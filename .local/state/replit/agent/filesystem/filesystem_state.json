{"file_contents":{"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","path":null,"size_bytes":2001,"size_tokens":null},"client/src/components/ui/sidebar.tsx":{"content":"import * as React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { VariantProps, cva } from \"class-variance-authority\";\nimport { PanelLeft } from \"lucide-react\";\n\nimport { useIsMobile } from \"@/hooks/use-is-mobile\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Separator } from \"@/components/ui/separator\";\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\";\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;\nconst SIDEBAR_WIDTH = \"16rem\";\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\";\nconst SIDEBAR_WIDTH_ICON = \"3rem\";\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\";\n\ntype SidebarContext = {\n  state: \"expanded\" | \"collapsed\";\n  open: boolean;\n  setOpen: (open: boolean) => void;\n  openMobile: boolean;\n  setOpenMobile: (open: boolean) => void;\n  isMobile: boolean;\n  toggleSidebar: () => void;\n};\n\nconst SidebarContext = React.createContext<SidebarContext | null>(null);\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext);\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\");\n  }\n\n  return context;\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean;\n    open?: boolean;\n    onOpenChange?: (open: boolean) => void;\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const isMobile = useIsMobile();\n    const [openMobile, setOpenMobile] = React.useState(false);\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen);\n    const open = openProp ?? _open;\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        const openState = typeof value === \"function\" ? value(open) : value;\n        if (setOpenProp) {\n          setOpenProp(openState);\n        } else {\n          _setOpen(openState);\n        }\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;\n      },\n      [setOpenProp, open],\n    );\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open);\n    }, [isMobile, setOpen, setOpenMobile]);\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault();\n          toggleSidebar();\n        }\n      };\n\n      window.addEventListener(\"keydown\", handleKeyDown);\n      return () => window.removeEventListener(\"keydown\", handleKeyDown);\n    }, [toggleSidebar]);\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\";\n\n    const contextValue = React.useMemo<SidebarContext>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      ],\n    );\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar\",\n              className,\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    );\n  },\n);\nSidebarProvider.displayName = \"SidebarProvider\";\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\";\n    variant?: \"sidebar\" | \"floating\" | \"inset\";\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\";\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className,\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      );\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <SheetHeader className=\"sr-only\">\n              <SheetTitle>Sidebar</SheetTitle>\n              <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n            </SheetHeader>\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      );\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden text-sidebar-foreground md:block\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\",\n          )}\n        />\n        <div\n          className={cn(\n            \"fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className,\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    );\n  },\n);\nSidebar.displayName = \"Sidebar\";\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar();\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event);\n        toggleSidebar();\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  );\n});\nSidebarTrigger.displayName = \"SidebarTrigger\";\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar();\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarRail.displayName = \"SidebarRail\";\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex w-full flex-1 flex-col bg-background\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarInset.displayName = \"SidebarInset\";\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarInput.displayName = \"SidebarInput\";\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  );\n});\nSidebarHeader.displayName = \"SidebarHeader\";\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  );\n});\nSidebarFooter.displayName = \"SidebarFooter\";\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  );\n});\nSidebarSeparator.displayName = \"SidebarSeparator\";\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarContent.displayName = \"SidebarContent\";\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  );\n});\nSidebarGroup.displayName = \"SidebarGroup\";\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\";\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarGroupAction.displayName = \"SidebarGroupAction\";\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n));\nSidebarGroupContent.displayName = \"SidebarGroupContent\";\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n));\nSidebarMenu.displayName = \"SidebarMenu\";\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n));\nSidebarMenuItem.displayName = \"SidebarMenuItem\";\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  },\n);\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean;\n    isActive?: boolean;\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>;\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref,\n  ) => {\n    const Comp = asChild ? Slot : \"button\";\n    const { isMobile, state } = useSidebar();\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    );\n\n    if (!tooltip) {\n      return button;\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      };\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    );\n  },\n);\nSidebarMenuButton.displayName = \"SidebarMenuButton\";\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean;\n    showOnHover?: boolean;\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarMenuAction.displayName = \"SidebarMenuAction\";\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className,\n    )}\n    {...props}\n  />\n));\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\";\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean;\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`;\n  }, []);\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[--skeleton-width] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  );\n});\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\";\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className,\n    )}\n    {...props}\n  />\n));\nSidebarMenuSub.displayName = \"SidebarMenuSub\";\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />);\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\";\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean;\n    size?: \"sm\" | \"md\";\n    isActive?: boolean;\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\";\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\";\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n};\n","path":null,"size_bytes":23790,"size_tokens":null},"client/src/lib/game/rendering/AnimationManager.ts":{"content":"export interface AnimationFrame {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface AnimationDefinition {\n  frames: AnimationFrame[];\n  frameDuration: number; // seconds per frame\n  loop: boolean;\n}\n\nexport class AnimationManager {\n  private animations: Map<string, AnimationDefinition> = new Map();\n  private currentAnimations: Map<string, {\n    currentFrame: number;\n    elapsed: number;\n    playing: boolean;\n  }> = new Map();\n\n  public addAnimation(name: string, frames: AnimationFrame[], frameDuration: number = 0.1, loop: boolean = true) {\n    this.animations.set(name, {\n      frames,\n      frameDuration,\n      loop\n    });\n  }\n\n  public startAnimation(animationName: string, instanceId: string) {\n    if (this.animations.has(animationName)) {\n      // Always reset the animation state when starting a new animation\n      this.currentAnimations.set(instanceId, {\n        currentFrame: 0,\n        elapsed: 0,\n        playing: true\n      });\n    }\n  }\n\n  public update(deltaTime: number, instanceId: string, animationName: string): AnimationFrame | null {\n    const animation = this.animations.get(animationName);\n    let state = this.currentAnimations.get(instanceId);\n\n    if (!animation) {\n      console.warn(`Animation ${animationName} not found`);\n      return null;\n    }\n\n    // Ensure deltaTime is a valid number\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) ? deltaTime : 0.016; // fallback to ~60fps\n\n    if (typeof deltaTime !== 'number' || isNaN(deltaTime)) {\n      console.warn(`Invalid deltaTime received: ${typeof deltaTime} (${deltaTime}), using fallback`);\n    }\n\n    // Initialize state if it doesn't exist\n    if (!state) {\n      state = {\n        currentFrame: 0,\n        elapsed: 0,\n        playing: true\n      };\n      this.currentAnimations.set(instanceId, state);\n      console.log(`Initialized animation state for ${animationName}, frames: ${animation.frames.length}, frameDuration: ${animation.frameDuration}`);\n    }\n\n    if (!state.playing) {\n      return animation.frames[state.currentFrame] || animation.frames[0];\n    }\n\n    state.elapsed += validDeltaTime;\n\n    if (state.elapsed >= animation.frameDuration) {\n      const oldFrame = state.currentFrame;\n      state.elapsed = 0; // Reset elapsed time completely\n      state.currentFrame++;\n\n      if (state.currentFrame >= animation.frames.length) {\n        if (animation.loop) {\n          state.currentFrame = 0;\n        } else {\n          state.currentFrame = animation.frames.length - 1;\n          state.playing = false;\n        }\n      }\n\n      // Only log frame changes occasionally to avoid spam\n      if (Math.random() < 0.1) {\n        console.log(`Animation ${animationName}: frame ${oldFrame} -> ${state.currentFrame} (${animation.frames.length} total)`);\n      }\n    }\n\n    return animation.frames[state.currentFrame] || animation.frames[0];\n  }\n\n  public getCurrentFrame(instanceId: string, animationName: string): AnimationFrame | null {\n    const animation = this.animations.get(animationName);\n    const state = this.currentAnimations.get(instanceId);\n\n    if (!animation || !state) {\n      return animation ? animation.frames[0] : null;\n    }\n\n    return animation.frames[state.currentFrame];\n  }\n}","path":null,"size_bytes":3263,"size_tokens":null},"client/src/lib/game/services/CollisionService.ts":{"content":"\nimport { ICollisionService } from './ICollisionService';\nimport { ICollidable } from '../core/interfaces/IGameObject';\n\nexport class CollisionService implements ICollisionService {\n  public checkCollision(obj1: ICollidable, obj2: ICollidable): boolean {\n    const obj1Width = obj1.collisionWidth || obj1.width;\n    const obj1Height = obj1.collisionHeight || obj1.height;\n    const obj2Width = obj2.collisionWidth || obj2.width;\n    const obj2Height = obj2.collisionHeight || obj2.height;\n    \n    return (\n      obj1.x - obj1Width / 2 < obj2.x + obj2Width / 2 &&\n      obj1.x + obj1Width / 2 > obj2.x - obj2Width / 2 &&\n      obj1.y - obj1Height / 2 < obj2.y + obj2Height / 2 &&\n      obj1.y + obj1Height / 2 > obj2.y - obj2Height / 2\n    );\n  }\n\n  public getDistance(obj1: ICollidable, obj2: ICollidable): number {\n    const dx = obj1.x - obj2.x;\n    const dy = obj1.y - obj2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}\n","path":null,"size_bytes":928,"size_tokens":null},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-2 w-full overflow-hidden rounded-full bg-primary/20\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","path":null,"size_bytes":792,"size_tokens":null},"client/src/lib/game/core/base/BaseWeapon.ts":{"content":"\nimport { IWeapon } from '../interfaces/IWeapon';\nimport { IProjectile } from '../interfaces/IProjectile';\n\nexport abstract class BaseWeapon implements IWeapon {\n  protected damage: number;\n  protected fireRate: number;\n  protected projectileSpeed: number;\n  protected lastFireTime: number = 0;\n\n  constructor(damage: number, fireRate: number, projectileSpeed: number) {\n    this.damage = damage;\n    this.fireRate = fireRate;\n    this.projectileSpeed = projectileSpeed;\n  }\n\n  abstract fire(deltaTime: number, x: number, y: number, direction?: { x: number; y: number }): IProjectile[];\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getFireRate(): number {\n    return this.fireRate;\n  }\n\n  protected canFire(deltaTime: number): boolean {\n    this.lastFireTime += deltaTime;\n    if (this.lastFireTime >= 1 / this.fireRate) {\n      this.lastFireTime = 0;\n      return true;\n    }\n    return false;\n  }\n}\n","path":null,"size_bytes":926,"size_tokens":null},"client/src/lib/game/factories/PlayerFactory.ts":{"content":"\nimport { IPlayer } from '../core/interfaces/IPlayer';\nimport { Player } from '../entities/characters/Player';\nimport { AssassinPlayer } from '../entities/characters/AssassinPlayer';\n\nexport type PlayerType = 'sylph' | 'assassin';\n\nexport class PlayerFactory {\n  public static createPlayer(type: PlayerType, x: number, y: number): IPlayer {\n    switch (type) {\n      case 'assassin':\n        return new AssassinPlayer(x, y);\n      case 'sylph':\n      default:\n        return new Player(x, y);\n    }\n  }\n}\n","path":null,"size_bytes":505,"size_tokens":null},"client/src/components/PowerUpSelection.tsx":{"content":"import { useState } from \"react\";\nimport { PowerUpDefinition } from \"../lib/game/entities/collectibles/PowerUp\";\nimport { POWERUP_DEFINITIONS } from \"../lib/game/config/PowerUpDefinitions\";\nimport { useGameState } from \"../lib/stores/useGameState\";\n\ninterface PowerUpSelectionProps {\n  onSelect: (powerUp: PowerUpDefinition) => void;\n  onClose: () => void;\n}\n\nexport default function PowerUpSelection({ onSelect, onClose }: PowerUpSelectionProps) {\n  const { selectedCharacter, spiderMode } = useGameState();\n  \n  const [selectedPowerUps] = useState(() => {\n    // Filter powerups based on character\n    let availablePowerUps = POWERUP_DEFINITIONS.filter(powerUp => {\n      // Universal powerups are always available\n      if (!powerUp.characterRestriction) return true;\n      \n      // Character-specific powerups\n      if (selectedCharacter?.id === \"sylph\" && powerUp.characterRestriction === \"sylph\") return true;\n      if (selectedCharacter?.id === \"assassin\" && powerUp.characterRestriction === \"assassin\") {\n        // For assassin, filter out spider modes if one is already selected\n        if (powerUp.id === \"big_spider\" && spiderMode === \"small\") return false;\n        if (powerUp.id === \"small_spiders\" && spiderMode === \"big\") return false;\n        return true;\n      }\n      \n      return false;\n    });\n    \n    // Randomly select 3 power-ups\n    const shuffled = [...availablePowerUps].sort(() => 0.5 - Math.random());\n    return shuffled.slice(0, 3);\n  });\n\n  const handleSelect = (powerUp: PowerUpDefinition) => {\n    onSelect(powerUp);\n    onClose();\n  };\n\n  return (\n    <div className=\"absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50\">\n      <div className=\"bg-gray-900 border-2 border-yellow-400 rounded-lg p-8 max-w-2xl w-full mx-4\">\n        <h2 className=\"text-3xl font-bold text-yellow-400 text-center mb-2\">LEVEL UP!</h2>\n        <p className=\"text-white text-center mb-6\">Choose your upgrade:</p>\n        \n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n          {selectedPowerUps.map((powerUp) => (\n            <button\n              key={powerUp.id}\n              onClick={() => handleSelect(powerUp)}\n              className=\"bg-gray-800 hover:bg-gray-700 border-2 border-gray-600 hover:border-yellow-400 rounded-lg p-4 transition-all duration-200 text-left group\"\n            >\n              <div className=\"flex items-center mb-3\">\n                <div \n                  className=\"w-8 h-8 rounded mr-3 shadow-lg\"\n                  style={{ \n                    backgroundColor: powerUp.color,\n                    boxShadow: `0 0 10px ${powerUp.color}50`\n                  }}\n                />\n                <h3 className=\"text-xl font-bold text-white group-hover:text-yellow-400\">\n                  {powerUp.name}\n                </h3>\n              </div>\n              <p className=\"text-gray-300 text-sm leading-relaxed\">\n                {powerUp.description}\n              </p>\n            </button>\n          ))}\n        </div>\n        \n        <p className=\"text-gray-400 text-center text-sm mt-4\">\n          Click on an upgrade to select it\n        </p>\n      </div>\n    </div>\n  );\n}","path":null,"size_bytes":3173,"size_tokens":null},"client/src/lib/game/rendering/Particle.ts":{"content":"export class Particle {\n  public x: number;\n  public y: number;\n  private vx: number;\n  private vy: number;\n  private color: string;\n  private life: number;\n  private maxLife: number;\n  private size: number;\n\n  constructor(x: number, y: number, vx: number, vy: number, color: string, life: number) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.color = color;\n    this.life = life;\n    this.maxLife = life;\n    this.size = Math.random() * 3 + 1;\n  }\n\n  public update(deltaTime: number) {\n    this.x += this.vx * deltaTime;\n    this.y += this.vy * deltaTime;\n    \n    // Apply gravity and friction\n    this.vy += 200 * deltaTime; // gravity\n    this.vx *= 0.98; // friction\n    this.vy *= 0.98;\n\n    this.life -= deltaTime;\n  }\n\n  public isAlive(): boolean {\n    return this.life > 0;\n  }\n\n  public render(ctx: CanvasRenderingContext2D) {\n    if (!this.isAlive()) return;\n\n    const alpha = this.life / this.maxLife;\n    const currentSize = this.size * alpha;\n\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = this.color;\n    ctx.fillRect(\n      this.x - currentSize / 2,\n      this.y - currentSize / 2,\n      currentSize,\n      currentSize\n    );\n    ctx.restore();\n  }\n}\n","path":null,"size_bytes":1220,"size_tokens":null},"client/src/lib/game/rendering/SpriteManager.ts":{"content":"export class SpriteManager {\n  private static instance: SpriteManager;\n  private sprites: Map<string, HTMLImageElement> = new Map();\n  private loadingPromises: Map<string, Promise<HTMLImageElement>> = new Map();\n\n  private constructor() {}\n\n  public static getInstance(): SpriteManager {\n    if (!SpriteManager.instance) {\n      SpriteManager.instance = new SpriteManager();\n    }\n    return SpriteManager.instance;\n  }\n\n  public async loadSprite(name: string, src: string): Promise<HTMLImageElement> {\n    // Return cached sprite if already loaded\n    if (this.sprites.has(name)) {\n      return this.sprites.get(name)!;\n    }\n\n    // Return existing loading promise if already loading\n    if (this.loadingPromises.has(name)) {\n      return this.loadingPromises.get(name)!;\n    }\n\n    // Create new loading promise\n    const loadingPromise = new Promise<HTMLImageElement>((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => {\n        this.sprites.set(name, img);\n        this.loadingPromises.delete(name);\n        console.log(`Loaded sprite: ${name} from ${src} (${img.naturalWidth}x${img.naturalHeight})`);\n        \n        // Debug spider sprites specifically\n        if (name.includes('spider')) {\n          console.log(`Spider sprite ${name}: dimensions ${img.naturalWidth}x${img.naturalHeight}, complete: ${img.complete}`);\n        }\n        \n        resolve(img);\n      };\n      img.onerror = () => {\n        this.loadingPromises.delete(name);\n        console.error(`Failed to load sprite: ${name} from ${src}`);\n        reject(new Error(`Failed to load sprite: ${name}`));\n      };\n      img.src = src;\n    });\n\n    this.loadingPromises.set(name, loadingPromise);\n    return loadingPromise;\n  }\n\n  public getSprite(name: string): HTMLImageElement | null {\n    return this.sprites.get(name) || null;\n  }\n\n  public async loadAllSprites(): Promise<void> {\n    const spritesToLoad = [\n      { name: \"player\", src: \"/assets/sprites/walking_Down_weapon.png\" },\n      { name: \"player_diagonal\", src: \"/assets/sprites/top_diagonal_sheet.png\" },\n      { name: \"player_forward\", src: \"/assets/sprites/forward-sheet_1749393148210.png\" },\n      { name: \"player_sideways\", src: \"/assets/sprites/Walking_Sideways_weapon.png\" },\n      { name: \"player_down\", src: \"/assets/sprites/walking_Down_weapon.png\" },\n      { name: \"player_diagonal_down\", src: \"/assets/sprites/Walking_diagonal_Down_weapon_1749410363417.png\" },\n      { name: \"player_up\", src: \"/assets/sprites/walking_up_weapon.png\" },\n      // Assassin character sprites\n      { name: \"assassin_diagonal_back\", src: \"/assets/sprites/assassin_diagonal_back.png\" },\n      { name: \"assassin_diagonal_front\", src: \"/assets/sprites/assassin_diagonal_front.png\" },\n      { name: \"assassin_down\", src: \"/assets/sprites/assassin_down.png\" },\n      { name: \"assassin_sideways\", src: \"/assets/sprites/assassin_sideways.png\" },\n      { name: \"assassin_up\", src: \"/assets/sprites/assassin_up.png\" },\n      { name: \"enemy_basic\", src: \"/assets/sprites/enemy_basic.png\" },\n      { name: \"enemy_fast\", src: \"/assets/sprites/enemy_fast.png\" },\n      { name: \"enemy_tank\", src: \"/assets/sprites/enemy_tank.png\" },\n      // Spider sprites\n      { name: \"spider_down\", src: \"/assets/sprites/spider/spider_down.png\" },\n      { name: \"spider_up\", src: \"/assets/sprites/spider/spider_up.png\" },\n      { name: \"spider_side\", src: \"/assets/sprites/spider/spider_side.png\" },\n      { name: \"spider_diagonal_down\", src: \"/assets/sprites/spider/spider_diagonal_down.png\" },\n      { name: \"spider_diagonal_up\", src: \"/assets/sprites/spider/spider_diagonal_up.png\" },\n      { name: \"spider_jumping\", src: \"/assets/sprites/spider/spider_jumping.png\" },\n      { name: \"objects\", src: \"/assets/tilesets/PNG/Objects.png\" },\n      { name: \"details\", src: \"/assets/tilesets/PNG/Details.png\" },\n      { name: \"flower_growing\", src: \"/assets/sprites/flower_growing.png\" },\n      { name: \"undead_tileset\", src: \"/assets/tilesets/PNG/Ground_new.png\" }\n    ];\n\n    try {\n      await Promise.all(\n        spritesToLoad.map(sprite => this.loadSprite(sprite.name, sprite.src))\n      );\n      console.log('All sprites loaded successfully');\n    } catch (error) {\n      console.error('Failed to load some sprites:', error);\n    }\n  }\n\n  public clearSprites(): void {\n    this.sprites.clear();\n    this.loadingPromises.clear();\n  }\n}","path":null,"size_bytes":4365,"size_tokens":null},"server/storage.ts":{"content":"import { users, type User, type InsertUser } from \"@shared/schema\";\n\n// modify the interface with any CRUD methods\n// you might need\n\nexport interface IStorage {\n  getUser(id: number): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n}\n\nexport class MemStorage implements IStorage {\n  private users: Map<number, User>;\n  currentId: number;\n\n  constructor() {\n    this.users = new Map();\n    this.currentId = 1;\n  }\n\n  async getUser(id: number): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    return Array.from(this.users.values()).find(\n      (user) => user.username === username,\n    );\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const id = this.currentId++;\n    const user: User = { ...insertUser, id };\n    this.users.set(id, user);\n    return user;\n  }\n}\n\nexport const storage = new MemStorage();\n","path":null,"size_bytes":1012,"size_tokens":null},"client/src/lib/game/core/interfaces/IProjectile.ts":{"content":"\nimport { IGameObject, IRenderable, IUpdatable, IDestroyable } from './IGameObject';\n\nexport interface IProjectile extends IGameObject, IRenderable, IUpdatable, IDestroyable {\n  getDamage(): number;\n  addHit(): boolean;\n}\n","path":null,"size_bytes":222,"size_tokens":null},"client/src/hooks/use-is-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","path":null,"size_bytes":565,"size_tokens":null},"client/src/lib/stores/useAudio.tsx":{"content":"import { create } from \"zustand\";\n\ninterface AudioState {\n  backgroundMusic: HTMLAudioElement | null;\n  bossMusic: HTMLAudioElement | null;\n  hitSound: HTMLAudioElement | null;\n  successSound: HTMLAudioElement | null;\n  levelUpSound: HTMLAudioElement | null;\n  playerHurtSound: HTMLAudioElement | null;\n  victorySound: HTMLAudioElement | null;\n  defeatSound: HTMLAudioElement | null;\n  isMuted: boolean;\n  musicVolume: number;\n  sfxVolume: number;\n\n  // Setter functions\n  setBackgroundMusic: (audio: HTMLAudioElement) => void;\n  setBossMusic: (audio: HTMLAudioElement) => void;\n  setHitSound: (audio: HTMLAudioElement) => void;\n  setSuccessSound: (audio: HTMLAudioElement) => void;\n  setLevelUpSound: (audio: HTMLAudioElement) => void;\n  setPlayerHurtSound: (audio: HTMLAudioElement) => void;\n  setVictorySound: (audio: HTMLAudioElement) => void;\n  setDefeatSound: (audio: HTMLAudioElement) => void;\n\n  // Control functions\n  toggleMute: () => void;\n  playHit: () => void;\n  playSuccess: () => void;\n  playLevelUp: () => void;\n  playPlayerHurt: () => void;\n  playVictory: () => void;\n  playDefeat: () => void;\n  playBossMusic: () => void;\n  stopBossMusic: () => void;\n  setMusicVolume: (volume: number) => void;\n  setSfxVolume: (volume: number) => void;\n}\n\nexport const useAudio = create<AudioState>((set, get) => ({\n  backgroundMusic: null,\n  bossMusic: null,\n  hitSound: null,\n  successSound: null,\n  levelUpSound: null,\n  playerHurtSound: null,\n  victorySound: null,\n  defeatSound: null,\n  isMuted: true, // Start muted by default\n  musicVolume: 0.3,\n  sfxVolume: 0.5,\n\n  setBackgroundMusic: (audio) => set({ backgroundMusic: audio }),\n  setBossMusic: (audio) => set({ bossMusic: audio }),\n  setHitSound: (audio) => set({ hitSound: audio }),\n  setSuccessSound: (audio) => set({ successSound: audio }),\n  setLevelUpSound: (audio) => set({ levelUpSound: audio }),\n  setPlayerHurtSound: (audio) => set({ playerHurtSound: audio }),\n  setVictorySound: (audio) => set({ victorySound: audio }),\n  setDefeatSound: (audio) => set({ defeatSound: audio }),\n\n  toggleMute: () => {\n    const { isMuted, backgroundMusic } = get();\n    const newMuted = !isMuted;\n\n    if (backgroundMusic) {\n      if (newMuted) {\n        backgroundMusic.pause();\n      } else {\n        backgroundMusic.play().catch((e) => {\n          console.log(\"Background music play prevented:\", e);\n        });\n      }\n    }\n\n    set({ isMuted: newMuted });\n  },\n\n  playHit: () => {\n    const { hitSound, isMuted } = get();\n    if (hitSound && !isMuted) {\n      const clone = hitSound.cloneNode() as HTMLAudioElement;\n      clone.volume = hitSound.volume;\n      clone.play().catch((e) => {\n        console.log(\"Hit sound play prevented:\", e);\n      });\n    }\n  },\n\n  playSuccess: () => {\n    const { successSound, isMuted } = get();\n    if (successSound && !isMuted) {\n      const clone = successSound.cloneNode() as HTMLAudioElement;\n      clone.volume = successSound.volume;\n      clone.play().catch((e) => {\n        console.log(\"Success sound play prevented:\", e);\n      });\n    }\n  },\n\n  playLevelUp: () => {\n    const { levelUpSound, isMuted } = get();\n    if (levelUpSound && !isMuted) {\n      const clone = levelUpSound.cloneNode() as HTMLAudioElement;\n      clone.volume = 0.8;\n      clone.play().catch((e) => {\n        console.log(\"Level up sound play prevented:\", e);\n      });\n    }\n  },\n\n  playPlayerHurt: () => {\n    const { playerHurtSound, isMuted, sfxVolume } = get();\n    if (playerHurtSound && !isMuted) {\n      const clone = playerHurtSound.cloneNode() as HTMLAudioElement;\n      clone.volume = 0.6 * sfxVolume;\n      clone.play().catch((e) => {\n        console.log(\"Player hurt sound play prevented:\", e);\n      });\n    }\n  },\n\n  playVictory: () => {\n    const { victorySound, isMuted, sfxVolume } = get();\n    if (victorySound && !isMuted) {\n      const clone = victorySound.cloneNode() as HTMLAudioElement;\n      clone.volume = 0.7 * sfxVolume;\n      clone.play().catch((e) => {\n        console.log(\"Victory sound play prevented:\", e);\n      });\n    }\n  },\n\n  playDefeat: () => {\n    const { defeatSound, isMuted, sfxVolume } = get();\n    if (defeatSound && !isMuted) {\n      const clone = defeatSound.cloneNode() as HTMLAudioElement;\n      clone.volume = 0.7 * sfxVolume;\n      clone.play().catch((e) => {\n        console.log(\"Defeat sound play prevented:\", e);\n      });\n    }\n  },\n\n  playBossMusic: () => {\n    const { bossMusic, backgroundMusic, isMuted, musicVolume } = get();\n    if (backgroundMusic) {\n      backgroundMusic.pause();\n    }\n    if (bossMusic && !isMuted) {\n      bossMusic.volume = musicVolume;\n      bossMusic.play().catch((e) => {\n        console.log(\"Boss music play prevented:\", e);\n      });\n    }\n  },\n\n  stopBossMusic: () => {\n    const { bossMusic, backgroundMusic, isMuted, musicVolume } = get();\n    if (bossMusic) {\n      bossMusic.pause();\n      bossMusic.currentTime = 0;\n    }\n    if (backgroundMusic && !isMuted) {\n      backgroundMusic.volume = musicVolume;\n      backgroundMusic.play().catch((e) => {\n        console.log(\"Background music play prevented:\", e);\n      });\n    }\n  },\n\n  setMusicVolume: (volume: number) => {\n    const { backgroundMusic, bossMusic } = get();\n    set({ musicVolume: volume });\n    if (backgroundMusic) {\n      backgroundMusic.volume = volume;\n    }\n    if (bossMusic) {\n      bossMusic.volume = volume;\n    }\n  },\n\n  setSfxVolume: (volume: number) => {\n    set({ sfxVolume: volume });\n  },\n}));","path":null,"size_bytes":5444,"size_tokens":null},"client/src/lib/game/weapons/OrbitalWeapon.ts":{"content":"export class OrbitalWeapon {\n  public x: number = 0;\n  public y: number = 0;\n  public width = 12;\n  public height = 12;\n  private angle = 0;\n  private radius = 50;\n  private rotationSpeed = 2; // radians per second\n  private damage = 3;\n  private damageTimer = 0;\n  private damageCooldown = 0.5; // seconds between damage ticks\n\n  public update(deltaTime: number, playerX: number, playerY: number): { x: number; y: number } {\n    this.angle += this.rotationSpeed * deltaTime;\n    this.damageTimer += deltaTime;\n\n    // Calculate orbital position\n    this.x = playerX + Math.cos(this.angle) * this.radius;\n    this.y = playerY + Math.sin(this.angle) * this.radius;\n\n    return { x: this.x, y: this.y };\n  }\n\n  public render(ctx: CanvasRenderingContext2D, x: number, y: number) {\n    // Draw orbital weapon as a spinning diamond\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(this.angle * 2);\n\n    // Outer glow\n    ctx.shadowColor = \"#4444ff\";\n    ctx.shadowBlur = 10;\n    ctx.fillStyle = \"#4444ff\";\n    ctx.fillRect(-6, -6, 12, 12);\n\n    // Inner core\n    ctx.shadowBlur = 0;\n    ctx.fillStyle = \"#aaaaff\";\n    ctx.fillRect(-3, -3, 6, 6);\n\n    ctx.restore();\n  }\n\n  public canDamage(): boolean {\n    return this.damageTimer >= this.damageCooldown;\n  }\n\n  public dealDamage(): number {\n    if (this.canDamage()) {\n      this.damageTimer = 0;\n      return this.damage;\n    }\n    return 0;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public upgrade() {\n    this.damage += 1;\n    this.rotationSpeed += 0.3;\n    this.radius += 5;\n  }\n}","path":null,"size_bytes":1562,"size_tokens":null},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","path":null,"size_bytes":756,"size_tokens":null},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","path":null,"size_bytes":768,"size_tokens":null},"client/src/lib/game/core/interfaces/IEnemy.ts":{"content":"\nimport { IEntity, IDamageable } from './IEntity';\n\nexport interface IEnemy extends IEntity, IDamageable {\n  getDamage(): number;\n  getScoreValue(): number;\n  getType(): string;\n}\n","path":null,"size_bytes":180,"size_tokens":null},"README.md":{"content":"\n# Vampire Survivors Clone\n\nA TypeScript-based survivor-style game built with React, Canvas API, and Express. Fight against endless waves of enemies using the mystical Sylph Blooms weapon system that spawns magical flower turrets.\n\n##  Game Features\n\n- **Infinite Survival Gameplay**: Survive endless waves of increasingly difficult enemies\n- **Unique Weapon System**: Sylph Blooms weapon that spawns magical flower turrets around the player\n- **Animated Character**: Fully animated player character with directional movement sprites\n- **Enemy Variety**: Multiple enemy types (Basic, Fast, Tank) with different behaviors\n- **Experience System**: Collect experience orbs to level up and gain power-ups\n- **Infinite World**: Procedurally generated tilemap with collision detection\n- **Audio System**: Background music and sound effects\n- **Power-Up System**: Upgrade damage, fire rate, flower capacity, and more\n\n##  Quick Start\n\n### Prerequisites\n\n- Node.js 18+ \n- npm\n\n### Installation & Running\n\n1. Clone the repository\n2. Install dependencies:\n```bash\nnpm install\n```\n\n3. Start the development server:\n```bash\nnpm run dev\n```\n\n4. Open your browser and navigate to the forwarded URL (typically port 5000)\n\n##  How to Play\n\n### Controls\n- **WASD** or **Arrow Keys**: Move your character\n- **M**: Toggle sound on/off\n- **R**: Restart the game\n- **Space** or **Click**: Start the game\n\n### Gameplay\n- Your character automatically fires the Sylph Blooms weapon\n- Magical flower turrets spawn around you and shoot at nearby enemies\n- Collect experience orbs dropped by defeated enemies\n- Level up to choose from powerful upgrades\n- Survive as long as possible against increasing waves\n\n### Weapon System: Sylph Blooms\n- Spawns magical flower turrets that persist for 15 seconds\n- Flowers automatically target and shoot at nearby enemies\n- Flowers have bloom stages that increase their damage over time\n- Maximum of 4-6 flowers active at once (upgradeable)\n- Flowers shoot magical orbs that home in on enemies\n\n##  Project Structure\n\n```\n client/                 # Frontend React application\n    public/            # Static assets\n       textures/      # Game sprites and textures\n       sounds/        # Audio files\n       Tileset/       # Tilemap assets\n    src/\n        components/    # React components\n        lib/\n           game/      # Game engine classes\n           stores/    # State management\n        pages/\n server/                # Backend Express server\n shared/                # Shared types and schemas\n migrations/            # Database migrations\n```\n\n### Key Game Classes\n\n- **GameEngine**: Main game loop and system coordination\n- **Player**: Character with animation, movement, and weapon systems\n- **SylphBloomsWeapon**: Unique flower-spawning weapon system\n- **InfiniteTileRenderer**: Procedural world generation with collision\n- **WaveManager**: Enemy spawning and difficulty progression\n- **SpriteManager**: Asset loading and management\n- **AnimationManager**: Character animation system\n\n##  Assets\n\nThe game uses pixel art assets including:\n- Player character sprites with directional animations\n- Enemy sprites (basic, fast, tank variants)\n- Tileset for world generation\n- Particle effects and UI elements\n\n##  Development\n\n### Available Scripts\n\n- `npm run dev`: Start development server\n- `npm run build`: Build for production\n- `npm run start`: Start production server\n- `npm run check`: TypeScript type checking\n- `npm run db:push`: Push database schema changes\n\n### Technology Stack\n\n**Frontend:**\n- React 18 with TypeScript\n- Canvas API for game rendering\n- Zustand for state management\n- Tailwind CSS for UI styling\n- Vite for bundling\n\n**Backend:**\n- Express.js with TypeScript\n- PostgreSQL with Drizzle ORM\n- Session-based authentication\n- WebSocket support\n\n**Game Engine:**\n- Custom TypeScript game engine\n- Canvas 2D rendering\n- Delta time-based animations\n- Collision detection system\n- Particle effects system\n\n##  Audio\n\nThe game features:\n- Background music during gameplay\n- Sound effects for hits and interactions\n- Mute/unmute functionality\n- Howler.js for audio management\n\n##  Database\n\nUses PostgreSQL with Drizzle ORM for:\n- User sessions\n- Game statistics\n- Leaderboards (if implemented)\n\nEnvironment variable required:\n- `DATABASE_URL`: PostgreSQL connection string\n\n##  Deployment\n\nThe project is configured for deployment on Replit:\n- Production build script included\n- Database migrations supported\n- Environment variables configured\n- Port 5000 forwarding enabled\n\n##  Game Mechanics\n\n### Enemy Types\n- **Basic**: Standard speed and health\n- **Fast**: Quick movement, low health\n- **Tank**: Slow but high health and damage\n\n### Power-Up System\n- **Damage**: Increase weapon damage\n- **Fire Rate**: Reduce flower spawn interval\n- **Flower Capacity**: Increase maximum flowers\n- **Flower Lifespan**: Extend flower duration\n- **Health**: Restore player health\n\n### Collision System\n- Player vs enemies\n- Projectiles vs enemies\n- Player vs experience orbs\n- Tile-based world collision\n\n##  Future Enhancements\n\n- Additional weapon types\n- Boss battles\n- Multiplayer support\n- Achievement system\n- Save/load functionality\n- Mobile touch controls\n\n##  License\n\nThis project is available under the MIT License.\n\n##  Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Test thoroughly\n5. Submit a pull request\n\n##  Troubleshooting\n\n### Common Issues\n\n**Game won't start:**\n- Check browser console for errors\n- Ensure all assets are loading properly\n- Verify database connection\n\n**Performance issues:**\n- Reduce particle count in development mode\n- Check for memory leaks in game loops\n- Monitor FPS counter in debug mode\n\n**Audio not working:**\n- Check browser autoplay policies\n- Verify audio files are accessible\n- Test mute/unmute functionality\n\nFor more help, check the browser console for detailed error messages.\n","path":null,"size_bytes":6134,"size_tokens":null},"client/src/components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogTrigger,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","path":null,"size_bytes":3849,"size_tokens":null},"client/src/lib/game/entities/spiders/MechanicalSpider.ts":{"content":"\nimport { ISpider } from \"../../core/interfaces/ISpider\";\nimport { IEnemy } from \"../../core/interfaces/IEnemy\";\nimport { AnimationManager } from \"../../rendering/AnimationManager\";\n\nexport class MechanicalSpider implements ISpider {\n  public x: number;\n  public y: number;\n  public width = 120;\n  public height = 68;\n  public instanceId: string;\n  public currentAnimation = \"spider_idle\";\n  public lastDirection = { x: 0, y: 1 };\n\n  private vx = 0;\n  private vy = 0;\n  private speed = 150;\n  private alive = true;\n  private target: IEnemy | null = null;\n  private attachedToEnemy = false;\n  private damage = 2;\n  private damageTimer = 0;\n  private damageCooldown = 0.5;\n  private searchRadius = 120;\n  private spiderMode: \"normal\" | \"big\" | \"small\" = \"normal\";\n  private maxHealth = 1;\n  private isJumping = false;\n  private jumpStartPos = { x: 0, y: 0 };\n  private jumpTargetPos = { x: 0, y: 0 };\n  private jumpProgress = 0;\n  private jumpDuration = 0.4;\n  private jumpHeight = 50;\n  private animationManager: AnimationManager;\n  private lastAnimationFrame: any = null;\n  private lastAnimationSwitch = 0;\n\n  constructor(x: number, y: number, mode: \"normal\" | \"big\" | \"small\" = \"normal\") {\n    this.x = x;\n    this.y = y;\n    this.spiderMode = mode;\n    this.instanceId = `mechanical_spider_${Date.now()}_${Math.random()}`;\n    this.animationManager = new AnimationManager();\n\n    this.applyModeStats();\n    this.setupAnimations();\n  }\n\n  private applyModeStats() {\n    switch (this.spiderMode) {\n      case \"big\":\n        this.damage = 8;\n        this.maxHealth = 3;\n        this.damageCooldown = 0.3;\n        this.speed = 120;\n        this.searchRadius = 150;\n        this.width = 160;\n        this.height = 90;\n        break;\n      case \"small\":\n        this.damage = 1;\n        this.maxHealth = 1;\n        this.damageCooldown = 0.8;\n        this.speed = 200;\n        this.searchRadius = 100;\n        this.width = 80;\n        this.height = 45;\n        break;\n      default:\n        this.damage = 2;\n        this.maxHealth = 1;\n        this.damageCooldown = 0.5;\n        this.speed = 150;\n        this.searchRadius = 120;\n        this.width = 120;\n        this.height = 68;\n        break;\n    }\n  }\n\n  private setupAnimations() {\n    const walkFrames = [];\n    for (let i = 0; i < 30; i++) {\n      walkFrames.push({\n        x: i * 800,\n        y: 0,\n        width: 800,\n        height: 450\n      });\n    }\n\n    const idleFrames = [{ x: 0, y: 0, width: 800, height: 450 }];\n\n    const jumpingFrames = [];\n    const jumpFrameWidth = 1408 / 4;\n    for (let i = 0; i < 4; i++) {\n      jumpingFrames.push({\n        x: i * jumpFrameWidth,\n        y: 0,\n        width: jumpFrameWidth,\n        height: 272\n      });\n    }\n\n    this.animationManager.addAnimation(\"spider_idle\", idleFrames, 0.5, true);\n    this.animationManager.addAnimation(\"spider_walk_down\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_up\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_side\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_diagonal\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_jumping\", jumpingFrames, 0.1, false);\n\n    this.lastAnimationFrame = idleFrames[0];\n    this.animationManager.startAnimation(\"spider_idle\", this.instanceId);\n  }\n\n  public update(deltaTime: number, enemies: IEnemy[], playerPos: { x: number; y: number }) {\n    if (!this.alive) return;\n\n    let targetAnimation = \"spider_idle\";\n\n    if (this.attachedToEnemy && this.target) {\n      this.damageTimer += deltaTime;\n\n      if (!this.target.isAlive()) {\n        this.attachedToEnemy = false;\n        this.target = null;\n        return;\n      }\n\n      if (this.x !== this.target.x || this.y !== this.target.y) {\n        this.x = this.target.x;\n        this.y = this.target.y;\n      }\n\n      if (this.damageTimer >= this.damageCooldown) {\n        this.target.takeDamage(this.damage);\n        this.damageTimer = 0;\n      }\n\n      targetAnimation = \"spider_idle\";\n    } else {\n      if (!this.target || !this.target.isAlive()) {\n        this.findNearestEnemy(enemies, playerPos);\n      }\n\n      if (this.target) {\n        const dx = this.target.x - this.x;\n        const dy = this.target.y - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 35) {\n          this.attachedToEnemy = true;\n          this.isJumping = false;\n          this.x = this.target.x;\n          this.y = this.target.y;\n        } else if (this.isJumping) {\n          this.jumpProgress += deltaTime / this.jumpDuration;\n\n          if (this.jumpProgress >= 1) {\n            this.x = this.jumpTargetPos.x;\n            this.y = this.jumpTargetPos.y;\n            this.isJumping = false;\n            this.jumpProgress = 0;\n\n            if (this.target && this.target.isAlive()) {\n              const finalDx = this.target.x - this.x;\n              const finalDy = this.target.y - this.y;\n              const finalDistance = Math.sqrt(finalDx * finalDx + finalDy * finalDy);\n\n              if (finalDistance < 35) {\n                this.attachedToEnemy = true;\n                this.x = this.target.x;\n                this.y = this.target.y;\n              }\n            }\n\n            targetAnimation = \"spider_idle\";\n          } else {\n            const t = this.jumpProgress;\n            const newX = this.jumpStartPos.x + (this.jumpTargetPos.x - this.jumpStartPos.x) * t;\n            const newY = this.jumpStartPos.y + (this.jumpTargetPos.y - this.jumpStartPos.y) * t;\n\n            if (Math.abs(newX - this.x) > 1 || Math.abs(newY - this.y) > 1) {\n              this.x = newX;\n              this.y = newY;\n            }\n\n            if (this.jumpProgress < 0.1) {\n              this.lastDirection.x = (this.jumpTargetPos.x - this.jumpStartPos.x) / distance;\n              this.lastDirection.y = (this.jumpTargetPos.y - this.jumpStartPos.y) / distance;\n            }\n\n            targetAnimation = \"spider_jumping\";\n          }\n        } else {\n          this.isJumping = true;\n          this.jumpStartPos = { x: this.x, y: this.y };\n          this.jumpTargetPos = { x: this.target.x, y: this.target.y };\n          this.jumpProgress = 0;\n\n          this.lastDirection.x = dx / distance;\n          this.lastDirection.y = dy / distance;\n\n          targetAnimation = \"spider_jumping\";\n        }\n      } else {\n        targetAnimation = \"spider_idle\";\n      }\n    }\n\n    if (this.currentAnimation !== targetAnimation) {\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n      this.lastAnimationSwitch = Date.now();\n    }\n  }\n\n  private findNearestEnemy(enemies: IEnemy[], playerPos: { x: number; y: number }) {\n    let nearestEnemy: IEnemy | null = null;\n    let nearestDistance = Infinity;\n\n    for (const enemy of enemies) {\n      if (!enemy.isAlive()) continue;\n\n      const dx = enemy.x - playerPos.x;\n      const dy = enemy.y - playerPos.y;\n      const distanceFromPlayer = Math.sqrt(dx * dx + dy * dy);\n\n      if (distanceFromPlayer <= this.searchRadius && distanceFromPlayer < nearestDistance) {\n        nearestDistance = distanceFromPlayer;\n        nearestEnemy = enemy;\n      }\n    }\n\n    this.target = nearestEnemy;\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public destroy(): void {\n    this.alive = false;\n  }\n\n  public get isAttached(): boolean {\n    return this.attachedToEnemy;\n  }\n\n  public get health(): number {\n    return this.target?.getHealth() || 0;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0) {\n    return;\n  }\n}\n","path":null,"size_bytes":7670,"size_tokens":null},"client/src/lib/game/entities/AssassinPlayer.ts":{"content":"import { Player } from \"./Player\";\nimport { Enemy } from \"./Enemy\";\nimport { Projectile } from \"../weapons/Projectile\";\nimport { MechanicalSpider } from \"./MechanicalSpider\";\nimport { SpriteManager } from \"../rendering/SpriteManager\";\nimport { AnimationManager } from \"../rendering/AnimationManager\";\n\n// Global tracking for assassin players\nlet globalAssassinPlayerCount = 0;\n\nexport class AssassinPlayer extends Player {\n  private followerSpider: MechanicalSpider | null = null;\n  private spiderSpawned = false;\n  private tileRenderer: any = null;\n  private spiderMode: \"normal\" | \"big\" | \"small\" = \"normal\";\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.speed = 250; // Faster than base player\n    this.maxHealth = 80; // Less health than base player\n    this.health = this.maxHealth;\n\n    globalAssassinPlayerCount++;\n    const instanceId = `assassin_${Date.now()}_${Math.random()}`;\n    console.log(`Creating AssassinPlayer instance: ${instanceId}. Global count: ${globalAssassinPlayerCount}`);\n\n    // Override the weapon from Player to prevent flower spawning\n    this.weapon = null;\n\n    // Ensure instanceId is set for assassin\n    this.instanceId = `assassin_${Date.now()}_${Math.random()}`;\n\n    // Spawn spider immediately as a child\n    this.spawnSpider();\n\n    // Use inherited animation system from Player - no need for custom setup\n  }\n\n  public update(deltaTime: number, input: any, canvasWidth: number, canvasHeight: number, tileRenderer: any) {\n    // Handle movement\n    let moveX = 0;\n    let moveY = 0;\n\n    if (input.left) moveX -= 1;\n    if (input.right) moveX += 1;\n    if (input.up) moveY -= 1;\n    if (input.down) moveY += 1;\n\n    // Normalize diagonal movement\n    if (moveX !== 0 && moveY !== 0) {\n      moveX *= 0.707;\n      moveY *= 0.707;\n    }\n\n    // Update last move direction if player is moving\n    if (moveX !== 0 || moveY !== 0) {\n      this.lastMoveDirection = { x: moveX, y: moveY };\n      this.isMoving = true;\n    } else {\n      this.isMoving = false;\n    }\n\n    // Calculate new position\n    const newX = this.x + moveX * this.speed * deltaTime;\n    const newY = this.y + moveY * this.speed * deltaTime;\n\n    // Check tile collisions if tileRenderer is available\n    if (tileRenderer && tileRenderer.isSolidAt) {\n      // Check horizontal movement\n      if (!this.checkTileCollision(newX, this.y, tileRenderer)) {\n        this.x = newX;\n      }\n      // Check vertical movement\n      if (!this.checkTileCollision(this.x, newY, tileRenderer)) {\n        this.y = newY;\n      }\n    } else {\n      // Fallback: no tile collision, just update position\n      this.x = newX;\n      this.y = newY;\n    }\n\n    // Determine which animation to use based on movement (same logic as Player)\n    let targetAnimation = \"idle\";\n    if (this.isMoving) {\n      if (moveY < 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal\";\n      } else if (moveY > 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal_down\";\n      } else if (moveY > 0) {\n        targetAnimation = \"walk_down\";\n      } else if (moveY < 0 && Math.abs(moveX) === 0) {\n        targetAnimation = \"walk_up\";\n      } else if (Math.abs(moveX) > 0 && moveY === 0) {\n        targetAnimation = \"walk_sideways\";\n      } else {\n        targetAnimation = \"walk\";\n      }\n    }\n\n    // Switch animation if needed\n    if (this.currentAnimation !== targetAnimation) {\n      if (targetAnimation === \"idle\" && this.lastAnimationFrame) {\n        this.animationManager.addAnimation(\"idle\", [this.lastAnimationFrame], 1, true);\n      }\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n    }\n  }\n\n  private spawnSpider() {\n    if (!this.spiderSpawned && !this.followerSpider) {\n      // Spawn spider close to player\n      const offsetX = -60;\n      const offsetY = -20;\n\n      this.followerSpider = new MechanicalSpider(this.x + offsetX, this.y + offsetY, this.spiderMode);\n      this.spiderSpawned = true;\n      console.log(`[${this.instanceId}] Spawned ${this.spiderMode} spider at (${this.x + offsetX}, ${this.y + offsetY})`);\n      \n      // Register with tile renderer if available\n      if (this.tileRenderer) {\n        this.registerSpiderWithTileRenderer();\n      }\n    }\n  }\n\n  private registerSpiderWithTileRenderer() {\n    if (this.followerSpider && this.tileRenderer) {\n      this.tileRenderer.addSpider({\n        x: this.followerSpider.x,\n        y: this.followerSpider.y,\n        instanceId: this.followerSpider.instanceId || `mechanical_spider_${Date.now()}`,\n        currentAnimation: this.followerSpider.currentAnimation || 'spider_idle',\n        lastDirection: this.followerSpider.lastDirection || { x: 0, y: 1 }\n      });\n    }\n  }\n\n  public setTileRenderer(tileRenderer: any) {\n    this.tileRenderer = tileRenderer;\n    // Register spider if it exists\n    if (this.followerSpider) {\n      this.registerSpiderWithTileRenderer();\n    }\n  }\n\n  public updateTileRenderer(tileRenderer: any) {\n    // Register spider with tile renderer if it exists and isn't already registered\n    if (this.followerSpider && tileRenderer) {\n      // Add spider to tile renderer for proper background rendering\n      tileRenderer.addSpider({\n        x: this.followerSpider.x,\n        y: this.followerSpider.y,\n        instanceId: this.followerSpider.instanceId || `mechanical_spider_${Date.now()}`,\n        currentAnimation: this.followerSpider.currentAnimation || 'spider_idle',\n        lastDirection: this.followerSpider.lastDirection || { x: 0, y: 1 }\n      });\n    }\n  }\n\n\n  public updateSpiders(deltaTime: number, enemies: Enemy[], playerPos: { x: number; y: number }) {\n    // Update child spider if it exists\n    if (this.followerSpider) {\n      this.followerSpider.update(deltaTime, enemies, { x: this.x, y: this.y });\n\n      // Update tile renderer with spider position and animation state\n      if (this.tileRenderer) {\n        this.tileRenderer.updateSpider(\n          this.followerSpider.instanceId || `mechanical_spider_${Date.now()}`,\n          this.followerSpider.x,\n          this.followerSpider.y,\n          this.followerSpider.currentAnimation || 'spider_idle',\n          this.followerSpider.lastDirection || { x: 0, y: 1 }\n        );\n      }\n    } else if (this.followerSpider && !this.followerSpider.isAlive()) {\n      // Clean up dead spider\n      this.followerSpider = null;\n      console.log(`[${this.instanceId}] Child spider died`);\n    }\n  }\n\n  public renderSpiders(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0) {\n    if (this.followerSpider) {\n      this.followerSpider.render(ctx, deltaTime, cameraX, cameraY);\n    }\n  }\n\n  public getSpiders(): MechanicalSpider[] {\n    return this.followerSpider ? [this.followerSpider] : [];\n  }\n\n  public getFollowerSpider(): MechanicalSpider | null {\n    return this.followerSpider;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number) {\n    const spriteManager = SpriteManager.getInstance();\n\n    // Ensure deltaTime is a valid number\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) ? deltaTime : 0.016;\n\n    // Get current animation frame\n    const frame = this.animationManager.update(validDeltaTime, this.instanceId, this.currentAnimation);\n\n    if (frame) {\n      this.lastAnimationFrame = frame;\n    }\n\n    // Use assassin-specific sprites based on current animation (map to Player animation names)\n    let spriteToUse = null;\n    if (this.currentAnimation === \"walk_up\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_up\");\n    } else if (this.currentAnimation === \"walk_down\" || this.currentAnimation === \"idle\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_down\");\n    } else if (this.currentAnimation === \"walk_sideways\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_sideways\");\n    } else if (this.currentAnimation === \"walk_diagonal\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_diagonal_back\");\n    } else if (this.currentAnimation === \"walk_diagonal_down\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_diagonal_front\");\n    } else if (this.currentAnimation === \"walk\" || this.currentAnimation === \"walk_forward\") {\n      spriteToUse = spriteManager.getSprite(\"assassin_down\"); // Use down as default walking\n    }\n\n    // Fallback to down sprite if no specific sprite found\n    if (!spriteToUse) {\n      spriteToUse = spriteManager.getSprite(\"assassin_down\");\n    }\n\n    if (spriteToUse) {\n      // Store the current frame as last animation frame for idle use\n      if (frame && this.currentAnimation !== \"idle\") {\n        this.lastAnimationFrame = frame;\n      }\n\n      // Calculate proper draw dimensions based on animation to preserve aspect ratio\n      let drawWidth = this.width;\n      let drawHeight = this.height;\n\n      // For assassin animations (800x450), maintain proper aspect ratio\n      const aspectRatio = 800 / 450; // ~1.78\n      drawWidth = this.height * aspectRatio; // Keep height, adjust width\n\n      // Calculate draw position (center the sprite)\n      const drawX = this.x - drawWidth / 2;\n      const drawY = this.y - drawHeight / 2;\n\n      // Create a temporary canvas to process the sprite and remove white outline\n      const tempCanvas = document.createElement('canvas');\n      const tempCtx = tempCanvas.getContext('2d')!;\n\n      if (frame && spriteToUse) {\n        tempCanvas.width = frame.width;\n        tempCanvas.height = frame.height;\n\n        // Draw the sprite frame to temp canvas\n        tempCtx.drawImage(\n          spriteToUse,\n          frame.x,\n          frame.y,\n          frame.width,\n          frame.height,\n          0,\n          0,\n          frame.width,\n          frame.height\n        );\n\n        // Remove white outline by making white pixels transparent\n        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\n        const data = imageData.data;\n\n        for (let i = 0; i < data.length; i += 4) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n\n          // If pixel is white or very close to white, make it transparent\n          if (r > 240 && g > 240 && b > 240) {\n            data[i + 3] = 0; // Set alpha to 0 (transparent)\n          }\n        }\n\n        tempCtx.putImageData(imageData, 0, 0);\n        spriteToUse = tempCanvas as any; // Use processed canvas as sprite\n      }\n\n      // Handle sprite flipping based on movement direction (same logic as Player)\n      const shouldFlip =\n        (this.currentAnimation === \"walk_diagonal\" && this.lastMoveDirection.x > 0) ||\n        (this.currentAnimation === \"walk_diagonal_down\" && this.lastMoveDirection.x < 0) ||\n        (this.currentAnimation === \"walk_sideways\" && this.lastMoveDirection.x < 0) ||\n        (this.currentAnimation !== \"walk_diagonal\" && this.currentAnimation !== \"walk_sideways\" && \n         this.currentAnimation !== \"walk_down\" && this.currentAnimation !== \"walk_up\" && \n         this.currentAnimation !== \"walk_diagonal_down\" && this.lastMoveDirection.x > 0);\n\n      ctx.save();\n      if (shouldFlip) {\n        ctx.translate(this.x, this.y);\n        ctx.scale(-1, 1);\n        ctx.translate(-this.x, -this.y);\n      }\n\n      try {\n        if (frame) {\n          // Use animation frame\n          ctx.drawImage(\n            spriteToUse,\n            0, 0,\n            frame.width, frame.height,\n            drawX, drawY,\n            drawWidth, drawHeight\n          );\n        } else {\n          // Fallback - use full sprite (800x450)\n          ctx.drawImage(\n            spriteToUse,\n            0, 0, 800, 450,\n            drawX, drawY,\n            drawWidth, drawHeight\n          );\n        }\n      } catch (error) {\n        console.error(\"Error drawing assassin sprite:\", error);\n        // Fallback: render a colored rectangle\n        ctx.fillStyle = \"#ff0000\"; \n        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);\n      }\n\n      ctx.restore();\n    } else {\n      // Fallback: render a colored rectangle\n      ctx.fillStyle = \"#ff00ff\"; \n      ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);\n    }\n\n    // Render health bar\n    this.renderHealthBar(ctx);\n\n    // Note: Spiders should be rendered by GameEngine to prevent double rendering\n    // this.spiderWeapon.renderSpiders(ctx, 0, 0);\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D) {\n    // Draw health bar if damaged\n    if (this.health < this.maxHealth) {\n      const barWidth = this.width;\n      const barHeight = 3;\n      const healthPercent = this.health / this.maxHealth;\n\n      // Background\n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(\n        this.x,\n        this.y - 10,\n        barWidth,\n        barHeight\n      );\n\n      // Health\n      ctx.fillStyle = \"#44ff44\";\n      ctx.fillRect(\n        this.x,\n        this.y - 10,\n        barWidth * healthPercent,\n        barHeight\n      );\n    }\n  }\n\n  private checkTileCollision(x: number, y: number, tileRenderer: any): boolean {\n    // Check collision points around the player\n    const margin = 2; // Small margin to prevent getting stuck\n    const points = [\n      { x: x + margin, y: y + margin }, // Top-left\n      { x: x + this.width - margin, y: y + margin }, // Top-right\n      { x: x + margin, y: y + this.height - margin }, // Bottom-left\n      { x: x + this.width - margin, y: y + this.height - margin } // Bottom-right\n    ];\n\n    return points.some(point => tileRenderer.isSolidAt(point.x, point.y));\n  }\n\n  public fire(deltaTime: number, direction?: { x: number; y: number }): Projectile[] {\n    // Assassin doesn't fire traditional projectiles, uses spiders instead\n    return this.spiderWeapon.fire(deltaTime, this.x, this.y, direction);\n  }\n\n  public fireWeapon(deltaTime: number): Projectile[] {\n    // Override parent method to prevent flower weapon firing\n    return [];\n  }\n\n  public getWeapon() {\n    // Return null to prevent flower weapon from being used\n    return null;\n  }\n\n  public setBigSpiderMode(enable: boolean) {\n    if (enable && this.spiderMode !== \"big\") {\n      this.spiderMode = \"big\";\n      this.respawnSpider();\n      // Update game state\n      import(\"../../stores/useGameState\").then(({ useGameState }) => {\n        useGameState.getState().setSpiderMode(\"big\");\n      });\n    }\n  }\n\n  public setSmallSpidersMode(enable: boolean) {\n    if (enable && this.spiderMode !== \"small\") {\n      this.spiderMode = \"small\";\n      this.respawnSpider();\n      // Update game state\n      import(\"../../stores/useGameState\").then(({ useGameState }) => {\n        useGameState.getState().setSpiderMode(\"small\");\n      });\n    }\n  }\n\n  private respawnSpider() {\n    // Remove existing spider\n    if (this.followerSpider) {\n      this.followerSpider.destroy();\n      this.followerSpider = null;\n      this.spiderSpawned = false;\n    }\n\n    // Spawn new spider with mode-specific stats\n    this.spawnSpider();\n  }\n}","path":null,"size_bytes":14986,"size_tokens":null},"client/src/lib/game/core/interfaces/ISpider.ts":{"content":"\nimport { IGameObject, IRenderable, IUpdatable, IDestroyable } from './IGameObject';\nimport { IEnemy } from './IEnemy';\n\nexport interface ISpider extends IGameObject, IRenderable, IUpdatable, IDestroyable {\n  update(deltaTime: number, enemies: IEnemy[], playerPos: { x: number; y: number }): void;\n  isAttached: boolean;\n  health: number;\n  instanceId: string;\n  currentAnimation: string;\n  lastDirection: { x: number; y: number };\n}\n","path":null,"size_bytes":434,"size_tokens":null},"client/src/lib/game/managers/SpiderManager.ts":{"content":"\nimport { ISpider } from \"../core/interfaces/ISpider\";\nimport { IEnemy } from \"../core/interfaces/IEnemy\";\nimport { MechanicalSpider } from \"../entities/spiders/MechanicalSpider\";\n\nexport class SpiderManager {\n  private spiders: ISpider[] = [];\n  private spiderMode: \"normal\" | \"big\" | \"small\" = \"normal\";\n  private maxSpiders = 1;\n\n  constructor(mode: \"normal\" | \"big\" | \"small\" = \"normal\") {\n    this.spiderMode = mode;\n  }\n\n  public spawnSpider(x: number, y: number): void {\n    if (this.spiders.length < this.maxSpiders) {\n      const spider = new MechanicalSpider(x, y, this.spiderMode);\n      this.spiders.push(spider);\n    }\n  }\n\n  public update(deltaTime: number, enemies: IEnemy[], playerPos: { x: number; y: number }): void {\n    // Remove dead spiders\n    this.spiders = this.spiders.filter(spider => spider.isAlive());\n\n    // Update alive spiders\n    this.spiders.forEach(spider => {\n      spider.update(deltaTime, enemies, playerPos);\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0): void {\n    this.spiders.forEach(spider => {\n      spider.render(ctx, deltaTime, cameraX, cameraY);\n    });\n  }\n\n  public getSpiders(): ISpider[] {\n    return [...this.spiders];\n  }\n\n  public setMode(mode: \"normal\" | \"big\" | \"small\"): void {\n    if (this.spiderMode !== mode) {\n      this.spiderMode = mode;\n      this.respawnAllSpiders();\n    }\n  }\n\n  public upgradeMaxSpiders(): void {\n    this.maxSpiders++;\n  }\n\n  private respawnAllSpiders(): void {\n    this.spiders.forEach(spider => spider.destroy());\n    this.spiders = [];\n  }\n\n  public destroy(): void {\n    this.spiders.forEach(spider => spider.destroy());\n    this.spiders = [];\n  }\n}\n","path":null,"size_bytes":1716,"size_tokens":null},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nconst getLocalStorage = (key: string): any =>\n  JSON.parse(window.localStorage.getItem(key) || \"null\");\nconst setLocalStorage = (key: string, value: any): void =>\n  window.localStorage.setItem(key, JSON.stringify(value));\n\nexport { getLocalStorage, setLocalStorage };\n","path":null,"size_bytes":438,"size_tokens":null},"client/src/lib/game/managers/UndeadTileMap.ts":{"content":"\nexport interface TileDefinition {\n  id: number;\n  name: string;\n  solid: boolean;\n  variants?: number[];\n}\n\nexport class UndeadTileMap {\n  // Tile definitions for the 5x5 grid (25 tiles total) - using 16x16 pixel tiles\n  public static readonly TILES: { [key: string]: TileDefinition } = {\n    // Row 0 (0-4): Base dirt variants\n    BASE_DIRT_1: { id: 0, name: 'Base Dirt 1 (default)', solid: false },\n    BASE_DIRT_2: { id: 1, name: 'Base Dirt 2 (variant)', solid: false },\n    BASE_DIRT_3: { id: 2, name: 'Base Dirt 3 (variant)', solid: false },\n    BASE_DIRT_CRACK: { id: 3, name: 'Base Dirt + Crack', solid: false },\n    BASE_DIRT_BONE: { id: 4, name: 'Base Dirt + Bone', solid: false },\n\n    // Row 1 (5-9): Edges and center variants\n    TOP_EDGE: { id: 5, name: 'Top Edge', solid: false },\n    BOTTOM_EDGE: { id: 6, name: 'Bottom Edge', solid: false },\n    LEFT_EDGE: { id: 7, name: 'Left Edge', solid: false },\n    RIGHT_EDGE: { id: 8, name: 'Right Edge', solid: false },\n    CENTER_CRACKED: { id: 9, name: 'Center Cracked Variant', solid: false },\n\n    // Row 2 (10-14): Corners and overlays\n    TOP_LEFT_CORNER: { id: 10, name: 'Top-Left Corner', solid: false },\n    TOP_RIGHT_CORNER: { id: 11, name: 'Top-Right Corner', solid: false },\n    BOTTOM_LEFT_CORNER: { id: 12, name: 'Bottom-Left Corner', solid: false },\n    BOTTOM_RIGHT_CORNER: { id: 13, name: 'Bottom-Right Corner', solid: false },\n    ROCK_CLUSTER: { id: 14, name: 'Rock Cluster Overlay', solid: false },\n\n    // Row 3 (15-19): Details and overlays\n    BLOOD_SPLATTER: { id: 15, name: 'Blood Splatter', solid: false },\n    BONE_OVERLAY: { id: 16, name: 'Bone Overlay 2', solid: false },\n    MOSS_PATCH: { id: 17, name: 'Moss Patch', solid: false },\n    DEAD_GRASS: { id: 18, name: 'Dead Grass', solid: false },\n    SMALL_STONE: { id: 19, name: 'Small Stone Detail', solid: false },\n\n    // Row 4 (20-24): Additional textures\n    MUD_PATCH: { id: 20, name: 'Mud Patch', solid: false },\n    STONE_MOSS: { id: 21, name: 'Stone + Moss', solid: false },\n    GRAVEL_CLUSTER: { id: 22, name: 'Gravel Cluster', solid: false },\n    SUBTLE_SHADOW: { id: 23, name: 'Overlay (Subtle Shadow)', solid: false },\n    SEAMLESS_FILLER: { id: 24, name: 'Seamless Filler (Alt)', solid: false }\n  };\n\n  // Tile variants for natural variation - updated for new tileset\n  public static readonly GROUND_VARIANTS = [0, 1, 2, 3, 4]; // Base dirt variants\n  public static readonly DETAIL_VARIANTS = [15, 16, 17, 18, 19]; // Blood, bones, moss, grass, stones\n  public static readonly TEXTURE_VARIANTS = [20, 21, 22, 23, 24]; // Mud, stone+moss, gravel, shadow, filler\n  public static readonly EDGE_VARIANTS = [5, 6, 7, 8]; // Edge tiles\n  public static readonly CORNER_VARIANTS = [10, 11, 12, 13]; // Corner tiles\n\n  public static getTileDefinition(id: number): TileDefinition | null {\n    for (const tile of Object.values(this.TILES)) {\n      if (tile.id === id) return tile;\n    }\n    return null;\n  }\n\n  public static isSolid(tileId: number): boolean {\n    const tile = this.getTileDefinition(tileId);\n    return tile ? tile.solid : false;\n  }\n}\n","path":null,"size_bytes":3094,"size_tokens":null},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-3.5 w-3.5 fill-primary\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","path":null,"size_bytes":1410,"size_tokens":null},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","path":null,"size_bytes":2712,"size_tokens":null},"client/src/lib/game/rendering/UndeadTileRenderer.ts":{"content":"import { SpriteManager } from './SpriteManager';\nimport { TileMapGenerator, TileMapCell } from '../managers/TileMapGenerator';\n\nexport class UndeadTileRenderer {\n  private spriteManager: SpriteManager;\n  private tileSize: number = 64;\n  private map: TileMapCell[][];\n\n  constructor() {\n    this.spriteManager = SpriteManager.getInstance();\n    this.map = TileMapGenerator.generateUndeadScene();\n  }\n\n  public async loadUndeadSprites(): Promise<void> {\n    const spritePromises = [\n      this.spriteManager.loadSprite('undead_ground', `/Tileset/PNG/Ground_new.png?v=${Date.now()}&r=${Math.random()}&force=true`),\n      this.spriteManager.loadSprite('undead_objects', '/craftpix-net-695666-free-undead-tileset-top-down-pixel-art/PNG/Objects.png'),\n      this.spriteManager.loadSprite('undead_details', '/craftpix-net-695666-free-undead-tileset-top-down-pixel-art/PNG/Details.png'),\n    ];\n\n    try {\n      await Promise.all(spritePromises);\n      console.log('Undead tileset sprites loaded successfully');\n    } catch (error) {\n      console.warn('Some undead sprites failed to load:', error);\n    }\n  }\n\n  public drawUndeadScene(ctx: CanvasRenderingContext2D, offsetX: number = 0, offsetY: number = 0): void {\n    const groundSprite = this.spriteManager.getSprite('undead_ground');\n    const objectsSprite = this.spriteManager.getSprite('undead_objects');\n    const detailsSprite = this.spriteManager.getSprite('undead_details');\n\n    // Enable high-quality rendering\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n\n    const srcTileSize = 256; // Source tile size in the new tileset (256x256 pixels)\n\n    for (let y = 0; y < 16; y++) {\n      for (let x = 0; x < 16; x++) {\n        const cell = this.map[y][x];\n        const drawX = offsetX + x * this.tileSize;\n        const drawY = offsetY + y * this.tileSize;\n\n        // Draw ground layer using new tileset coordinates\n        if (groundSprite) {\n          this.drawTileFromCoords(ctx, groundSprite, cell.groundTile, drawX, drawY, srcTileSize);\n        } else {\n          // Fallback to colored rectangles with undead theme\n          this.drawFallbackTile(ctx, cell.groundTile, drawX, drawY, 'ground');\n        }\n\n        // Draw object layer\n        if (cell.objectTile !== undefined) {\n          if (objectsSprite) {\n            this.drawTile(ctx, objectsSprite, cell.objectTile, drawX, drawY, srcTileSize);\n          } else {\n            this.drawFallbackTile(ctx, cell.objectTile, drawX, drawY, 'object');\n          }\n        }\n\n        // Draw detail layer\n        if (cell.detailTile !== undefined) {\n          if (detailsSprite) {\n            this.drawTile(ctx, detailsSprite, cell.detailTile, drawX, drawY, srcTileSize);\n          } else {\n            this.drawFallbackTile(ctx, cell.detailTile, drawX, drawY, 'detail');\n          }\n        }\n      }\n    }\n\n    // Add atmospheric fog overlay\n    this.drawFogOverlay(ctx, offsetX, offsetY);\n  }\n\n  private drawTile(ctx: CanvasRenderingContext2D, sprite: HTMLImageElement, tileIndex: number, x: number, y: number, srcTileSize: number): void {\n    const tilesPerRow = Math.floor(sprite.width / srcTileSize);\n    const srcX = (tileIndex % tilesPerRow) * srcTileSize;\n    const srcY = Math.floor(tileIndex / tilesPerRow) * srcTileSize;\n\n    ctx.drawImage(\n      sprite,\n      srcX, srcY, srcTileSize, srcTileSize,\n      x, y, this.tileSize, this.tileSize\n    );\n  }\n\n  // New method to draw tiles using direct pixel coordinates from the tileset mapping\n  private drawTileFromCoords(ctx: CanvasRenderingContext2D, sprite: HTMLImageElement, tileIndex: number, x: number, y: number, srcTileSize: number): void {\n    // Always use the first tile (top-left) as the ground tile\n    const srcX = 0;\n    const srcY = 0;\n    \n    ctx.drawImage(\n      sprite,\n      srcX, srcY, srcTileSize, srcTileSize,\n      x, y, this.tileSize, this.tileSize\n    );\n  }\n\n  private drawFallbackTile(ctx: CanvasRenderingContext2D, tileIndex: number, x: number, y: number, layer: 'ground' | 'object' | 'detail'): void {\n    let color = '#2a1f15'; // Default dark earth\n\n    if (layer === 'ground') {\n      const groundColors = ['#2a1f15', '#3d2f1f', '#1e2a1e', '#4a3a2a', '#2f2520', '#5a4a35', '#332922', '#453525'];\n      color = groundColors[tileIndex % groundColors.length];\n    } else if (layer === 'object') {\n      const objectColors = ['#8b4513', '#654321', '#3e2723', '#5d4037', '#4e342e', '#6d4c41', '#795548', '#a0522d'];\n      color = objectColors[tileIndex % objectColors.length];\n    } else {\n      const detailColors = ['#faf0e6', '#deb887', '#f5deb3', '#cd853f', '#228b22', '#8fbc8f', '#9acd32', '#e6e6fa'];\n      color = detailColors[tileIndex % detailColors.length];\n    }\n\n    ctx.fillStyle = color;\n    ctx.fillRect(x, y, this.tileSize, this.tileSize);\n\n    // Add simple visual indicators for fallback\n    if (layer === 'object') {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.fillRect(x + 4, y + 4, this.tileSize - 8, this.tileSize - 8);\n    } else if (layer === 'detail') {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\n      ctx.fillRect(x + 8, y + 8, this.tileSize - 16, this.tileSize - 16);\n    }\n  }\n\n  private drawFogOverlay(ctx: CanvasRenderingContext2D, offsetX: number, offsetY: number): void {\n    // Create subtle fog effect\n    const gradient = ctx.createRadialGradient(\n      offsetX + 8 * this.tileSize, offsetY + 8 * this.tileSize, 0,\n      offsetX + 8 * this.tileSize, offsetY + 8 * this.tileSize, 12 * this.tileSize\n    );\n\n    gradient.addColorStop(0, 'rgba(180, 180, 200, 0.05)');\n    gradient.addColorStop(0.5, 'rgba(160, 160, 180, 0.1)');\n    gradient.addColorStop(1, 'rgba(140, 140, 160, 0.15)');\n\n    ctx.fillStyle = gradient;\n    ctx.fillRect(offsetX, offsetY, 16 * this.tileSize, 16 * this.tileSize);\n  }\n\n  public getMapAsString(): string {\n    return TileMapGenerator.exportAsGrid(this.map);\n  }\n\n  public regenerateMap(): void {\n    this.map = TileMapGenerator.generateUndeadScene();\n  }\n}","path":null,"size_bytes":5968,"size_tokens":null},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","path":null,"size_bytes":4873,"size_tokens":null},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-primary/10\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","path":null,"size_bytes":266,"size_tokens":null},"client/src/lib/game/services/AudioService.ts":{"content":"\nimport { IAudioService } from './IAudioService';\nimport { useAudio } from '../../stores/useAudio';\n\nexport class AudioService implements IAudioService {\n  public playHit(): void {\n    const audioState = useAudio.getState();\n    if (!audioState.isMuted) {\n      audioState.playHit();\n    }\n  }\n\n  public playSuccess(): void {\n    const audioState = useAudio.getState();\n    if (!audioState.isMuted) {\n      audioState.playSuccess();\n    }\n  }\n\n  public playBackgroundMusic(): void {\n    const audioState = useAudio.getState();\n    if (audioState.backgroundMusic && !audioState.isMuted) {\n      audioState.backgroundMusic.play().catch(console.warn);\n    }\n  }\n\n  public stopBackgroundMusic(): void {\n    const audioState = useAudio.getState();\n    if (audioState.backgroundMusic) {\n      audioState.backgroundMusic.pause();\n    }\n  }\n\n  public toggleMute(): void {\n    const audioState = useAudio.getState();\n    audioState.toggleMute();\n\n    if (audioState.backgroundMusic) {\n      if (audioState.isMuted) {\n        this.stopBackgroundMusic();\n      } else {\n        this.playBackgroundMusic();\n      }\n    }\n  }\n\n  public isMuted(): boolean {\n    return useAudio.getState().isMuted;\n  }\n}\n","path":null,"size_bytes":1190,"size_tokens":null},"client/src/lib/game/entities/ExperienceOrb.ts":{"content":"import { GameObject } from \"./Player\";\n\nexport class ExperienceOrb implements GameObject {\n  public x: number;\n  public y: number;\n  public width = 8;\n  public height = 8;\n  private value: number;\n  private lifetime = 10; // seconds before disappearing\n  private attractRadius = 80;\n  private collectRadius = 20;\n  private attracted = false;\n  private pulseTime = 0;\n\n  constructor(x: number, y: number, value: number = 5) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }) {\n    this.lifetime -= deltaTime;\n    this.pulseTime += deltaTime * 3;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Check if player is within attraction radius\n    if (distance <= this.attractRadius) {\n      this.attracted = true;\n    }\n\n    // Move towards player if attracted\n    if (this.attracted && distance > this.collectRadius) {\n      const speed = 200; // pixels per second\n      const moveX = (dx / distance) * speed * deltaTime;\n      const moveY = (dy / distance) * speed * deltaTime;\n      \n      this.x += moveX;\n      this.y += moveY;\n    }\n  }\n\n  public isExpired(): boolean {\n    return this.lifetime <= 0;\n  }\n\n  public canBeCollected(playerPos: { x: number; y: number }): boolean {\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= this.collectRadius;\n  }\n\n  public getValue(): number {\n    return this.value;\n  }\n\n  public render(ctx: CanvasRenderingContext2D) {\n    const pulse = Math.sin(this.pulseTime) * 0.3 + 1;\n    const size = this.width * pulse;\n    \n    // Glow effect\n    ctx.save();\n    ctx.shadowColor = \"#44ff44\";\n    ctx.shadowBlur = this.attracted ? 15 : 8;\n    \n    // Main orb\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(\n      this.x - size / 2,\n      this.y - size / 2,\n      size,\n      size\n    );\n\n    // Inner highlight\n    ctx.shadowBlur = 0;\n    ctx.fillStyle = \"#88ff88\";\n    ctx.fillRect(\n      this.x - size / 4,\n      this.y - size / 4,\n      size / 2,\n      size / 2\n    );\n    \n    ctx.restore();\n\n    // Lifetime indicator (only when low)\n    if (this.lifetime < 3) {\n      const lifetimePercent = this.lifetime / 3;\n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(this.x - this.width / 2, this.y + this.height / 2 + 1, this.width, 2);\n      ctx.fillStyle = \"#44ff44\";\n      ctx.fillRect(this.x - this.width / 2, this.y + this.height / 2 + 1, this.width * lifetimePercent, 2);\n    }\n  }\n}","path":null,"size_bytes":2593,"size_tokens":null},"client/src/lib/game/core/base/BaseEntity.ts":{"content":"\nimport { IEntity } from '../interfaces/IEntity';\n\nexport abstract class BaseEntity implements IEntity {\n  public x: number;\n  public y: number;\n  public width: number;\n  public height: number;\n  protected alive: boolean = true;\n\n  constructor(x: number, y: number, width: number, height: number) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  abstract update(deltaTime: number, ...args: any[]): void;\n  abstract render(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX?: number, cameraY?: number): void;\n\n  public getPosition(): { x: number; y: number } {\n    return { x: this.x, y: this.y };\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public destroy(): void {\n    this.alive = false;\n  }\n}\n","path":null,"size_bytes":766,"size_tokens":null},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","path":null,"size_bytes":1148,"size_tokens":null},"client/src/components/ui/chart.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","path":null,"size_bytes":10481,"size_tokens":null},"client/src/lib/game/weapons/Projectile.ts":{"content":"export class Projectile {\n  public x: number;\n  public y: number;\n  public width = 8;\n  public height = 8;\n  public vx: number;\n  public vy: number;\n  private damage: number;\n  private alive = true;\n  private lifetime = 8; // seconds\n  private piercing = false;\n  private hitCount = 0;\n  private maxHits = 1;\n  private isSylphOrb = false;\n\n  constructor(x: number, y: number, vx: number, vy: number, damage: number) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.damage = damage;\n  }\n\n  public update(deltaTime: number) {\n    if (!this.alive) return;\n\n    // Ensure deltaTime is valid and reasonable (cap at 1/30th second to prevent large jumps)\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) && deltaTime > 0 ? \n      Math.min(deltaTime, 1/30) : 0.016;\n\n    // Update position\n    this.x += this.vx * validDeltaTime;\n    this.y += this.vy * validDeltaTime;\n\n    // Debug logging for first few frames to verify movement\n    if (this.lifetime > 2.9 && this.lifetime < 3.0) {\n      console.log(`Projectile position: (${this.x.toFixed(1)}, ${this.y.toFixed(1)}), velocity: (${this.vx.toFixed(1)}, ${this.vy.toFixed(1)})`);\n    }\n\n    this.lifetime -= validDeltaTime;\n    if (this.lifetime <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public destroy() {\n    this.alive = false;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public setSylphOrb(isSylph: boolean) {\n    this.isSylphOrb = isSylph;\n  }\n\n  public isSylphOrbProjectile(): boolean {\n    return this.isSylphOrb;\n  }\n\n  public isPiercing(): boolean {\n    return this.piercing;\n  }\n\n  public setPiercing(piercing: boolean, maxHits: number = 3) {\n    this.piercing = piercing;\n    this.maxHits = maxHits;\n  }\n\n  public isSylph(): boolean {\n    return this.isSylphOrb;\n  }\n\n  public addHit(): boolean {\n    if (this.piercing) {\n      this.hitCount++;\n      if (this.hitCount >= this.maxHits) {\n        this.destroy();\n        return true; // Projectile should be destroyed\n      }\n      return false; // Projectile continues\n    } else {\n      this.destroy();\n      return true; // Regular projectile is destroyed after one hit\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number = 0, cameraY: number = 0): void {\n    const screenX = this.x - cameraX;\n    const screenY = this.y - cameraY;\n\n    ctx.save();\n\n    if (this.isSylphOrb) {\n      // Render Sylph Orb with magical pink/purple glow\n      const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;\n\n      // Outer glow\n      ctx.shadowColor = \"#e91e63\";\n      ctx.shadowBlur = 15;\n      ctx.fillStyle = `rgba(233, 30, 99, ${pulse})`;\n      ctx.beginPath();\n      ctx.arc(screenX, screenY, this.width / 2 + 2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Inner core\n      ctx.shadowBlur = 0;\n      ctx.fillStyle = \"#ffffff\";\n      ctx.beginPath();\n      ctx.arc(screenX, screenY, this.width / 4, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Sparkle trail effect\n      if (Math.random() < 0.5) {\n        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8})`;\n        ctx.beginPath();\n        ctx.arc(\n          screenX + (Math.random() - 0.5) * 10,\n          screenY + (Math.random() - 0.5) * 10,\n          1,\n          0,\n          Math.PI * 2\n        );\n        ctx.fill();\n      }\n    } else if (this.damage >= 1.5) {\n      // Render magical emerald energy bolt - make it bigger\n      // Outer glow\n      ctx.shadowColor = \"#50c878\";\n      ctx.shadowBlur = 12;\n      ctx.fillStyle = \"#50c878\";\n      ctx.beginPath();\n      ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Inner core\n      ctx.shadowBlur = 0;\n      ctx.fillStyle = \"#90ee90\";\n      ctx.beginPath();\n      ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Sparkle effect\n      ctx.fillStyle = \"#ffffff\";\n      ctx.beginPath();\n      ctx.arc(screenX - 2, screenY - 2, 1, 0, Math.PI * 2);\n      ctx.fill();\n    } else {\n      // Regular projectile - make it much larger and more visible\n      const size = 8; // Increased from 4\n\n      // Bright yellow projectile\n      ctx.fillStyle = \"#ffff00\";\n      ctx.fillRect(\n        screenX - size / 2,\n        screenY - size / 2,\n        size,\n        size\n      );\n\n      // Add a bright white center\n      ctx.fillStyle = \"#ffffff\";\n      ctx.fillRect(\n        screenX - 2,\n        screenY - 2,\n        4,\n        4\n      );\n\n      // Add bright red outline for maximum visibility\n      ctx.strokeStyle = \"#ff0000\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(\n        screenX - size / 2,\n        screenY - size / 2,\n        size,\n        size\n      );\n\n      // Add additional glow effect\n      ctx.shadowColor = \"#ffff00\";\n      ctx.shadowBlur = 6;\n      ctx.fillStyle = \"#ffff00\";\n      ctx.beginPath();\n      ctx.arc(screenX, screenY, size / 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.restore();\n  }\n}","path":null,"size_bytes":4953,"size_tokens":null},"client/src/lib/game/weapons/Weapon.ts":{"content":"import { BaseWeapon } from \"./WeaponTypes\";\nimport { Projectile } from \"./projectiles/Projectile\";\nimport { Enemy } from \"../entities/enemies/Enemy\";\n\nexport class Weapon extends BaseWeapon {\n  constructor(fireRate: number = 2, damage: number = 10, projectileSpeed: number = 300) {\n    super(fireRate, damage, projectileSpeed);\n  }\n\n  public fire(deltaTime: number, playerX: number, playerY: number, direction?: { x: number; y: number }): Projectile[] {\n    if (!this.updateFireTimer(deltaTime)) {\n      return [];\n    }\n\n    const dir = direction || { x: 1, y: 0 };\n    const magnitude = Math.sqrt(dir.x * dir.x + dir.y * dir.y);\n    const normalizedX = magnitude > 0 ? dir.x / magnitude : 1;\n    const normalizedY = magnitude > 0 ? dir.y / magnitude : 0;\n\n    const projectile = new Projectile(\n      playerX,\n      playerY,\n      normalizedX * this.projectileSpeed,\n      normalizedY * this.projectileSpeed,\n      this.damage\n    );\n\n    return [projectile];\n  }\n\n  public abstract update(deltaTime: number, ...args: any[]): void;\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    // Render projectiles with camera offset\n    this.projectiles.forEach(projectile => {\n      projectile.render(ctx, cameraX, cameraY);\n    });\n  }\n}","path":null,"size_bytes":1275,"size_tokens":null},"client/src/lib/game/entities/Enemy.ts":{"content":"import { GameObject } from \"./Player\";\nimport { SpriteManager } from '../rendering/SpriteManager';\n\nexport class Enemy implements GameObject {\n  public x: number;\n  public y: number;\n  public width = 80;\n  public height = 80;\n  public collisionWidth = 32; // Smaller collision box\n  public collisionHeight = 32;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  private alive = true;\n  private type: \"basic\" | \"fast\" | \"tank\";\n\n  constructor(x: number, y: number, type: \"basic\" | \"fast\" | \"tank\" = \"basic\") {\n    this.x = x;\n    this.y = y;\n    this.type = type;\n\n    // Set properties based on enemy type\n    switch (type) {\n      case \"fast\":\n        this.speed = 80;\n        this.health = 1;\n        this.maxHealth = 1;\n        this.damage = 15;\n        this.scoreValue = 15;\n        this.width = 70;\n        this.height = 70;\n        this.collisionWidth = 28;\n        this.collisionHeight = 28;\n        break;\n      case \"tank\":\n        this.speed = 30;\n        this.health = 5;\n        this.maxHealth = 5;\n        this.damage = 30;\n        this.scoreValue = 50;\n        this.width = 120;\n        this.height = 120;\n        this.collisionWidth = 48;\n        this.collisionHeight = 48;\n        break;\n      default: // basic\n        this.speed = 50;\n        this.health = 2;\n        this.maxHealth = 2;\n        this.damage = 20;\n        this.scoreValue = 10;\n        this.width = 80;\n        this.height = 80;\n        this.collisionWidth = 32;\n        this.collisionHeight = 32;\n        break;\n    }\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }) {\n    if (!this.alive) return;\n\n    // Move towards player\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance > 0) {\n      const moveX = (dx / distance) * this.speed * deltaTime;\n      const moveY = (dy / distance) * this.speed * deltaTime;\n\n      this.x += moveX;\n      this.y += moveY;\n    }\n  }\n\n  public takeDamage(damage: number) {\n    this.health -= damage;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number) {\n    if (!this.alive) return;\n\n    const spriteManager = SpriteManager.getInstance();\n    let spriteName = 'enemy_basic';\n    let fallbackColor = \"#ff4444\";\n\n    // Determine sprite and fallback color based on type\n    if (this.speed > 60) {\n      spriteName = 'enemy_fast';\n      fallbackColor = \"#ff8844\"; // fast = orange\n    } else if (this.maxHealth > 2) {\n      spriteName = 'enemy_tank';\n      fallbackColor = \"#ff44ff\"; // tank = magenta\n    }\n\n    const enemySprite = spriteManager.getSprite(spriteName);\n\n    if (enemySprite) {\n      // Draw static sprite\n      ctx.drawImage(\n        enemySprite,\n        this.x - this.width / 2,\n        this.y - this.height / 2,\n        this.width,\n        this.height\n      );\n    } else {\n      // Fallback to colored squares if sprite not loaded\n      ctx.fillStyle = fallbackColor;\n      ctx.fillRect(\n        this.x - this.width / 2,\n        this.y - this.height / 2,\n        this.width,\n        this.height\n      );\n    }\n\n    // Draw health bar if damaged\n    if (this.health < this.maxHealth) {\n      const barWidth = this.width;\n      const barHeight = 3;\n      const healthPercent = this.health / this.maxHealth;\n\n      // Background\n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(\n        this.x - barWidth / 2,\n        this.y - this.height / 2 - 8,\n        barWidth,\n        barHeight\n      );\n\n      // Health\n      ctx.fillStyle = \"#44ff44\";\n      ctx.fillRect(\n        this.x - barWidth / 2,\n        this.y - this.height / 2 - 8,\n        barWidth * healthPercent,\n        barHeight\n      );\n    }\n  }\n}","path":null,"size_bytes":4010,"size_tokens":null},"client/src/components/ui/interface.tsx":{"content":"import { useEffect } from \"react\";\nimport { useGame } from \"@/lib/stores/useGame\";\nimport { useAudio } from \"@/lib/stores/useAudio\";\nimport { Button } from \"./button\";\nimport { Card, CardContent, CardFooter, CardHeader, CardTitle } from \"./card\";\nimport { Confetti } from \"../game/Confetti\";\nimport { VolumeX, Volume2, RotateCw, Trophy } from \"lucide-react\";\n\nexport function Interface() {\n  const restart = useGame((state) => state.restart);\n  const phase = useGame((state) => state.phase);\n  const { isMuted, toggleMute } = useAudio();\n\n  // Handle clicks on the interface in the ready phase to start the game\n  useEffect(() => {\n    if (phase === \"ready\") {\n      const handleClick = () => {\n        document.activeElement?.blur(); // Remove focus from any button\n        const event = new KeyboardEvent(\"keydown\", { code: \"Space\" });\n        window.dispatchEvent(event);\n      };\n\n      window.addEventListener(\"click\", handleClick);\n      return () => window.removeEventListener(\"click\", handleClick);\n    }\n  }, [phase]);\n\n  return (\n    <>\n      <Confetti />\n      \n      {/* Top-right corner UI controls */}\n      <div className=\"fixed top-4 right-4 flex gap-2 z-10\">\n        <Button\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={toggleMute}\n          title={isMuted ? \"Unmute\" : \"Mute\"}\n        >\n          {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}\n        </Button>\n        \n        <Button\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={restart}\n          title=\"Restart Game\"\n        >\n          <RotateCw size={18} />\n        </Button>\n      </div>\n      \n      {/* Game completion overlay */}\n      {phase === \"ended\" && (\n        <div className=\"fixed inset-0 flex items-center justify-center z-20 bg-black/30\">\n          <Card className=\"w-full max-w-md mx-4 shadow-lg\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center justify-center gap-2\">\n                <Trophy className=\"text-yellow-500\" />\n                Level Complete!\n              </CardTitle>\n            </CardHeader>\n            \n            <CardContent>\n              <p className=\"text-center text-muted-foreground\">\n                Congratulations! You successfully navigated the course.\n              </p>\n            </CardContent>\n            \n            <CardFooter className=\"flex justify-center\">\n              <Button onClick={restart} className=\"w-full\">\n                Play Again\n              </Button>\n            </CardFooter>\n          </Card>\n        </div>\n      )}\n      \n      {/* Instructions panel */}\n      <div className=\"fixed bottom-4 left-4 z-10\">\n        <Card className=\"w-auto max-w-xs bg-background/80 backdrop-blur-sm\">\n          <CardContent className=\"p-4\">\n            <h3 className=\"font-medium mb-2\">Controls:</h3>\n            <ul className=\"text-sm space-y-1 text-muted-foreground\">\n              <li>WASD or Arrow Keys: Move the ball</li>\n              <li>Space: Jump</li>\n              <li>R: Restart game</li>\n              <li>M: Toggle sound</li>\n            </ul>\n          </CardContent>\n        </Card>\n      </div>\n    </>\n  );\n}\n","path":null,"size_bytes":3154,"size_tokens":null},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","path":null,"size_bytes":1753,"size_tokens":null},"client/src/lib/game/core/interfaces/IEntity.ts":{"content":"\nimport { IGameObject, IRenderable, IUpdatable, IDestroyable } from './IGameObject';\n\nexport interface IEntity extends IGameObject, IRenderable, IUpdatable, IDestroyable {\n  getPosition(): { x: number; y: number };\n}\n\nexport interface IDamageable {\n  takeDamage(amount: number): void;\n  getHealth(): number;\n  getMaxHealth(): number;\n}\n\nexport interface IHealable {\n  heal(amount: number): void;\n}\n","path":null,"size_bytes":398,"size_tokens":null},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","path":null,"size_bytes":1723,"size_tokens":null},"client/src/lib/game/rendering/CameraSystem.ts":{"content":"\nexport interface Camera {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport class CameraSystem {\n  public x: number = 0;\n  public y: number = 0;\n  public width: number;\n  public height: number;\n  private followSpeed: number = 0.1;\n  private smoothing: boolean = false;\n  \n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n  }\n\n  public update(targetX: number, targetY: number, deltaTime: number): void {\n    // Center the camera on the target - use pixel-perfect positioning\n    this.x = Math.floor(targetX - this.width / 2);\n    this.y = Math.floor(targetY - this.height / 2);\n  }\n\n  public setSize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n  }\n\n  public setFollowSpeed(speed: number): void {\n    this.followSpeed = speed;\n  }\n\n  public setSmoothing(enabled: boolean): void {\n    this.smoothing = enabled;\n  }\n\n  public worldToScreen(worldX: number, worldY: number): { x: number; y: number } {\n    return {\n      x: worldX - this.x,\n      y: worldY - this.y\n    };\n  }\n\n  public screenToWorld(screenX: number, screenY: number): { x: number; y: number } {\n    return {\n      x: screenX + this.x,\n      y: screenY + this.y\n    };\n  }\n\n  public isInView(worldX: number, worldY: number, objectWidth: number = 0, objectHeight: number = 0): boolean {\n    return !(worldX + objectWidth < this.x || \n             worldX > this.x + this.width ||\n             worldY + objectHeight < this.y || \n             worldY > this.y + this.height);\n  }\n\n  public getViewBounds(): { left: number; right: number; top: number; bottom: number } {\n    return {\n      left: this.x,\n      right: this.x + this.width,\n      top: this.y,\n      bottom: this.y + this.height\n    };\n  }\n}\n","path":null,"size_bytes":1775,"size_tokens":null},"client/src/components/GameUI.tsx":{"content":"import { useGameState } from \"../lib/stores/useGameState\";\nimport { useAudio } from \"../lib/stores/useAudio\";\nimport BossHealthBar from \"./BossHealthBar\";\nimport BossWarning from \"./BossWarning\";\nimport ComboDisplay from \"./ComboDisplay\";\nimport Minimap from \"./Minimap\";\n\nexport default function GameUI() {\n  const { phase, score, health, wave, maxHealth, experience, experienceToNext, level, selectedCharacter, isBossActive, showBossWarning, comboCount, comboMultiplier, currency, totalKills } = useGameState();\n  const { isMuted, toggleMute } = useAudio();\n\n  if (phase === \"ready\") {\n    return (\n      <div className=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 text-white\">\n        <div className=\"text-center\">\n          <h1 className=\"text-6xl font-bold mb-4 text-red-500\">VAMPIRE SURVIVORS</h1>\n          <p className=\"text-xl mb-8\">Survive the endless waves of enemies!</p>\n          <div className=\"space-y-2 text-lg\">\n            <p><strong>WASD</strong> or <strong>Arrow Keys</strong> - Move</p>\n            <p><strong>Weapons fire automatically</strong></p>\n            <p><strong>M</strong> - Toggle sound</p>\n            <p><strong>R</strong> - Restart game</p>\n            <div className=\"mt-6\">\n              <p className=\"text-yellow-400 mb-2\">Sylph Guardian - Nature magic with flower turrets</p>\n              <p className=\"text-yellow-400 mb-2\">Shadow Assassin - Fast & deadly with spider companions</p>\n            </div>\n            <div className=\"mt-4 p-4 bg-red-900/50 rounded-lg border border-red-500\">\n              <p className=\"text-red-300 font-bold\">Boss fights every 5 waves!</p>\n              <p className=\"text-sm text-gray-300 mt-1\">Defeat powerful bosses to earn bonus rewards</p>\n            </div>\n          </div>\n          <p className=\"text-sm mt-8 text-gray-400\">Press any key or click to start</p>\n        </div>\n      </div>\n    );\n  }\n\n  if (phase !== \"playing\") return null;\n\n  const healthPercentage = (health / maxHealth) * 100;\n  const experiencePercentage = (experience / experienceToNext) * 100;\n  const isBossWave = wave % 5 === 0;\n\n  return (\n    <div className=\"absolute inset-0 pointer-events-none\">\n      <BossWarning />\n\n      {isBossActive && <BossHealthBar />}\n\n      <ComboDisplay combo={comboCount} multiplier={comboMultiplier} timeRemaining={3} />\n\n      <div className=\"absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-auto\">\n        <div className=\"bg-black bg-opacity-70 p-4 rounded-lg text-white\">\n          <div className=\"flex items-center space-x-6\">\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-red-400 font-bold\">HP</span>\n              <div className=\"w-32 h-4 bg-red-900 rounded-full overflow-hidden\">\n                <div\n                  className=\"h-full bg-red-500 transition-all duration-200\"\n                  style={{ width: `${healthPercentage}%` }}\n                />\n              </div>\n              <span className=\"text-sm\">{health}/{maxHealth}</span>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-yellow-400 font-bold\">Score</span>\n              <span className=\"text-xl font-bold\">{score.toLocaleString()}</span>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-green-400 font-bold\"></span>\n              <span className=\"text-lg font-bold text-green-300\">{currency.toLocaleString()}</span>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-purple-400 font-bold\">LVL</span>\n              <span className=\"text-xl font-bold\">{level}</span>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-orange-400 font-bold\"></span>\n              <span className=\"text-sm\">{totalKills}</span>\n            </div>\n          </div>\n\n          <div className=\"mt-3 flex items-center space-x-2\">\n            <span className=\"text-green-400 font-bold text-sm\">EXP</span>\n            <div className=\"w-48 h-3 bg-green-900 rounded-full overflow-hidden\">\n              <div\n                className=\"h-full bg-green-500 transition-all duration-200\"\n                style={{ width: `${experiencePercentage}%` }}\n              />\n            </div>\n            <span className=\"text-xs text-green-300\">{experience}/{experienceToNext}</span>\n          </div>\n\n          {isBossWave && !isBossActive && (\n            <div className=\"mt-2 text-xs text-red-400 animate-pulse\">\n              Boss wave! Prepare for battle...\n            </div>\n          )}\n        </div>\n\n        <button\n          onClick={toggleMute}\n          className=\"bg-black bg-opacity-70 p-3 rounded-lg text-white hover:bg-opacity-90 transition-colors text-xl\"\n        >\n          {isMuted ? \"Muted\" : \"Sound\"}\n        </button>\n      </div>\n\n      <div className=\"absolute bottom-4 left-4 bg-black bg-opacity-70 p-2 rounded text-white text-sm\">\n        <div>WASD/Arrows: Move | M: Sound | R: Restart</div>\n      </div>\n\n      <div className=\"absolute bottom-4 right-4 space-y-2\">\n        {isBossActive && (\n          <div className=\"bg-red-900/80 p-3 rounded-lg text-white border border-red-500\">\n            <div className=\"text-sm font-bold text-red-300\">BOSS FIGHT ACTIVE</div>\n            <div className=\"text-xs text-gray-300 mt-1\">Defeat the boss to proceed!</div>\n          </div>\n        )}\n        <Minimap playerX={0} playerY={0} enemies={[]} />\n      </div>\n    </div>\n  );\n}","path":null,"size_bytes":5602,"size_tokens":null},"client/src/components/ui/sonner.tsx":{"content":"\"use client\"\n\nimport { useTheme } from \"next-themes\"\nimport { Toaster as Sonner } from \"sonner\"\n\ntype ToasterProps = React.ComponentProps<typeof Sonner>\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      toastOptions={{\n        classNames: {\n          toast:\n            \"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\",\n          description: \"group-[.toast]:text-muted-foreground\",\n          actionButton:\n            \"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\",\n          cancelButton:\n            \"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\",\n        },\n      }}\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n","path":null,"size_bytes":894,"size_tokens":null},"client/src/components/GameCanvas.tsx":{"content":"import { useEffect, useRef } from \"react\";\nimport { GameEngine } from \"../lib/game/GameEngine\";\n\ninterface GameCanvasProps {\n  onEngineReady?: (engine: GameEngine) => void;\n}\n\nexport default function GameCanvas({ onEngineReady }: GameCanvasProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const gameEngineRef = useRef<GameEngine | null>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Set canvas size to match window\n    const resizeCanvas = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n\n    resizeCanvas();\n    window.addEventListener(\"resize\", resizeCanvas);\n\n    // Initialize game engine\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      gameEngineRef.current = new GameEngine(canvas, ctx);\n      gameEngineRef.current.start();\n      \n      // Notify parent component that engine is ready\n      if (onEngineReady) {\n        onEngineReady(gameEngineRef.current);\n      }\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", resizeCanvas);\n      if (gameEngineRef.current) {\n        gameEngineRef.current.stop();\n      }\n    };\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"absolute inset-0 w-full h-full\"\n    />\n  );\n}\n","path":null,"size_bytes":1295,"size_tokens":null},"client/src/components/Game.tsx":{"content":"import { useEffect, useRef, useState } from \"react\";\nimport GameCanvas from \"./GameCanvas\";\nimport GameUI from \"./GameUI\";\nimport PowerUpSelection from \"./PowerUpSelection\";\nimport CharacterSelection from \"./CharacterSelection\";\nimport { useGameState } from \"../lib/stores/useGameState\";\nimport { useAudio } from \"../lib/stores/useAudio\";\nimport { PowerUpDefinition } from \"../lib/game/PowerUp\";\nimport { CharacterType } from \"./CharacterSelection\";\nimport PauseMenu from \"./PauseMenu\";\nimport SettingsMenu from \"./SettingsMenu\";\nimport { GameEngine } from \"../lib/game/GameEngine\";\nimport GameOverScreen from \"./GameOverScreen\";\nimport StatisticsScreen from \"./StatisticsScreen\";\nimport LevelUpEffect from \"./LevelUpEffect\";\nimport UpgradeShop from \"./UpgradeShop\";\n\nexport default function Game() {\n  const { phase, restart, resumeFromLevelUp, selectCharacter, resume, pause, playerStats, setPlayerStats } = useGameState();\n  const { setBackgroundMusic, setHitSound, setSuccessSound, toggleMute } = useAudio();\n  const audioInitialized = useRef(false);\n  const [engine, setEngine] = useState<GameEngine | null>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [showSettings, setShowSettings] = useState(false);\n  const [showStatistics, setShowStatistics] = useState(false);\n  const [showUpgradeShop, setShowUpgradeShop] = useState(false);\n\n  // Initialize audio on first user interaction\n  useEffect(() => {\n    const initAudio = async () => {\n      if (audioInitialized.current) return;\n\n      // Audio is now optional - game works without it\n      audioInitialized.current = true;\n      console.log(\"Audio system initialized (files optional)\");\n    };\n\n    const handleFirstInteraction = () => {\n      initAudio();\n      document.removeEventListener(\"click\", handleFirstInteraction);\n      document.removeEventListener(\"keydown\", handleFirstInteraction);\n    };\n\n    document.addEventListener(\"click\", handleFirstInteraction);\n    document.addEventListener(\"keydown\", handleFirstInteraction);\n\n    return () => {\n      document.removeEventListener(\"click\", handleFirstInteraction);\n      document.removeEventListener(\"keydown\", handleFirstInteraction);\n    };\n  }, []);\n\n  const handlePowerUpSelect = (powerUp: PowerUpDefinition) => {\n    if (engine?.getPlayer) {\n      powerUp.apply(engine.getPlayer());\n    }\n    resumeFromLevelUp();\n  };\n\n  const handleCharacterSelect = (character: CharacterType) => {\n    selectCharacter(character);\n  };\n\n  // Game Over logic - This is where the Game Over screen would be rendered.\n  // The original code already had a conditional render for \"ended\" phase.\n  // We'll keep that and ensure it displays the GameOverScreen component.\n  if (phase === \"ended\") {\n    return (\n      <div className=\"relative w-full h-full\">\n        <GameOverScreen onRestart={restart} />\n      </div>\n    );\n  }\n\n  if (phase === \"levelUp\") {\n    return (\n      <div className=\"relative w-full h-full\">\n        <GameCanvas onEngineReady={setEngine} />\n        <PowerUpSelection\n          onSelect={handlePowerUpSelect}\n          onClose={resumeFromLevelUp}\n        />\n      </div>\n    );\n  }\n\n  if (phase === \"characterSelect\") {\n    return (\n      <div className=\"relative w-full h-full\">\n        <CharacterSelection onSelect={handleCharacterSelect} onClose={resumeFromLevelUp} />\n      </div>\n    );\n  }\n\n  // Statistics screen display\n  if (showStatistics) {\n    return (\n      <StatisticsScreen stats={playerStats} onClose={() => setShowStatistics(false)} />\n    );\n  }\n\n  // Upgrade shop display\n  if (showUpgradeShop) {\n    return (\n      <UpgradeShop onClose={() => setShowUpgradeShop(false)} />\n    );\n  }\n\n\n  return (\n    <div className=\"relative w-full h-full flex flex-col bg-gray-900 text-white overflow-hidden\">\n      <GameCanvas onEngineReady={setEngine} />\n      <GameUI />\n      <LevelUpEffect />\n\n      {phase === \"levelUp\" && (\n        <PowerUpSelection\n          onSelect={handlePowerUpSelect}\n          onClose={() => {}}\n        />\n      )}\n\n      {phase === \"characterSelect\" && (\n        <CharacterSelection\n          onSelect={handleCharacterSelect}\n          onClose={() => {}}\n        />\n      )}\n\n      {phase === \"paused\" && !showSettings && (\n        <PauseMenu\n          onResume={resume}\n          onRestart={() => {\n            restart();\n            resume();\n          }}\n          onSettings={() => setShowSettings(true)}\n          onShowStatistics={() => setShowStatistics(true)}\n          onShowUpgradeShop={() => setShowUpgradeShop(true)}\n        />\n      )}\n\n      {showSettings && (\n        <SettingsMenu onClose={() => setShowSettings(false)} />\n      )}\n    </div>\n  );\n}","path":null,"size_bytes":4651,"size_tokens":null},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-4 w-4 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","path":null,"size_bytes":7224,"size_tokens":null},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"px-2 py-1.5 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute right-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","path":null,"size_bytes":5639,"size_tokens":null},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","path":null,"size_bytes":80,"size_tokens":null},"client/src/lib/game/entities/characters/Player.ts":{"content":"\nimport { BaseEntity } from '../../core/base/BaseEntity';\nimport { IPlayer } from '../../core/interfaces/IPlayer';\nimport { IWeapon } from '../../core/interfaces/IWeapon';\nimport { IProjectile } from '../../core/interfaces/IProjectile';\nimport { SylphBloomsWeapon } from '../../weapons/SylphBloomsWeapon';\nimport { OrbitalWeapon } from '../../weapons/OrbitalWeapon';\nimport { SpriteManager } from '../../rendering/SpriteManager';\nimport { AnimationManager } from '../../rendering/AnimationManager';\n\nexport class Player extends BaseEntity implements IPlayer {\n  public collisionWidth = 60;\n  public collisionHeight = 70;\n  protected speed = 200;\n  protected health = 100;\n  protected maxHealth = 100;\n  protected weapon: IWeapon | null;\n  protected orbitalWeapons: OrbitalWeapon[] = [];\n  protected lastMoveDirection = { x: 1, y: 0 };\n  protected isMoving = false;\n  protected instanceId: string;\n  protected animationManager: AnimationManager;\n  protected currentAnimation = \"idle\";\n  protected lastAnimationFrame: any = null;\n\n  constructor(x: number, y: number) {\n    super(x, y, 96, 96);\n    this.weapon = new SylphBloomsWeapon();\n    this.instanceId = `player_${Date.now()}_${Math.random()}`;\n    this.animationManager = new AnimationManager();\n    this.setupAnimations();\n  }\n\n  private setupAnimations(): void {\n    const walkFrames = [\n      { x: 0, y: 0, width: 450, height: 450 },\n      { x: 450, y: 0, width: 450, height: 450 },\n      { x: 900, y: 0, width: 450, height: 450 },\n      { x: 1350, y: 0, width: 450, height: 450 },\n    ];\n\n    const frameWidth = 24000 / 30;\n    const walkDiagonalFrames = [];\n    for (let i = 0; i < 30; i++) {\n      walkDiagonalFrames.push({\n        x: i * frameWidth,\n        y: 0,\n        width: frameWidth,\n        height: 450,\n      });\n    }\n\n    const createFrames = (frameWidth: number, count: number) => {\n      const frames = [];\n      for (let i = 0; i < count; i++) {\n        frames.push({\n          x: i * frameWidth,\n          y: 0,\n          width: frameWidth,\n          height: 450,\n        });\n      }\n      return frames;\n    };\n\n    this.animationManager.addAnimation(\"walk\", walkFrames, 0.1, true);\n    this.animationManager.addAnimation(\"walk_diagonal\", walkDiagonalFrames, 0.05, true);\n    this.animationManager.addAnimation(\"walk_forward\", createFrames(800, 30), 0.05, true);\n    this.animationManager.addAnimation(\"walk_sideways\", createFrames(800, 30), 0.05, true);\n    this.animationManager.addAnimation(\"walk_down\", createFrames(800, 30), 0.05, true);\n    this.animationManager.addAnimation(\"walk_diagonal_down\", createFrames(800, 30), 0.05, true);\n    this.animationManager.addAnimation(\"walk_up\", createFrames(800, 30), 0.05, true);\n    this.animationManager.addAnimation(\"idle\", [createFrames(800, 30)[0]], 1, true);\n\n    this.lastAnimationFrame = createFrames(800, 30)[0];\n  }\n\n  public update(deltaTime: number, input: any, canvasWidth: number, canvasHeight: number, tileRenderer?: any): void {\n    let moveX = 0;\n    let moveY = 0;\n\n    if (input.left) moveX -= 1;\n    if (input.right) moveX += 1;\n    if (input.up) moveY -= 1;\n    if (input.down) moveY += 1;\n\n    if (moveX !== 0 && moveY !== 0) {\n      moveX *= 0.707;\n      moveY *= 0.707;\n    }\n\n    if (moveX !== 0 || moveY !== 0) {\n      this.lastMoveDirection = { x: moveX, y: moveY };\n      this.isMoving = true;\n    } else {\n      this.isMoving = false;\n    }\n\n    this.updateAnimation();\n    this.updatePosition(moveX, moveY, deltaTime, tileRenderer);\n  }\n\n  private updateAnimation(): void {\n    let targetAnimation = \"idle\";\n    \n    if (this.isMoving) {\n      const { x: moveX, y: moveY } = this.lastMoveDirection;\n      \n      if (moveY < 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal\";\n      } else if (moveY > 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal_down\";\n      } else if (moveY > 0) {\n        targetAnimation = \"walk_down\";\n      } else if (moveY < 0 && Math.abs(moveX) === 0) {\n        targetAnimation = \"walk_up\";\n      } else if (Math.abs(moveX) > 0 && moveY === 0) {\n        targetAnimation = \"walk_sideways\";\n      } else {\n        targetAnimation = \"walk\";\n      }\n    }\n\n    if (this.currentAnimation !== targetAnimation) {\n      if (targetAnimation === \"idle\" && this.lastAnimationFrame) {\n        this.animationManager.addAnimation(\"idle\", [this.lastAnimationFrame], 1, true);\n      }\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n    }\n  }\n\n  private updatePosition(moveX: number, moveY: number, deltaTime: number, tileRenderer: any): void {\n    const newX = this.x + moveX * this.speed * deltaTime;\n    const newY = this.y + moveY * this.speed * deltaTime;\n\n    if (tileRenderer && tileRenderer.isSolidAt) {\n      if (!this.checkTileCollision(newX, this.y, tileRenderer)) {\n        this.x = newX;\n      }\n      if (!this.checkTileCollision(this.x, newY, tileRenderer)) {\n        this.y = newY;\n      }\n    } else {\n      this.x = newX;\n      this.y = newY;\n    }\n  }\n\n  private checkTileCollision(x: number, y: number, tileRenderer: any): boolean {\n    const margin = 2;\n    const points = [\n      { x: x + margin, y: y + margin },\n      { x: x + this.width - margin, y: y + margin },\n      { x: x + margin, y: y + this.height - margin },\n      { x: x + this.width - margin, y: y + this.height - margin }\n    ];\n\n    return points.some(point => tileRenderer.isSolidAt(point.x, point.y));\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    const spriteManager = SpriteManager.getInstance();\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) ? deltaTime : 0.016;\n    const currentFrame = this.animationManager.update(validDeltaTime, this.instanceId, this.currentAnimation);\n\n    if (currentFrame && this.currentAnimation !== \"idle\") {\n      this.lastAnimationFrame = currentFrame;\n    }\n\n    const sprites = this.getSpritesForAnimation();\n    const spriteToUse = sprites[this.currentAnimation] || sprites['default'];\n\n    if (spriteToUse && currentFrame) {\n      this.renderSprite(ctx, spriteToUse, currentFrame);\n    } else {\n      this.renderFallback(ctx);\n    }\n\n    this.orbitalWeapons.forEach(orbital => orbital.render(ctx));\n  }\n\n  private getSpritesForAnimation(): Record<string, any> {\n    const spriteManager = SpriteManager.getInstance();\n    return {\n      'walk_diagonal': spriteManager.getSprite(\"player_diagonal\"),\n      'walk_diagonal_down': spriteManager.getSprite(\"player_diagonal_down\"),\n      'walk_forward': spriteManager.getSprite(\"player_forward\"),\n      'walk_sideways': spriteManager.getSprite(\"player_sideways\"),\n      'walk_down': spriteManager.getSprite(\"player_down\"),\n      'walk_up': spriteManager.getSprite(\"player_up\"),\n      'default': spriteManager.getSprite(\"player\")\n    };\n  }\n\n  private renderSprite(ctx: CanvasRenderingContext2D, sprite: any, frame: any): void {\n    ctx.save();\n\n    let drawWidth = this.width;\n    let drawHeight = this.height;\n\n    if (['walk_forward', 'walk_diagonal', 'walk_sideways', 'walk_down', 'walk_up', 'walk_diagonal_down', 'idle'].includes(this.currentAnimation)) {\n      const aspectRatio = 800 / 450;\n      drawWidth = this.height * aspectRatio;\n    }\n\n    const drawX = this.x - drawWidth / 2;\n    const drawY = this.y - drawHeight / 2;\n\n    const shouldFlip = this.shouldFlipSprite();\n    if (shouldFlip) {\n      ctx.translate(this.x, this.y);\n      ctx.scale(-1, 1);\n      ctx.translate(-this.x, -this.y);\n    }\n\n    ctx.drawImage(sprite, frame.x, frame.y, frame.width, frame.height, drawX, drawY, drawWidth, drawHeight);\n    ctx.restore();\n  }\n\n  private shouldFlipSprite(): boolean {\n    return (\n      (this.currentAnimation === \"walk_diagonal\" && this.lastMoveDirection.x > 0) ||\n      (this.currentAnimation === \"walk_diagonal_down\" && this.lastMoveDirection.x < 0) ||\n      (this.currentAnimation === \"walk_sideways\" && this.lastMoveDirection.x < 0) ||\n      (!['walk_diagonal', 'walk_sideways', 'walk_down', 'walk_up', 'walk_diagonal_down'].includes(this.currentAnimation) && this.lastMoveDirection.x > 0)\n    );\n  }\n\n  private renderFallback(ctx: CanvasRenderingContext2D): void {\n    ctx.fillStyle = \"#4444ff\";\n    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\n  }\n\n  public fireWeapon(deltaTime: number): IProjectile[] {\n    if (!this.weapon) return [];\n\n    const projectiles = this.weapon.fire(deltaTime, this.x, this.y, this.lastMoveDirection);\n\n    this.orbitalWeapons.forEach(orbital => {\n      orbital.update(deltaTime, this.x, this.y);\n    });\n\n    return projectiles;\n  }\n\n  public getWeapon(): IWeapon | null {\n    return this.weapon;\n  }\n\n  public setWeapon(weapon: IWeapon): void {\n    this.weapon = weapon;\n  }\n\n  public getSpeed(): number {\n    return this.speed;\n  }\n\n  public setSpeed(speed: number): void {\n    this.speed = speed;\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.destroy();\n    }\n  }\n\n  public heal(amount: number): void {\n    this.health = Math.min(this.maxHealth, this.health + amount);\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public addOrbitalWeapon(): void {\n    this.orbitalWeapons.push(new OrbitalWeapon());\n  }\n\n  public getOrbitalWeapons(): OrbitalWeapon[] {\n    return this.orbitalWeapons;\n  }\n}\n","path":null,"size_bytes":9466,"size_tokens":null},"client/src/lib/game/weapons/AssassinSpiderWeapon.ts":{"content":"import { BaseWeapon } from \"./WeaponTypes\";\nimport { Projectile } from \"./projectiles/Projectile\";\nimport { Enemy } from \"../entities/enemies/Enemy\";\nimport { MechanicalSpider } from '../entities/spiders/MechanicalSpider';\n\n// Global tracking for weapons\nlet globalWeaponCount = 0;\n\nexport class AssassinSpiderWeapon extends BaseWeapon {\n  private weaponId: string;\n\n  constructor() {\n    super(0.25, 0, 0); // No traditional projectiles\n    globalWeaponCount++;\n    this.weaponId = `weapon_${Date.now()}_${Math.random()}`;\n    console.log(`Created AssassinSpiderWeapon: ${this.weaponId}. Global weapon count: ${globalWeaponCount}`);\n  }\n\n  public fire(deltaTime: number, playerX: number, playerY: number, direction?: { x: number; y: number }): Projectile[] {\n    // No traditional projectiles for assassin\n    return [];\n  }\n\n  public updateSpiders(deltaTime: number, enemies: Enemy[], playerPos: { x: number; y: number }) {\n    // FollowerSpider functionality removed\n  }\n\n  public renderSpiders(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0) {\n    // FollowerSpider rendering removed\n  }\n\n  public getSpiders(): any[] {\n    return [];\n  }\n\n  public upgradeMaxSpiders() {\n    // Upgrade functionality removed\n  }\n\n  public upgradeSpawnRate() {\n    // Upgrade functionality removed\n  }\n\n  public upgradeSpiderDamage() {\n    // Upgrade functionality removed\n  }\n}","path":null,"size_bytes":1408,"size_tokens":null},"client/src/lib/game/entities/PowerUp.ts":{"content":"\nimport { SylphBloomsWeapon } from \"../weapons/SylphBloomsWeapon\";\nimport { Player } from \"./Player\";\nimport { AssassinPlayer } from \"./AssassinPlayer\";\n\nexport interface PowerUpDefinition {\n  id: string;\n  name: string;\n  description: string;\n  color: string;\n  apply: (player: Player) => void;\n  characterRestriction?: \"sylph\" | \"assassin\";\n}\n\nexport const POWERUP_DEFINITIONS: PowerUpDefinition[] = [\n  // Sylph-specific powerups\n  {\n    id: \"damage\",\n    name: \"Flower Power\",\n    description: \"Your flowers deal more damage to enemies\",\n    color: \"#ff6b6b\",\n    characterRestriction: \"sylph\",\n    apply: (player: Player) => {\n      if (player.weapon instanceof SylphBloomsWeapon) {\n        player.weapon.upgradeDamage();\n      }\n    }\n  },\n  {\n    id: \"fire_rate\",\n    name: \"Rapid Bloom\",\n    description: \"Spawn flowers more frequently\",\n    color: \"#4ecdc4\",\n    characterRestriction: \"sylph\",\n    apply: (player: Player) => {\n      if (player.weapon instanceof SylphBloomsWeapon) {\n        player.weapon.upgradeFireRate();\n      }\n    }\n  },\n  {\n    id: \"flower_capacity\",\n    name: \"Garden Growth\",\n    description: \"Maintain more flowers at once\",\n    color: \"#45b7d1\",\n    characterRestriction: \"sylph\",\n    apply: (player: Player) => {\n      if (player.weapon instanceof SylphBloomsWeapon) {\n        player.weapon.upgradeFlowerCapacity();\n      }\n    }\n  },\n  {\n    id: \"flower_lifespan\",\n    name: \"Eternal Bloom\",\n    description: \"Flowers last longer before wilting\",\n    color: \"#96ceb4\",\n    characterRestriction: \"sylph\",\n    apply: (player: Player) => {\n      if (player.weapon instanceof SylphBloomsWeapon) {\n        player.weapon.upgradeFlowerLifespan();\n      }\n    }\n  },\n  // Assassin-specific powerups (mutually exclusive)\n  {\n    id: \"big_spider\",\n    name: \"Big Spider\",\n    description: \"Replace spider with a powerful tank-killer (high single-target DPS)\",\n    color: \"#8b0000\",\n    characterRestriction: \"assassin\",\n    apply: (player: Player) => {\n      if (player instanceof AssassinPlayer) {\n        player.setBigSpiderMode(true);\n      }\n    }\n  },\n  {\n    id: \"small_spiders\",\n    name: \"Small Spiders\",\n    description: \"Replace spider with multiple fast swarm-killers (die faster but excel vs. hordes)\",\n    color: \"#4169e1\",\n    characterRestriction: \"assassin\",\n    apply: (player: Player) => {\n      if (player instanceof AssassinPlayer) {\n        player.setSmallSpidersMode(true);\n      }\n    }\n  },\n  // Universal powerups\n  {\n    id: \"health\",\n    name: \"Nature's Blessing\",\n    description: \"Restore health and increase maximum health\",\n    color: \"#feca57\",\n    apply: (player: Player) => {\n      player.heal(20);\n      player.maxHealth += 10;\n    }\n  },\n  {\n    id: \"speed\",\n    name: \"Wind Walker\",\n    description: \"Move faster through the battlefield\",\n    color: \"#ff9ff3\",\n    apply: (player: Player) => {\n      player.speed += 30;\n    }\n  }\n];\n\nexport class PowerUp {\n  constructor(\n    public x: number,\n    public y: number,\n    public definition: PowerUpDefinition\n  ) {}\n\n  public apply(player: Player) {\n    this.definition.apply(player);\n  }\n\n  public render(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = this.definition.color;\n    ctx.fillRect(this.x - 10, this.y - 10, 20, 20);\n    \n    // Add glow effect\n    ctx.shadowColor = this.definition.color;\n    ctx.shadowBlur = 10;\n    ctx.fillRect(this.x - 8, this.y - 8, 16, 16);\n    ctx.shadowBlur = 0;\n  }\n}\n","path":null,"size_bytes":3425,"size_tokens":null},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: cn(\n          \"relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md\",\n          props.mode === \"range\"\n            ? \"[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md\"\n            : \"[&:has([aria-selected])]:rounded-md\"\n        ),\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-8 w-8 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_start: \"day-range-start\",\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","path":null,"size_bytes":2935,"size_tokens":null},"client/src/lib/game/managers/TileMapGenerator.ts":{"content":"\nexport interface TileMapCell {\n  groundTile: number;\n  objectTile?: number;\n  detailTile?: number;\n}\n\nexport class TileMapGenerator {\n  private static readonly MAP_SIZE = 16;\n  \n  // Tile indices for different elements (based on the new 5x5 tileset)\n  private static readonly GROUND_TILES = {\n    BASE_DIRT_1: 0,\n    BASE_DIRT_2: 1,\n    BASE_DIRT_3: 2,\n    BASE_DIRT_CRACK: 3,\n    BASE_DIRT_BONE: 4,\n    MUD_PATCH: 20,\n    STONE_MOSS: 21,\n    GRAVEL_CLUSTER: 22\n  };\n\n  private static readonly OBJECT_TILES = {\n    COFFIN_SLAB_1: 0,\n    COFFIN_SLAB_2: 1,\n    TWISTED_TREE_1: 2,\n    TWISTED_TREE_2: 3,\n    BROKEN_TREE: 4,\n    STONE_CRYPT: 5,\n    BROKEN_ALTAR: 6,\n    GRAVESTONE: 7,\n    SKELETON_HAND: 8,\n    CRYSTAL_FORMATION: 9\n  };\n\n  private static readonly DETAIL_TILES = {\n    BLOOD_SPLATTER: 15,\n    BONE_OVERLAY: 16,\n    MOSS_PATCH: 17,\n    DEAD_GRASS: 18,\n    SMALL_STONE: 19,\n    CENTER_CRACKED: 9,\n    ROCK_CLUSTER: 14,\n    SUBTLE_SHADOW: 23,\n    SEAMLESS_FILLER: 24\n  };\n\n  public static generateUndeadScene(): TileMapCell[][] {\n    const map: TileMapCell[][] = [];\n    \n    // Initialize base map with varied ground\n    for (let y = 0; y < this.MAP_SIZE; y++) {\n      map[y] = [];\n      for (let x = 0; x < this.MAP_SIZE; x++) {\n        map[y][x] = {\n          groundTile: this.selectGroundTile(x, y)\n        };\n      }\n    }\n\n    // Place major structures\n    this.placeCoffinsAndCrypts(map);\n    this.placeTwistedTrees(map);\n    this.placeBrokenAltars(map);\n    \n    // Add atmospheric details\n    this.scatterBones(map);\n    this.addVegetation(map);\n    this.addCrystalFormations(map);\n\n    return map;\n  }\n\n  private static selectGroundTile(x: number, y: number): number {\n    // Create varied ground using base dirt variants with some randomness\n    const seed = (x * 3 + y * 7) % 100;\n    \n    if (seed < 40) {\n      return 0; // Tile at (0,0) - most common\n    } else if (seed < 65) {\n      return 1; // Tile at (1,0) - common\n    } else if (seed < 80) {\n      return 2; // Tile at (2,0) - less common\n    } else if (seed < 88) {\n      return 3; // Tile at (3,0) - rare\n    } else if (seed < 94) {\n      return 4; // Tile at (0,1) - very rare\n    } else if (seed < 97) {\n      return 8; // Tile at (0,2) - extremely rare\n    } else {\n      return 12; // Tile at (0,3) - ultra rare\n    }\n  }\n\n  private static placeCoffinsAndCrypts(map: TileMapCell[][]) {\n    // Place coffin slabs in strategic locations\n    const coffins = [\n      { x: 3, y: 4 }, { x: 12, y: 6 }, { x: 7, y: 11 }, { x: 14, y: 13 }\n    ];\n\n    coffins.forEach((pos, index) => {\n      if (this.isValidPosition(pos.x, pos.y)) {\n        map[pos.y][pos.x].objectTile = index % 2 === 0 ? \n          this.OBJECT_TILES.COFFIN_SLAB_1 : this.OBJECT_TILES.COFFIN_SLAB_2;\n      }\n    });\n\n    // Place stone crypts\n    const crypts = [\n      { x: 1, y: 2 }, { x: 9, y: 8 }, { x: 13, y: 3 }\n    ];\n\n    crypts.forEach(pos => {\n      if (this.isValidPosition(pos.x, pos.y)) {\n        map[pos.y][pos.x].objectTile = this.OBJECT_TILES.STONE_CRYPT;\n      }\n    });\n  }\n\n  private static placeTwistedTrees(map: TileMapCell[][]) {\n    const trees = [\n      { x: 1, y: 8 }, { x: 6, y: 2 }, { x: 11, y: 14 }, \n      { x: 14, y: 7 }, { x: 4, y: 13 }, { x: 8, y: 5 }\n    ];\n\n    trees.forEach((pos, index) => {\n      if (this.isValidPosition(pos.x, pos.y)) {\n        if (index % 3 === 0) {\n          map[pos.y][pos.x].objectTile = this.OBJECT_TILES.TWISTED_TREE_1;\n        } else if (index % 3 === 1) {\n          map[pos.y][pos.x].objectTile = this.OBJECT_TILES.TWISTED_TREE_2;\n        } else {\n          map[pos.y][pos.x].objectTile = this.OBJECT_TILES.BROKEN_TREE;\n        }\n      }\n    });\n  }\n\n  private static placeBrokenAltars(map: TileMapCell[][]) {\n    const altars = [\n      { x: 5, y: 9 }, { x: 10, y: 3 }\n    ];\n\n    altars.forEach(pos => {\n      if (this.isValidPosition(pos.x, pos.y)) {\n        map[pos.y][pos.x].objectTile = this.OBJECT_TILES.BROKEN_ALTAR;\n      }\n    });\n  }\n\n  private static scatterBones(map: TileMapCell[][]) {\n    for (let y = 0; y < this.MAP_SIZE; y++) {\n      for (let x = 0; x < this.MAP_SIZE; x++) {\n        // Skip cells that already have objects\n        if (map[y][x].objectTile !== undefined) continue;\n\n        const boneChance = (x * 3 + y * 7) % 100;\n        \n        if (boneChance < 8) {\n          map[y][x].detailTile = this.DETAIL_TILES.BONE_OVERLAY;\n        } else if (boneChance < 15) {\n          map[y][x].detailTile = this.DETAIL_TILES.BLOOD_SPLATTER;\n        } else if (boneChance < 20) {\n          map[y][x].detailTile = this.DETAIL_TILES.SMALL_STONE;\n        } else if (boneChance < 25) {\n          map[y][x].detailTile = this.DETAIL_TILES.CENTER_CRACKED;\n        } else if (boneChance < 30) {\n          map[y][x].detailTile = this.DETAIL_TILES.ROCK_CLUSTER;\n        }\n\n        // Add skeleton hands emerging from ground\n        if (boneChance >= 95) {\n          map[y][x].objectTile = this.OBJECT_TILES.SKELETON_HAND;\n        }\n      }\n    }\n  }\n\n  private static addVegetation(map: TileMapCell[][]) {\n    for (let y = 0; y < this.MAP_SIZE; y++) {\n      for (let x = 0; x < this.MAP_SIZE; x++) {\n        if (map[y][x].objectTile !== undefined || map[y][x].detailTile !== undefined) continue;\n\n        const vegChance = (x * 5 + y * 9) % 100;\n        \n        if (vegChance < 6) {\n          map[y][x].detailTile = this.DETAIL_TILES.MOSS_PATCH;\n        } else if (vegChance < 12) {\n          map[y][x].detailTile = this.DETAIL_TILES.DEAD_GRASS;\n        } else if (vegChance < 18) {\n          map[y][x].detailTile = this.DETAIL_TILES.SUBTLE_SHADOW;\n        } else if (vegChance < 22) {\n          map[y][x].detailTile = this.DETAIL_TILES.SEAMLESS_FILLER;\n        }\n      }\n    }\n  }\n\n  private static addCrystalFormations(map: TileMapCell[][]) {\n    const crystals = [\n      { x: 2, y: 12 }, { x: 15, y: 1 }, { x: 8, y: 7 }\n    ];\n\n    crystals.forEach((pos, index) => {\n      if (this.isValidPosition(pos.x, pos.y) && map[pos.y][pos.x].objectTile === undefined) {\n        if (index % 2 === 0) {\n          map[pos.y][pos.x].objectTile = this.OBJECT_TILES.CRYSTAL_FORMATION;\n        } else {\n          map[pos.y][pos.x].detailTile = this.DETAIL_TILES.ROCK_CLUSTER;\n        }\n      }\n    });\n  }\n\n  private static isValidPosition(x: number, y: number): boolean {\n    return x >= 0 && x < this.MAP_SIZE && y >= 0 && y < this.MAP_SIZE;\n  }\n\n  public static exportAsGrid(map: TileMapCell[][]): string {\n    let output = \"=== UNDEAD TILESET MAP (16x16) ===\\n\\n\";\n    output += \"Legend:\\n\";\n    output += \"Ground: . (earth) # (stone) ~ (moss) * (corrupted)\\n\";\n    output += \"Objects: C (coffin) T (tree) A (altar) H (hand) X (crypt)\\n\";\n    output += \"Details: b (bones) s (skull) r (rose-hip) c (crystal)\\n\\n\";\n\n    for (let y = 0; y < this.MAP_SIZE; y++) {\n      for (let x = 0; x < this.MAP_SIZE; x++) {\n        const cell = map[y][x];\n        let char = '.';\n\n        // Priority: Objects > Details > Ground\n        if (cell.objectTile !== undefined) {\n          switch (cell.objectTile) {\n            case this.OBJECT_TILES.COFFIN_SLAB_1:\n            case this.OBJECT_TILES.COFFIN_SLAB_2:\n              char = 'C'; break;\n            case this.OBJECT_TILES.TWISTED_TREE_1:\n            case this.OBJECT_TILES.TWISTED_TREE_2:\n            case this.OBJECT_TILES.BROKEN_TREE:\n              char = 'T'; break;\n            case this.OBJECT_TILES.BROKEN_ALTAR:\n              char = 'A'; break;\n            case this.OBJECT_TILES.SKELETON_HAND:\n              char = 'H'; break;\n            case this.OBJECT_TILES.STONE_CRYPT:\n              char = 'X'; break;\n            case this.OBJECT_TILES.CRYSTAL_FORMATION:\n              char = 'Y'; break;\n            default: char = '?';\n          }\n        } else if (cell.detailTile !== undefined) {\n          switch (cell.detailTile) {\n            case this.DETAIL_TILES.SCATTERED_BONES_1:\n            case this.DETAIL_TILES.SCATTERED_BONES_2:\n            case this.DETAIL_TILES.SCATTERED_BONES_3:\n            case this.DETAIL_TILES.BONE_FRAGMENT:\n              char = 'b'; break;\n            case this.DETAIL_TILES.SMALL_SKULL:\n              char = 's'; break;\n            case this.DETAIL_TILES.ROSE_HIP_SHRUB:\n              char = 'r'; break;\n            case this.DETAIL_TILES.SMALL_CRYSTAL:\n              char = 'c'; break;\n            case this.DETAIL_TILES.MOSS_PATCH:\n              char = '~'; break;\n            case this.DETAIL_TILES.DEAD_BRANCH:\n            case this.DETAIL_TILES.DEAD_LEAVES:\n              char = 'd'; break;\n            default: char = ',';\n          }\n        } else {\n          // Ground tiles\n          switch (cell.groundTile) {\n            case this.GROUND_TILES.BASE_DIRT_1:\n              char = '.'; break;\n            case this.GROUND_TILES.BASE_DIRT_2:\n              char = ','; break;\n            case this.GROUND_TILES.BASE_DIRT_3:\n              char = ':'; break;\n            case this.GROUND_TILES.BASE_DIRT_CRACK:\n              char = '/'; break;\n            case this.GROUND_TILES.BASE_DIRT_BONE:\n              char = 'B'; break;\n            case this.GROUND_TILES.MUD_PATCH:\n              char = 'm'; break;\n            case this.GROUND_TILES.STONE_MOSS:\n              char = '~'; break;\n            case this.GROUND_TILES.GRAVEL_CLUSTER:\n              char = '#'; break;\n            default: char = '.';\n          }\n        }\n\n        output += char + ' ';\n      }\n      output += '\\n';\n    }\n\n    return output;\n  }\n}\n","path":null,"size_bytes":9419,"size_tokens":null},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","path":null,"size_bytes":1902,"size_tokens":null},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md\",\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","path":null,"size_bytes":7480,"size_tokens":null},"client/src/lib/game/weapons/WeaponTypes.ts":{"content":"import { Projectile } from \"./Projectile\";\n\nexport abstract class BaseWeapon {\n  protected fireRate: number;\n  protected timeSinceLastShot = 0;\n  protected damage: number;\n  protected projectileSpeed: number;\n\n  constructor(fireRate: number, damage: number, projectileSpeed: number) {\n    this.fireRate = fireRate;\n    this.damage = damage;\n    this.projectileSpeed = projectileSpeed;\n  }\n\n  public abstract fire(deltaTime: number, playerX: number, playerY: number, direction?: { x: number; y: number }): Projectile[];\n\n  public upgradeDamage() {\n    this.damage += 1;\n  }\n\n  public upgradeFireRate() {\n    this.fireRate += 1;\n  }\n\n  protected updateFireTimer(deltaTime: number): boolean {\n    this.timeSinceLastShot += deltaTime;\n    const shotInterval = 1 / this.fireRate;\n\n    if (this.timeSinceLastShot >= shotInterval) {\n      this.timeSinceLastShot = 0;\n      return true;\n    }\n    return false;\n  }\n}","path":null,"size_bytes":908,"size_tokens":null},"client/src/lib/game/entities/characters/AssassinPlayer.ts":{"content":"\nimport { Player } from \"./Player\";\nimport { IEnemy } from \"../../core/interfaces/IEnemy\";\nimport { IProjectile } from \"../../core/interfaces/IProjectile\";\nimport { ISpider } from \"../../core/interfaces/ISpider\";\nimport { SpiderManager } from \"../../managers/SpiderManager\";\nimport { SpriteManager } from \"../../rendering/SpriteManager\";\nimport { AnimationManager } from \"../../rendering/AnimationManager\";\n\nexport class AssassinPlayer extends Player {\n  private spiderManager: SpiderManager;\n  private tileRenderer: any = null;\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.speed = 250;\n    this.maxHealth = 80;\n    this.health = this.maxHealth;\n\n    this.weapon = null;\n    this.instanceId = `assassin_${Date.now()}_${Math.random()}`;\n    this.spiderManager = new SpiderManager(\"normal\");\n    this.spiderManager.spawnSpider(x - 60, y - 20);\n  }\n\n  public update(deltaTime: number, input: any, canvasWidth: number, canvasHeight: number, tileRenderer: any): void {\n    let moveX = 0;\n    let moveY = 0;\n\n    if (input.left) moveX -= 1;\n    if (input.right) moveX += 1;\n    if (input.up) moveY -= 1;\n    if (input.down) moveY += 1;\n\n    if (moveX !== 0 && moveY !== 0) {\n      moveX *= 0.707;\n      moveY *= 0.707;\n    }\n\n    if (moveX !== 0 || moveY !== 0) {\n      this.lastMoveDirection = { x: moveX, y: moveY };\n      this.isMoving = true;\n    } else {\n      this.isMoving = false;\n    }\n\n    const newX = this.x + moveX * this.speed * deltaTime;\n    const newY = this.y + moveY * this.speed * deltaTime;\n\n    if (tileRenderer && tileRenderer.isSolidAt) {\n      if (!this.checkTileCollision(newX, this.y, tileRenderer)) {\n        this.x = newX;\n      }\n      if (!this.checkTileCollision(this.x, newY, tileRenderer)) {\n        this.y = newY;\n      }\n    } else {\n      this.x = newX;\n      this.y = newY;\n    }\n\n    this.updateAnimation();\n  }\n\n  private updateAnimation(): void {\n    let targetAnimation = \"idle\";\n    const { x: moveX, y: moveY } = this.lastMoveDirection;\n\n    if (this.isMoving) {\n      if (moveY < 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal\";\n      } else if (moveY > 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal_down\";\n      } else if (moveY > 0) {\n        targetAnimation = \"walk_down\";\n      } else if (moveY < 0 && Math.abs(moveX) === 0) {\n        targetAnimation = \"walk_up\";\n      } else if (Math.abs(moveX) > 0 && moveY === 0) {\n        targetAnimation = \"walk_sideways\";\n      } else {\n        targetAnimation = \"walk\";\n      }\n    }\n\n    if (this.currentAnimation !== targetAnimation) {\n      if (targetAnimation === \"idle\" && this.lastAnimationFrame) {\n        this.animationManager.addAnimation(\"idle\", [this.lastAnimationFrame], 1, true);\n      }\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n    }\n  }\n\n  public setTileRenderer(tileRenderer: any): void {\n    this.tileRenderer = tileRenderer;\n    // Register existing spiders with tile renderer\n    this.spiderManager.getSpiders().forEach(spider => {\n      this.tileRenderer.addSpider({\n        x: spider.x,\n        y: spider.y,\n        instanceId: spider.instanceId,\n        currentAnimation: spider.currentAnimation,\n        lastDirection: spider.lastDirection\n      });\n    });\n  }\n\n  public updateSpiders(deltaTime: number, enemies: IEnemy[], playerPos: { x: number; y: number }): void {\n    this.spiderManager.update(deltaTime, enemies, { x: this.x, y: this.y });\n\n    if (this.tileRenderer) {\n      this.spiderManager.getSpiders().forEach(spider => {\n        this.tileRenderer.updateSpider(\n          spider.instanceId,\n          spider.x,\n          spider.y,\n          spider.currentAnimation,\n          spider.lastDirection\n        );\n      });\n    }\n  }\n\n  public renderSpiders(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0): void {\n    this.spiderManager.render(ctx, deltaTime, cameraX, cameraY);\n  }\n\n  public getSpiders(): ISpider[] {\n    return this.spiderManager.getSpiders();\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    const spriteManager = SpriteManager.getInstance();\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) ? deltaTime : 0.016;\n\n    const frame = this.animationManager.update(validDeltaTime, this.instanceId, this.currentAnimation);\n\n    if (frame) {\n      this.lastAnimationFrame = frame;\n    }\n\n    const spriteToUse = this.getAssassinSprite(spriteManager);\n\n    if (spriteToUse) {\n      this.renderAssassinSprite(ctx, spriteToUse, frame);\n    } else {\n      this.renderFallback(ctx);\n    }\n\n    this.renderHealthBar(ctx);\n  }\n\n  private getAssassinSprite(spriteManager: SpriteManager): HTMLImageElement | null {\n    const spriteMap: Record<string, string> = {\n      \"walk_up\": \"assassin_up\",\n      \"walk_down\": \"assassin_down\",\n      \"idle\": \"assassin_down\",\n      \"walk_sideways\": \"assassin_sideways\",\n      \"walk_diagonal\": \"assassin_diagonal_back\",\n      \"walk_diagonal_down\": \"assassin_diagonal_front\",\n      \"walk\": \"assassin_down\",\n      \"walk_forward\": \"assassin_down\"\n    };\n\n    const spriteName = spriteMap[this.currentAnimation] || \"assassin_down\";\n    return spriteManager.getSprite(spriteName);\n  }\n\n  private renderAssassinSprite(ctx: CanvasRenderingContext2D, sprite: HTMLImageElement, frame: any): void {\n    if (frame && this.currentAnimation !== \"idle\") {\n      this.lastAnimationFrame = frame;\n    }\n\n    const aspectRatio = 800 / 450;\n    const drawWidth = this.height * aspectRatio;\n    const drawHeight = this.height;\n    const drawX = this.x - drawWidth / 2;\n    const drawY = this.y - drawHeight / 2;\n\n    const processedSprite = this.removeWhiteOutline(sprite, frame);\n\n    ctx.save();\n    if (this.shouldFlipSprite()) {\n      ctx.translate(this.x, this.y);\n      ctx.scale(-1, 1);\n      ctx.translate(-this.x, -this.y);\n    }\n\n    try {\n      if (frame) {\n        ctx.drawImage(processedSprite, 0, 0, frame.width, frame.height, drawX, drawY, drawWidth, drawHeight);\n      } else {\n        ctx.drawImage(processedSprite, 0, 0, 800, 450, drawX, drawY, drawWidth, drawHeight);\n      }\n    } catch (error) {\n      this.renderFallback(ctx);\n    }\n\n    ctx.restore();\n  }\n\n  private removeWhiteOutline(sprite: HTMLImageElement, frame: any): HTMLCanvasElement {\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d')!;\n\n    if (frame) {\n      tempCanvas.width = frame.width;\n      tempCanvas.height = frame.height;\n\n      tempCtx.drawImage(sprite, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);\n\n      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\n      const data = imageData.data;\n\n      for (let i = 0; i < data.length; i += 4) {\n        if (data[i] > 240 && data[i + 1] > 240 && data[i + 2] > 240) {\n          data[i + 3] = 0;\n        }\n      }\n\n      tempCtx.putImageData(imageData, 0, 0);\n    }\n\n    return tempCanvas;\n  }\n\n  private shouldFlipSprite(): boolean {\n    return (\n      (this.currentAnimation === \"walk_diagonal\" && this.lastMoveDirection.x > 0) ||\n      (this.currentAnimation === \"walk_diagonal_down\" && this.lastMoveDirection.x < 0) ||\n      (this.currentAnimation === \"walk_sideways\" && this.lastMoveDirection.x < 0)\n    );\n  }\n\n  private renderFallback(ctx: CanvasRenderingContext2D): void {\n    ctx.fillStyle = \"#ff0000\";\n    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    if (this.health < this.maxHealth) {\n      const barWidth = this.width;\n      const barHeight = 3;\n      const healthPercent = this.health / this.maxHealth;\n\n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(this.x, this.y - 10, barWidth, barHeight);\n\n      ctx.fillStyle = \"#44ff44\";\n      ctx.fillRect(this.x, this.y - 10, barWidth * healthPercent, barHeight);\n    }\n  }\n\n  private checkTileCollision(x: number, y: number, tileRenderer: any): boolean {\n    const margin = 2;\n    const points = [\n      { x: x + margin, y: y + margin },\n      { x: x + this.width - margin, y: y + margin },\n      { x: x + margin, y: y + this.height - margin },\n      { x: x + this.width - margin, y: y + this.height - margin }\n    ];\n\n    return points.some(point => tileRenderer.isSolidAt(point.x, point.y));\n  }\n\n  public fireWeapon(deltaTime: number): IProjectile[] {\n    return [];\n  }\n\n  public getWeapon() {\n    return null;\n  }\n\n  public setBigSpiderMode(enable: boolean): void {\n    if (enable) {\n      this.spiderManager.setMode(\"big\");\n    }\n  }\n\n  public setSmallSpidersMode(enable: boolean): void {\n    if (enable) {\n      this.spiderManager.setMode(\"small\");\n      this.spiderManager.upgradeMaxSpiders(); // Small mode can have multiple spiders\n    }\n  }\n}\n","path":null,"size_bytes":8885,"size_tokens":null},"client/src/lib/game/entities/collectibles/ExperienceOrb.ts":{"content":"\nimport { ICollectible } from \"../../core/interfaces/ICollectible\";\n\nexport class ExperienceOrb implements ICollectible {\n  public x: number;\n  public y: number;\n  public width = 8;\n  public height = 8;\n  private value: number;\n  private lifetime = 10;\n  private attractRadius = 80;\n  private collectRadius = 20;\n  private attracted = false;\n  private pulseTime = 0;\n\n  constructor(x: number, y: number, value: number = 5) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    this.lifetime -= deltaTime;\n    this.pulseTime += deltaTime * 3;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance <= this.attractRadius) {\n      this.attracted = true;\n    }\n\n    if (this.attracted && distance > this.collectRadius) {\n      const speed = 200;\n      const moveX = (dx / distance) * speed * deltaTime;\n      const moveY = (dy / distance) * speed * deltaTime;\n      \n      this.x += moveX;\n      this.y += moveY;\n    }\n  }\n\n  public isExpired(): boolean {\n    return this.lifetime <= 0;\n  }\n\n  public canBeCollected(playerPos: { x: number; y: number }): boolean {\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= this.collectRadius;\n  }\n\n  public getValue(): number {\n    return this.value;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    const pulse = Math.sin(this.pulseTime) * 0.3 + 1;\n    const size = this.width * pulse;\n    \n    ctx.save();\n    ctx.shadowColor = \"#44ff44\";\n    ctx.shadowBlur = this.attracted ? 15 : 8;\n    \n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - size / 2, this.y - size / 2, size, size);\n\n    ctx.shadowBlur = 0;\n    ctx.fillStyle = \"#88ff88\";\n    ctx.fillRect(this.x - size / 4, this.y - size / 4, size / 2, size / 2);\n    \n    ctx.restore();\n\n    if (this.lifetime < 3) {\n      const lifetimePercent = this.lifetime / 3;\n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(this.x - this.width / 2, this.y + this.height / 2 + 1, this.width, 2);\n      ctx.fillStyle = \"#44ff44\";\n      ctx.fillRect(this.x - this.width / 2, this.y + this.height / 2 + 1, this.width * lifetimePercent, 2);\n    }\n  }\n}\n","path":null,"size_bytes":2334,"size_tokens":null},"client/src/lib/game/systems/InputManager.ts":{"content":"export interface InputState {\n  left: boolean;\n  right: boolean;\n  up: boolean;\n  down: boolean;\n  mute: boolean;\n  restart: boolean;\n  weapon1: boolean;\n  weapon2: boolean;\n  weapon3: boolean;\n  weapon4: boolean;\n  weapon5: boolean;\n}\n\nexport class InputManager {\n  private keys: { [key: string]: boolean } = {};\n\n  constructor() {\n    this.keys = {\n      left: false,\n      right: false,\n      up: false,\n      down: false,\n      mute: false,\n      restart: false,\n      weapon1: false,\n      weapon2: false,\n      weapon3: false,\n      weapon4: false,\n      weapon5: false\n    };\n  }\n\n  public addEventListeners() {\n    document.addEventListener(\"keydown\", this.handleKeyDown);\n    document.addEventListener(\"keyup\", this.handleKeyUp);\n  }\n\n  public removeEventListeners() {\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n    document.removeEventListener(\"keyup\", this.handleKeyUp);\n  }\n\n  private handleKeyDown = (e: KeyboardEvent) => {\n    this.keys[e.code] = true;\n    // Prevent default behavior for game keys\n    if ([\"KeyW\", \"KeyA\", \"KeyS\", \"KeyD\", \"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].includes(e.code)) {\n      e.preventDefault();\n    }\n  };\n\n  private handleKeyUp = (e: KeyboardEvent) => {\n    this.keys[e.code] = false;\n  };\n\n  public getInput() {\n    return {\n      up: this.keys[\"KeyW\"] || this.keys[\"ArrowUp\"],\n      down: this.keys[\"KeyS\"] || this.keys[\"ArrowDown\"],\n      left: this.keys[\"KeyA\"] || this.keys[\"ArrowLeft\"],\n      right: this.keys[\"KeyD\"] || this.keys[\"ArrowRight\"],\n      weapon1: this.keys[\"1\"],\n      weapon2: this.keys[\"2\"],\n      weapon3: this.keys[\"3\"],\n      weapon4: this.keys[\"4\"],\n      weapon5: this.keys[\"5\"],\n      mute: this.keys[\"m\"] || this.keys[\"M\"],\n      restart: this.keys[\"r\"] || this.keys[\"R\"]\n    };\n  }\n\n  private isKeyPressed(key: string): boolean {\n    return this.keys[key] === true;\n  }\n\n  public update() {\n    this.keys.left = this.isKeyPressed('ArrowLeft') || this.isKeyPressed('a') || this.isKeyPressed('A');\n    this.keys.right = this.isKeyPressed('ArrowRight') || this.isKeyPressed('d') || this.isKeyPressed('D');\n    this.keys.up = this.isKeyPressed('ArrowUp') || this.isKeyPressed('w') || this.isKeyPressed('W');\n    this.keys.down = this.isKeyPressed('ArrowDown') || this.isKeyPressed('s') || this.isKeyPressed('S');\n    this.keys.mute = this.isKeyPressed('m') || this.isKeyPressed('M');\n    this.keys.restart = this.isKeyPressed('r') || this.isKeyPressed('R');\n\n    // Debug keys for weapon testing\n    this.keys.weapon1 = this.isKeyPressed('1');\n    this.keys.weapon2 = this.isKeyPressed('2');\n    this.keys.weapon3 = this.isKeyPressed('3');\n    this.keys.weapon4 = this.isKeyPressed('4');\n    this.keys.weapon5 = this.isKeyPressed('5');\n  }\n}","path":null,"size_bytes":2746,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // put application routes here\n  // prefix all routes with /api\n\n  // use storage to perform CRUD operations on the storage interface\n  // e.g. storage.insertUser(user) or storage.getUserByUsername(username)\n\n  const httpServer = createServer(app);\n\n  return httpServer;\n}\n","path":null,"size_bytes":473,"size_tokens":null},"client/src/lib/game/config/PowerUpDefinitions.ts":{"content":"import { PowerUpDefinition } from \"../entities/collectibles/PowerUp\";\nimport { IPlayer } from \"../core/interfaces/IPlayer\";\n\nexport interface PowerUpDefinition {\n  id: string;\n  name: string;\n  description: string;\n  color: string;\n  icon?: string; // Added for potential UI representation\n  rarity?: string; // Added for potential rarity system\n  characterRestriction?: string;\n  apply: (player: IPlayer) => void;\n}\n\n// Placeholder for existing power-up definitions that are not provided in the original code snippet.\n// In a real scenario, these would be defined elsewhere and imported.\nconst healthUpgrade: PowerUpDefinition = { id: \"health_upgrade\", name: \"Health Upgrade\", description: \"Increase max health\", color: \"#FF1493\", apply: (player: IPlayer) => { player.maxHealth += 10; } };\nconst speedUpgrade: PowerUpDefinition = { id: \"speed_upgrade\", name: \"Speed Upgrade\", description: \"Increase movement speed\", color: \"#00BFFF\", apply: (player: IPlayer) => { player.setSpeed(player.getSpeed() * 1.1); } };\nconst damageUpgrade: PowerUpDefinition = { id: \"damage_upgrade\", name: \"Damage Upgrade\", description: \"Increase weapon damage\", color: \"#FF4500\", apply: (player: IPlayer) => { const weapon = player.getWeapon(); if (weapon && 'upgradeDamage' in weapon) { (weapon as any).upgradeDamage(); } } };\nconst fireRateUpgrade: PowerUpDefinition = { id: \"fire_rate_upgrade\", name: \"Fire Rate Upgrade\", description: \"Increase fire rate\", color: \"#FFA500\", apply: (player: IPlayer) => { const weapon = player.getWeapon(); if (weapon && 'upgradeFireRate' in weapon) { (weapon as any).upgradeFireRate(); } } };\nconst projectileSpeedUpgrade: PowerUpDefinition = { id: \"projectile_speed_upgrade\", name: \"Projectile Speed Upgrade\", description: \"Increase projectile speed\", color: \"#FFD700\", apply: (player: IPlayer) => { const weapon = player.getWeapon(); if (weapon && 'projectileSpeed' in weapon) { (weapon as any).projectileSpeed *= 1.2; } } };\nconst maxHealthUpgrade: PowerUpDefinition = { id: \"max_health_upgrade\", name: \"Max Health Upgrade\", description: \"Increase maximum health\", color: \"#FF69B4\", apply: (player: IPlayer) => { player.maxHealth += 20; } };\nconst addOrbitalWeapon: PowerUpDefinition = { id: \"add_orbital_weapon\", name: \"Orbital Weapon\", description: \"Summon a orbiting weapon\", color: \"#DA70D6\", apply: (player: IPlayer) => { console.log(\"Orbital weapon summoned!\"); } };\nconst addProjectile: PowerUpDefinition = { id: \"add_projectile\", name: \"Extra Projectile\", description: \"Fire an additional projectile\", color: \"#BA55D3\", apply: (player: IPlayer) => { console.log(\"Extra projectile fired!\"); } };\n\n\nexport const POWERUP_DEFINITIONS: PowerUpDefinition[] = [\n  {\n    id: \"speed_boost\",\n    name: \"Speed Boost\",\n    description: \"Increase movement speed by 15%\",\n    color: \"#00BFFF\",\n    apply: (player: IPlayer) => {\n      const speed = player.getSpeed();\n      player.setSpeed(speed * 1.15);\n    }\n  },\n  {\n    id: \"health_boost\",\n    name: \"Health Boost\",\n    description: \"Increase maximum health by 20\",\n    color: \"#FF1493\",\n    apply: (player: IPlayer) => {\n      const maxHealth = player.getMaxHealth();\n      const currentHealth = player.getHealth();\n      player.heal(20);\n    }\n  },\n  {\n    id: \"damage_boost\",\n    name: \"Damage Boost\",\n    description: \"Increase weapon damage by 25%\",\n    color: \"#FF4500\",\n    apply: (player: IPlayer) => {\n      const weapon = player.getWeapon();\n      if (weapon && 'upgradeDamage' in weapon) {\n        (weapon as any).upgradeDamage();\n      }\n    }\n  },\n  {\n    id: \"projectile_speed\",\n    name: \"Projectile Speed\",\n    description: \"Increase projectile speed by 20%\",\n    color: \"#FFD700\",\n    apply: (player: IPlayer) => {\n      const weapon = player.getWeapon();\n      if (weapon && 'projectileSpeed' in weapon) {\n        (weapon as any).projectileSpeed *= 1.2;\n      }\n    }\n  },\n  {\n    id: \"fire_rate\",\n    name: \"Fire Rate\",\n    description: \"Reduce cooldown between attacks by 15%\",\n    color: \"#FFA500\",\n    apply: (player: IPlayer) => {\n      const weapon = player.getWeapon();\n      if (weapon && 'upgradeFireRate' in weapon) {\n        (weapon as any).upgradeFireRate();\n      }\n    }\n  },\n  {\n    id: \"sylph_bloom_upgrade\",\n    name: \"Bloom Enhancement\",\n    description: \"Increase bloom damage and growth speed\",\n    color: \"#98FB98\",\n    characterRestriction: \"sylph\",\n    apply: (player: IPlayer) => {\n      const weapon = player.getWeapon();\n      if (weapon && weapon.constructor.name === \"SylphBloomsWeapon\") {\n        (weapon as any).upgradeFlowerCapacity();\n      }\n    }\n  },\n  {\n    id: \"big_spider\",\n    name: \"Big Mechanical Spider\",\n    description: \"Deploy one powerful mechanical spider\",\n    color: \"#8B4513\",\n    characterRestriction: \"assassin\",\n    apply: (player: IPlayer) => {\n      if ('setBigSpiderMode' in player) {\n        (player as any).setBigSpiderMode();\n      }\n    }\n  },\n  {\n    id: \"small_spiders\",\n    name: \"Small Spider Swarm\",\n    description: \"Deploy multiple agile spiders\",\n    color: \"#CD853F\",\n    characterRestriction: \"assassin\",\n    apply: (player: IPlayer) => {\n      if ('setSmallSpidersMode' in player) {\n        (player as any).setSmallSpidersMode();\n      }\n    }\n  }\n];\n\n// Additional power-ups\nconst criticalChance: PowerUpDefinition = {\n  id: \"critical_chance\",\n  name: \"Critical Hit\",\n  description: \"+10% critical hit chance (2x damage)\",\n  icon: \"\",\n  rarity: \"rare\",\n  apply: (player: IPlayer) => {\n    console.log(\"Critical chance increased!\");\n  },\n};\n\nconst lifeSteal: PowerUpDefinition = {\n  id: \"life_steal\",\n  name: \"Vampiric Touch\",\n  description: \"Heal 1 HP for every 50 damage dealt\",\n  icon: \"\",\n  rarity: \"rare\",\n  apply: (player: IPlayer) => {\n    console.log(\"Life steal enabled!\");\n  },\n};\n\nconst explosiveShots: PowerUpDefinition = {\n  id: \"explosive_shots\",\n  name: \"Explosive Rounds\",\n  description: \"Projectiles explode on impact\",\n  icon: \"\",\n  rarity: \"legendary\",\n  apply: (player: IPlayer) => {\n    console.log(\"Explosive shots enabled!\");\n  },\n};\n\nconst timeWarp: PowerUpDefinition = {\n  id: \"time_warp\",\n  name: \"Time Dilation\",\n  description: \"-20% enemy speed (stacks)\",\n  icon: \"\",\n  rarity: \"rare\",\n  apply: (player: IPlayer) => {\n    console.log(\"Time warp activated!\");\n  },\n};\n\nconst thorns: PowerUpDefinition = {\n  id: \"thorns\",\n  name: \"Thorny Armor\",\n  description: \"Reflect 25% damage back to attackers\",\n  icon: \"\",\n  rarity: \"uncommon\",\n  apply: (player: IPlayer) => {\n    console.log(\"Thorns activated!\");\n  },\n};\n\nconst multiShot: PowerUpDefinition = {\n  id: \"multi_shot\",\n  name: \"Multi-Shot\",\n  description: \"Fire 2 additional projectiles at angles\",\n  icon: \"\",\n  rarity: \"rare\",\n  apply: (player: IPlayer) => {\n    console.log(\"Multi-shot enabled!\");\n  },\n};\n\nconst magneticField: PowerUpDefinition = {\n  id: \"magnetic_field\",\n  name: \"Magnetic Field\",\n  description: \"+50% XP pickup range\",\n  icon: \"\",\n  rarity: \"common\",\n  apply: (player: IPlayer) => {\n    console.log(\"Magnetic field expanded!\");\n  },\n};\n\nconst berserk: PowerUpDefinition = {\n  id: \"berserk\",\n  name: \"Berserk Mode\",\n  description: \"+30% damage, -10% max health (trade-off)\",\n  icon: \"\",\n  rarity: \"legendary\",\n  apply: (player: IPlayer) => {\n    player.maxHealth = Math.max(20, player.maxHealth - 10);\n    console.log(\"Berserk mode activated!\");\n  },\n};\n\nconst ghostArmor: PowerUpDefinition = {\n  id: \"ghost_armor\",\n  name: \"Ghost Armor\",\n  description: \"10% chance to dodge attacks\",\n  icon: \"\",\n  rarity: \"rare\",\n  apply: (player: IPlayer) => {\n    console.log(\"Ghost armor equipped!\");\n  },\n};\n\nconst luckyCharm: PowerUpDefinition = {\n  id: \"lucky_charm\",\n  name: \"Lucky Charm\",\n  description: \"+15% better loot and XP\",\n  icon: \"\",\n  rarity: \"uncommon\",\n  apply: (player: IPlayer) => {\n    console.log(\"Lucky charm activated!\");\n  },\n};\n\nexport const POWER_UP_POOL: PowerUpDefinition[] = [\n  healthUpgrade,\n  speedUpgrade,\n  damageUpgrade,\n  fireRateUpgrade,\n  projectileSpeedUpgrade,\n  maxHealthUpgrade,\n  addOrbitalWeapon,\n  addProjectile,\n  criticalChance,\n  lifeSteal,\n  explosiveShots,\n  timeWarp,\n  thorns,\n  multiShot,\n  magneticField,\n  berserk,\n  ghostArmor,\n  luckyCharm,\n];","path":null,"size_bytes":8183,"size_tokens":null},"client/src/lib/game/entities/FollowerSpider.ts":{"content":"<replit_final_file>\n</replit_final_file>","path":null,"size_bytes":40,"size_tokens":null},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverAnchor = PopoverPrimitive.Anchor\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }\n","path":null,"size_bytes":1292,"size_tokens":null},"client/src/components/ui/drawer.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","path":null,"size_bytes":3021,"size_tokens":null},"client/src/lib/game/entities/MechanicalSpider.ts":{"content":"import { GameObject } from \"./Player\";\nimport { Enemy } from \"./Enemy\";\nimport { SpriteManager } from \"../rendering/SpriteManager\";\nimport { AnimationManager } from \"../rendering/AnimationManager\";\n\nexport class MechanicalSpider implements GameObject {\n  public x: number;\n  public y: number;\n  public width = 120; // Increased from 32 to match FollowerSpider\n  public height = 68; // Increased from 32 to match FollowerSpider\n  private vx = 0;\n  private vy = 0;\n  private speed = 150;\n  private alive = true;\n  private target: Enemy | null = null;\n  private attachedToEnemy = false; // Renamed from isAttached to avoid getter conflict\n  private damage = 2;\n  private damageTimer = 0;\n  private damageCooldown = 0.5; // damage every 0.5 seconds\n  private searchRadius = 120;\n  private spiderMode: \"normal\" | \"big\" | \"small\" = \"normal\";\n  private maxHealth = 1;\n  private lastDirection = { x: 0, y: 1 }; // Track movement direction for sprite selection\n  private isJumping = false;\n  private jumpStartPos = { x: 0, y: 0 };\n  private jumpTargetPos = { x: 0, y: 0 };\n  private jumpProgress = 0;\n  private jumpDuration = 0.4; // 400ms jump duration\n  private jumpHeight = 50; // pixels above ground during jump\n  private animationManager: AnimationManager;\n  private instanceId: string;\n  private currentAnimation = \"spider_idle\";\n  private lastAnimationFrame: any = null;\n  private lastAnimationSwitch = 0;\n  constructor(x: number, y: number, mode: \"normal\" | \"big\" | \"small\" = \"normal\") {\n    this.x = x;\n    this.y = y;\n    this.spiderMode = mode;\n    this.instanceId = `mechanical_spider_${Date.now()}_${Math.random()}`;\n    this.animationManager = new AnimationManager();\n\n    // Set stats based on mode\n    this.applyModeStats();\n    this.setupAnimations();\n  }\n\n  private applyModeStats() {\n    switch (this.spiderMode) {\n      case \"big\":\n        this.damage = 8; // Much higher damage\n        this.maxHealth = 3; // More durable\n        this.damageCooldown = 0.3; // Faster attack rate\n        this.speed = 120; // Slightly slower\n        this.searchRadius = 150; // Larger search radius\n        this.width = 160; // Bigger size\n        this.height = 90;\n        break;\n      case \"small\":\n        this.damage = 1; // Lower damage\n        this.maxHealth = 1; // Dies in one hit\n        this.damageCooldown = 0.8; // Slower attack rate\n        this.speed = 200; // Much faster\n        this.searchRadius = 100; // Smaller search radius\n        this.width = 80; // Smaller size\n        this.height = 45;\n        break;\n      default: // normal\n        this.damage = 2;\n        this.maxHealth = 1;\n        this.damageCooldown = 0.5;\n        this.speed = 150;\n        this.searchRadius = 120;\n        this.width = 120;\n        this.height = 68;\n        break;\n    }\n  }\n\n  private setupAnimations() {\n    // Generate all 30 walking frames (each frame is 800px wide)\n    const walkFrames = [];\n    for (let i = 0; i < 30; i++) {\n      walkFrames.push({\n        x: i * 800,\n        y: 0,\n        width: 800,\n        height: 450\n      });\n    }\n\n    // Use the first frame as idle animation\n    const idleFrames = [\n      { x: 0, y: 0, width: 800, height: 450 }\n    ];\n\n    // Jumping animation - 4 stages from the 1408x272 spritesheet\n    // Stage 1: idle, Stage 2: jumping, Stage 3: landing, Stage 4: idle again\n    const jumpingFrames = [];\n    const jumpFrameWidth = 1408 / 4; // 352px per frame\n    for (let i = 0; i < 4; i++) {\n      jumpingFrames.push({\n        x: i * jumpFrameWidth,\n        y: 0,\n        width: jumpFrameWidth,\n        height: 272\n      });\n    }\n\n    this.animationManager.addAnimation(\"spider_idle\", idleFrames, 0.5, true);\n    this.animationManager.addAnimation(\"spider_walk_down\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_up\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_side\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_walk_diagonal\", walkFrames, 0.05, true);\n    this.animationManager.addAnimation(\"spider_jumping\", jumpingFrames, 0.1, false); // Don't loop, play once\n\n    this.lastAnimationFrame = idleFrames[0];\n\n    // Start with idle animation\n    this.animationManager.startAnimation(\"spider_idle\", this.instanceId);\n  }\n\n  public update(deltaTime: number, enemies: Enemy[], playerPos: { x: number; y: number }) {\n    if (!this.alive) return;\n\n    let targetAnimation = \"spider_idle\";\n    let positionChanged = false;\n\n    if (this.attachedToEnemy && this.target) {\n      // Spider is attached to enemy - deal damage over time\n      this.damageTimer += deltaTime;\n\n      if (!this.target.isAlive()) {\n        // When target dies, detach and find new target\n        this.attachedToEnemy = false;\n        this.target = null;\n        return;\n      }\n\n      // Follow the target enemy only if position actually changed\n      if (this.x !== this.target.x || this.y !== this.target.y) {\n        this.x = this.target.x;\n        this.y = this.target.y;\n        positionChanged = true;\n      }\n\n      // Deal damage periodically\n      if (this.damageTimer >= this.damageCooldown) {\n        this.target.takeDamage(this.damage);\n        this.damageTimer = 0;\n      }\n\n      targetAnimation = \"spider_idle\";\n    } else {\n      // Spider is searching for a target\n      if (!this.target || !this.target.isAlive()) {\n        this.findNearestEnemy(enemies, playerPos);\n      }\n\n      if (this.target) {\n        const dx = this.target.x - this.x;\n        const dy = this.target.y - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 35) {\n          // Attach to enemy\n          this.attachedToEnemy = true;\n          this.isJumping = false;\n          this.x = this.target.x;\n          this.y = this.target.y;\n          positionChanged = true;\n        } else if (this.isJumping) {\n          // Handle jumping animation\n          this.jumpProgress += deltaTime / this.jumpDuration;\n\n          if (this.jumpProgress >= 1) {\n            // Jump complete\n            this.x = this.jumpTargetPos.x;\n            this.y = this.jumpTargetPos.y;\n            this.isJumping = false;\n            this.jumpProgress = 0;\n            positionChanged = true;\n\n            // Check for immediate attachment\n            if (this.target && this.target.isAlive()) {\n              const finalDx = this.target.x - this.x;\n              const finalDy = this.target.y - this.y;\n              const finalDistance = Math.sqrt(finalDx * finalDx + finalDy * finalDy);\n\n              if (finalDistance < 35) {\n                this.attachedToEnemy = true;\n                this.x = this.target.x;\n                this.y = this.target.y;\n              }\n            }\n\n            targetAnimation = \"spider_idle\";\n          } else {\n            // Smooth interpolation during jump\n            const t = this.jumpProgress;\n            const newX = this.jumpStartPos.x + (this.jumpTargetPos.x - this.jumpStartPos.x) * t;\n            const newY = this.jumpStartPos.y + (this.jumpTargetPos.y - this.jumpStartPos.y) * t;\n\n            if (Math.abs(newX - this.x) > 1 || Math.abs(newY - this.y) > 1) {\n              this.x = newX;\n              this.y = newY;\n              positionChanged = true;\n            }\n\n            // Only update direction when starting jump or major direction change\n            if (this.jumpProgress < 0.1) {\n              this.lastDirection.x = (this.jumpTargetPos.x - this.jumpStartPos.x) / distance;\n              this.lastDirection.y = (this.jumpTargetPos.y - this.jumpStartPos.y) / distance;\n            }\n\n            targetAnimation = \"spider_jumping\";\n          }\n        } else {\n          // Start jumping\n          this.isJumping = true;\n          this.jumpStartPos = { x: this.x, y: this.y };\n          this.jumpTargetPos = { x: this.target.x, y: this.target.y };\n          this.jumpProgress = 0;\n\n          this.lastDirection.x = dx / distance;\n          this.lastDirection.y = dy / distance;\n\n          targetAnimation = \"spider_jumping\";\n        }\n      } else {\n        targetAnimation = \"spider_idle\";\n      }\n    }\n\n    // Only switch animation when absolutely necessary\n    if (this.currentAnimation !== targetAnimation) {\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n      this.lastAnimationSwitch = Date.now();\n    }\n  }\n\n  private findNearestEnemy(enemies: Enemy[], playerPos: { x: number; y: number }) {\n    let nearestEnemy: Enemy | null = null;\n    let nearestDistance = Infinity;\n\n    for (const enemy of enemies) {\n      if (!enemy.isAlive()) continue;\n\n      // Check if enemy is within radius of player\n      const dx = enemy.x - playerPos.x;\n      const dy = enemy.y - playerPos.y;\n      const distanceFromPlayer = Math.sqrt(dx * dx + dy * dy);\n\n      // Only consider enemies within player's radius\n      if (distanceFromPlayer <= this.searchRadius && distanceFromPlayer < nearestDistance) {\n        nearestDistance = distanceFromPlayer;\n        nearestEnemy = enemy;\n      }\n    }\n\n    this.target = nearestEnemy;\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public destroy(): void {\n    this.alive = false;\n  }\n\n  public get isAttached(): boolean {\n    return this.attachedToEnemy; // Return the renamed property\n  }\n\n  public get health(): number {\n    return this.target?.health || 0;\n  }\n\n\n\n\n\n\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX: number = 0, cameraY: number = 0) {\n    // Spider rendering is handled by InfiniteTileRenderer to prevent double rendering\n    // and eliminate afterimage/black square issues\n    return;\n  }\n\n  private renderFallbackSpider(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number) {\n    ctx.save();\n\n    // Create a more detailed spider shape instead of just a circle\n    const centerX = this.x - cameraX;\n    const centerY = this.y - cameraY;\n    const size = 32; // Increased size for better visibility\n\n    if (this.attachedToEnemy) {\n      // Red spider when attached to enemy\n      ctx.fillStyle = \"#ff4444\";\n      ctx.strokeStyle = \"#ff0000\";\n      ctx.shadowColor = \"#ff3333\";\n      ctx.shadowBlur = 10;\n    } else {\n      // Blue/cyan spider when searching/moving\n      ctx.fillStyle = \"#4444ff\";\n      ctx.strokeStyle = \"#0000ff\";\n      ctx.shadowColor = \"#3333ff\";\n      ctx.shadowBlur = 6;\n    }\n\n    ctx.globalAlpha = 1.0; // Full opacity for better visibility\n    ctx.lineWidth = 3;\n\n    // Draw spider body (oval)\n    ctx.beginPath();\n    ctx.ellipse(centerX, centerY, size, size * 0.6, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // Draw spider legs (8 legs)\n    ctx.lineWidth = 4;\n    for (let i = 0; i < 8; i++) {\n      const angle = (i * Math.PI * 2) / 8;\n      const legLength = size * 1.8;\n      const legX = centerX + Math.cos(angle) * legLength;\n      const legY = centerY + Math.sin(angle) * legLength;\n\n      ctx.beginPath();\n      ctx.moveTo(centerX, centerY);\n      ctx.lineTo(legX, legY);\n      ctx.stroke();\n    }\n\n    // Add bright center dot for visibility\n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size * 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Add pulsing effect when attached\n    if (this.attachedToEnemy) {\n      const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;\n      ctx.globalAlpha = pulse;\n      ctx.fillStyle = \"#ffaaaa\";\n      ctx.beginPath();\n      ctx.ellipse(centerX, centerY, size * 1.2, size * 0.8, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.restore();\n  }\n}","path":null,"size_bytes":11535,"size_tokens":null},"client/src/components/CharacterSelection.tsx":{"content":"\nimport { useState } from \"react\";\n\nexport interface CharacterType {\n  id: \"sylph\" | \"assassin\";\n  name: string;\n  description: string;\n  weapon: string;\n  stats: {\n    speed: number;\n    health: number;\n    special: string;\n  };\n  color: string;\n}\n\nconst CHARACTERS: CharacterType[] = [\n  {\n    id: \"sylph\",\n    name: \" Sylph Guardian\",\n    description: \"A mystical guardian who communes with nature\",\n    weapon: \"Sylph Blooms - Spawns magical flower turrets\",\n    stats: {\n      speed: 200,\n      health: 100,\n      special: \"Flower turrets that grow stronger over time\"\n    },\n    color: \"#e91e63\"\n  },\n  {\n    id: \"assassin\",\n    name: \" Shadow Assassin\",\n    description: \"A deadly hunter with mechanical companions\",\n    weapon: \"Spider Swarm - Mechanical spiders hunt enemies\",\n    stats: {\n      speed: 250,\n      health: 80,\n      special: \"Fast movement, mechanical spider companions\"\n    },\n    color: \"#444444\"\n  }\n];\n\ninterface CharacterSelectionProps {\n  onSelect: (character: CharacterType) => void;\n  onClose: () => void;\n}\n\nexport default function CharacterSelection({ onSelect, onClose }: CharacterSelectionProps) {\n  const [selectedCharacter, setSelectedCharacter] = useState<CharacterType | null>(null);\n\n  const handleSelect = () => {\n    if (selectedCharacter) {\n      onSelect(selectedCharacter);\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"absolute inset-0 bg-black bg-opacity-95 flex items-center justify-center z-50\">\n      <div className=\"bg-gray-900 border-2 border-yellow-400 rounded-lg p-8 max-w-4xl w-full mx-4\">\n        <h2 className=\"text-4xl font-bold text-yellow-400 text-center mb-2\">Choose Your Character</h2>\n        <p className=\"text-white text-center mb-8\">Select your playstyle and begin your survival journey</p>\n        \n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 mb-8\">\n          {CHARACTERS.map((character) => (\n            <button\n              key={character.id}\n              onClick={() => setSelectedCharacter(character)}\n              className={`bg-gray-800 border-2 rounded-lg p-6 transition-all duration-200 text-left group ${\n                selectedCharacter?.id === character.id \n                  ? 'border-yellow-400 bg-gray-700' \n                  : 'border-gray-600 hover:border-gray-400'\n              }`}\n            >\n              <div className=\"flex items-center mb-4\">\n                <div \n                  className=\"w-12 h-12 rounded mr-4 shadow-lg flex items-center justify-center text-2xl\"\n                  style={{ \n                    backgroundColor: character.color,\n                    boxShadow: `0 0 15px ${character.color}50`\n                  }}\n                >\n                  {character.id === 'sylph' ? '' : ''}\n                </div>\n                <h3 className=\"text-2xl font-bold text-white group-hover:text-yellow-400\">\n                  {character.name}\n                </h3>\n              </div>\n              \n              <p className=\"text-gray-300 mb-4 leading-relaxed\">\n                {character.description}\n              </p>\n              \n              <div className=\"space-y-2 text-sm\">\n                <div className=\"flex justify-between\">\n                  <span className=\"text-gray-400\">Speed:</span>\n                  <span className=\"text-white\">{character.stats.speed}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span className=\"text-gray-400\">Health:</span>\n                  <span className=\"text-white\">{character.stats.health}</span>\n                </div>\n                <div className=\"mt-3\">\n                  <span className=\"text-gray-400\">Weapon:</span>\n                  <p className=\"text-white text-xs mt-1\">{character.weapon}</p>\n                </div>\n                <div className=\"mt-3\">\n                  <span className=\"text-gray-400\">Special:</span>\n                  <p className=\"text-white text-xs mt-1\">{character.stats.special}</p>\n                </div>\n              </div>\n            </button>\n          ))}\n        </div>\n        \n        <div className=\"flex justify-center space-x-4\">\n          <button\n            onClick={handleSelect}\n            disabled={!selectedCharacter}\n            className={`px-8 py-3 rounded-lg font-bold text-lg transition-all duration-200 ${\n              selectedCharacter\n                ? 'bg-yellow-400 text-black hover:bg-yellow-300'\n                : 'bg-gray-600 text-gray-400 cursor-not-allowed'\n            }`}\n          >\n            Start Game\n          </button>\n          <button\n            onClick={onClose}\n            className=\"px-8 py-3 rounded-lg font-bold text-lg bg-gray-700 text-white hover:bg-gray-600 transition-all duration-200\"\n          >\n            Back\n          </button>\n        </div>\n        \n        <p className=\"text-gray-400 text-center text-sm mt-4\">\n          Click on a character to select, then press Start Game\n        </p>\n      </div>\n    </div>\n  );\n}\n\nexport { CHARACTERS };\n","path":null,"size_bytes":5029,"size_tokens":null},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","path":null,"size_bytes":5124,"size_tokens":null},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","path":null,"size_bytes":1419,"size_tokens":null},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","path":null,"size_bytes":6210,"size_tokens":null},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","path":null,"size_bytes":140,"size_tokens":null},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n      {children}\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","path":null,"size_bytes":4280,"size_tokens":null},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path, { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        __dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","path":null,"size_bytes":2374,"size_tokens":null},"client/src/lib/game/core/interfaces/IGameObject.ts":{"content":"\nexport interface IGameObject {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface ICollidable extends IGameObject {\n  collisionWidth?: number;\n  collisionHeight?: number;\n}\n\nexport interface IRenderable {\n  render(ctx: CanvasRenderingContext2D, deltaTime: number, cameraX?: number, cameraY?: number): void;\n}\n\nexport interface IUpdatable {\n  update(deltaTime: number, ...args: any[]): void;\n}\n\nexport interface IDestroyable {\n  isAlive(): boolean;\n  destroy(): void;\n}\n","path":null,"size_bytes":500,"size_tokens":null},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","path":null,"size_bytes":4419,"size_tokens":null},"client/src/App.tsx":{"content":"import Game from './components/Game'\nimport { UndeadTileMapViewer } from './components/UndeadTileMapViewer'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { useState } from 'react'\nimport { Button } from './components/ui/button'\n\nfunction App() {\n  const [queryClient] = useState(() => new QueryClient())\n  const [currentView, setCurrentView] = useState<'game' | 'tilemap'>('game')\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <div className=\"w-full h-screen bg-gray-900 text-white relative overflow-hidden\">\n        <div className=\"absolute top-4 left-4 z-50\">\n          <button\n            onClick={() => setCurrentView(currentView === 'game' ? 'tilemap' : 'game')}\n            className=\"px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors shadow-lg\"\n          >\n            {currentView === 'game' ? 'View Tilemap' : 'Back to Game'}\n          </button>\n        </div>\n\n        <div className=\"w-full h-full\">\n          {currentView === 'game' ? <Game /> : <UndeadTileMapViewer />}\n        </div>\n      </div>\n    </QueryClientProvider>\n  )\n}\n\nexport default App","path":null,"size_bytes":1146,"size_tokens":null},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-9 px-2 min-w-9\",\n        sm: \"h-8 px-1.5 min-w-8\",\n        lg: \"h-10 px-2.5 min-w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","path":null,"size_bytes":1486,"size_tokens":null},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","path":null,"size_bytes":1140,"size_tokens":null},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","path":null,"size_bytes":1642,"size_tokens":null},"client/src/lib/game/core/interfaces/IPlayer.ts":{"content":"\nimport { IEntity, IDamageable, IHealable } from './IEntity';\nimport { IWeapon } from './IWeapon';\nimport { IProjectile } from './IProjectile';\n\nexport interface IPlayer extends IEntity, IDamageable, IHealable {\n  getWeapon(): IWeapon | null;\n  setWeapon(weapon: IWeapon): void;\n  fireWeapon(deltaTime: number): IProjectile[];\n  getSpeed(): number;\n  setSpeed(speed: number): void;\n}\n","path":null,"size_bytes":384,"size_tokens":null},"client/src/lib/game/services/IGameStateService.ts":{"content":"\nexport interface IGameStateService {\n  addScore(points: number): void;\n  addExperience(amount: number): void;\n  takeDamage(amount: number): void;\n  setWave(wave: number): void;\n  getCurrentPhase(): string;\n}\n","path":null,"size_bytes":209,"size_tokens":null},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","path":null,"size_bytes":649,"size_tokens":null},"client/src/lib/game/managers/TileConfig.ts":{"content":"\nexport const TileConfig = {\n  TILE_SIZE: 32,\n  CHUNK_SIZE: 32,\n  TILES_PER_ROW: 5,\n  SRC_TILE_SIZE: 16,\n  \n  // Rendering optimization\n  RENDER_BUFFER: 2, // Extra tiles to render outside viewport\n  CHUNK_CLEANUP_DISTANCE: 3, // Distance in chunks before cleanup\n  \n  // Generation probabilities (0-100)\n  GENERATION: {\n    GROUND_THRESHOLD: 60,\n    DECORATION_THRESHOLD: 70,\n    VEGETATION_THRESHOLD: 75,\n    STRUCTURE_THRESHOLD: 85,\n    STRUCTURE_DENSITY: 5, // Percentage chance for structures in valid areas\n  },\n  \n  // Camera settings\n  CAMERA: {\n    FOLLOW_SPEED: 0.1,\n    SMOOTHING: true,\n  },\n  \n  // Collision settings\n  COLLISION: {\n    PLAYER_MARGIN: 2, // Pixels of margin to prevent getting stuck\n  },\n  \n  // Sprite paths\n  SPRITES: {\n    UNDEAD_TILESET: '/craftpix-net-695666-free-undead-tileset-top-down-pixel-art/PNG/Ground_rocks.png'\n  }\n};\n","path":null,"size_bytes":861,"size_tokens":null},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","path":null,"size_bytes":1598,"size_tokens":null},"client/src/lib/game/weapons/SylphBloomsWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { InfiniteTileRenderer } from \"../rendering/InfiniteTileRenderer\";\nimport { Particle } from \"../rendering/Particle\";\n\n\n\nexport class SylphBloomsWeapon {\n  protected damage: number;\n  protected fireRate: number;\n  protected projectileSpeed: number;\n  protected lastFireTime: number = 0;\n  private lastFlowerSpawn: number = 0;\n  private flowerSpawnInterval: number = 8000; // 8 seconds between flower spawns\n  private maxFlowers: number = 4; // Maximum flowers on field\n  private flowerLifespan: number = 15000; // 15 seconds lifespan\n  private tileRenderer: InfiniteTileRenderer | null = null;\n\n  constructor() {\n    this.fireRate = 2;\n    this.damage = 35;\n    this.projectileSpeed = 150;\n  }\n\n  // SylphBloomsWeapon doesn't fire regular projectiles, only flower orbs\n  public fire(\n    deltaTime: number,\n    playerX: number,\n    playerY: number,\n    direction?: { x: number; y: number },\n  ): any[] {\n    return []; // No regular projectiles\n  }\n\n  public setTileRenderer(tileRenderer: InfiniteTileRenderer): void {\n    this.tileRenderer = tileRenderer;\n  }\n\n  update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number,\n  ): void {\n    if (!this.tileRenderer) return;\n\n    const now = Date.now();\n\n    // Spawn new flowers periodically\n    const currentFlowers = this.tileRenderer.getAllFlowers();\n    if (\n      now - this.lastFlowerSpawn >= this.flowerSpawnInterval &&\n      currentFlowers.length < this.maxFlowers\n    ) {\n      this.spawnFlowerTurret(playerX, playerY);\n      this.lastFlowerSpawn = now;\n    }\n\n    // Update flowers through tile renderer\n    this.tileRenderer.updateFlowers(deltaTime);\n\n    // Check flower shooting\n    const flowers = this.tileRenderer.getAllFlowers();\n    flowers.forEach((flower) => {\n      if (this.tileRenderer!.canFlowerShoot(flower)) {\n        const tileSize = this.tileRenderer!.getTileSize();\n        const flowerWorldX = flower.tileX * tileSize + Math.floor(tileSize / 2);\n        const flowerWorldY = flower.tileY * tileSize + Math.floor(tileSize / 2);\n        const nearestEnemy = this.findNearestEnemy(\n          enemies,\n          flowerWorldX,\n          flowerWorldY,\n          200,\n        );\n        if (nearestEnemy) {\n          this.tileRenderer!.fireOrbFromFlower(flower, nearestEnemy, this.damage);\n          this.tileRenderer!.flowerShoot(flower);\n        }\n      }\n    });\n\n    // Update orbs through tile renderer\n    this.tileRenderer.updateOrbs(deltaTime, enemies, playerX, playerY);\n  }\n\n  private spawnFlowerTurret(playerX: number, playerY: number): void {\n    if (!this.tileRenderer) return;\n\n    const tileSize = this.tileRenderer.getTileSize();\n    const playerTileX = Math.floor(playerX / tileSize);\n    const playerTileY = Math.floor(playerY / tileSize);\n    const maxTileRadius = 6;\n    const minTileRadius = 3;\n\n    const existingFlowers = this.tileRenderer.getAllFlowers();\n\n    let foundPosition = false;\n    let attempts = 0;\n    let targetTileX = playerTileX;\n    let targetTileY = playerTileY;\n\n    while (!foundPosition && attempts < 50) {\n      const angle = Math.random() * Math.PI * 2;\n      const tileRadius =\n        minTileRadius +\n        Math.floor(Math.random() * (maxTileRadius - minTileRadius + 1));\n      targetTileX = playerTileX + Math.round(Math.cos(angle) * tileRadius);\n      targetTileY = playerTileY + Math.round(Math.sin(angle) * tileRadius);\n\n      // Check if tile is already occupied\n      const existingFlower = this.tileRenderer.getFlower(\n        targetTileX,\n        targetTileY,\n      );\n      if (!existingFlower) {\n        // Check distance from other flowers\n        let tooClose = false;\n        for (const flower of existingFlowers) {\n          const dx = flower.tileX - targetTileX;\n          const dy = flower.tileY - targetTileY;\n          const tileDistance = Math.sqrt(dx * dx + dy * dy);\n          if (tileDistance < 2) {\n            tooClose = true;\n            break;\n          }\n        }\n\n        if (!tooClose) {\n          foundPosition = true;\n        }\n      }\n      attempts++;\n    }\n\n    // Fallback position if no good spot found\n    if (!foundPosition) {\n      const angle = Math.random() * Math.PI * 2;\n      const tileRadius = 4;\n      targetTileX = playerTileX + Math.round(Math.cos(angle) * tileRadius);\n      targetTileY = playerTileY + Math.round(Math.sin(angle) * tileRadius);\n    }\n\n    const flower = this.tileRenderer.addFlower(\n      targetTileX,\n      targetTileY,\n      this.flowerLifespan,\n    );\n    if (flower) {\n      const worldX = targetTileX * tileSize;\n      const worldY = targetTileY * tileSize;\n      console.log(`Spawned flower:`);\n      console.log(`  Tile coords: (${targetTileX}, ${targetTileY})`);\n      console.log(`  World coords: (${worldX}, ${worldY})`);\n      console.log(\n        `  Player coords: (${playerX.toFixed(1)}, ${playerY.toFixed(1)})`,\n      );\n      console.log(`  Player tile: (${playerTileX}, ${playerTileY})`);\n    }\n  }\n\n  private findNearestEnemy(\n    enemies: Enemy[],\n    x: number,\n    y: number,\n    maxRange: number,\n  ): Enemy | null {\n    let nearest: Enemy | null = null;\n    let nearestDistance = maxRange;\n\n    enemies.forEach((enemy) => {\n      if (enemy.health <= 0) return;\n\n      const dx = enemy.x - x;\n      const dy = enemy.y - y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < nearestDistance) {\n        nearest = enemy;\n        nearestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n\n\n  render(\n    ctx: CanvasRenderingContext2D,\n    cameraX: number,\n    cameraY: number,\n  ): void {\n    // Flowers and orbs are now rendered by the tile system\n    // This method is kept for interface compatibility but does nothing\n  }\n\n  checkCollisions(enemies: Enemy[]): { enemy: any; damage: number; orbX: number; orbY: number }[] {\n    // Delegate collision checking to tile renderer and return results\n    if (this.tileRenderer) {\n      return this.tileRenderer.checkOrbCollisions(enemies);\n    }\n    return [];\n  }\n\n  getParticles(): Particle[] {\n    return this.tileRenderer ? this.tileRenderer.getAllOrbs() : [];\n  }\n\n  // Upgrade methods for power-ups\n  public upgradeDamage() {\n    this.damage += 5;\n  }\n\n  public upgradeFireRate() {\n    // Reduce flower spawn interval and shot cooldown\n    this.flowerSpawnInterval = Math.max(2000, this.flowerSpawnInterval - 300);\n    // Note: Individual flower shot cooldowns are handled by the tile renderer\n  }\n\n  public upgradeFlowerCapacity() {\n    this.maxFlowers = Math.min(6, this.maxFlowers + 1);\n  }\n\n  public upgradeFlowerLifespan() {\n    this.flowerLifespan += 3000; // +3 seconds\n  }\n}","path":null,"size_bytes":6667,"size_tokens":null},"client/src/lib/game/factories/EnemyFactory.ts":{"content":"import { IEnemy } from '../core/interfaces/IEnemy';\nimport { Enemy } from '../entities/enemies/Enemy';\nimport { FlyingEnemy } from '../entities/enemies/FlyingEnemy';\nimport { RangedEnemy } from '../entities/enemies/RangedEnemy';\nimport { TeleportingEnemy } from '../entities/enemies/TeleportingEnemy';\nimport { SplittingEnemy } from '../entities/enemies/SplittingEnemy';\nimport { ShieldedEnemy } from '../entities/enemies/ShieldedEnemy';\n\nexport type BasicEnemyType = 'basic' | 'fast' | 'tank';\nexport type SpecialEnemyType = 'flying' | 'ranged' | 'teleporting' | 'splitting' | 'shielded';\nexport type EnemyType = BasicEnemyType | SpecialEnemyType;\n\nexport interface SpawnWeight {\n  type: EnemyType;\n  weight: number;\n  minWave: number;\n}\n\nexport class EnemyFactory {\n  private static readonly spawnWeights: SpawnWeight[] = [\n    { type: 'basic', weight: 40, minWave: 1 },\n    { type: 'fast', weight: 20, minWave: 2 },\n    { type: 'tank', weight: 10, minWave: 3 },\n    { type: 'flying', weight: 15, minWave: 2 },\n    { type: 'ranged', weight: 12, minWave: 3 },\n    { type: 'teleporting', weight: 8, minWave: 4 },\n    { type: 'splitting', weight: 10, minWave: 4 },\n    { type: 'shielded', weight: 8, minWave: 5 },\n  ];\n\n  public static createEnemy(type: EnemyType, x: number, y: number): IEnemy {\n    switch (type) {\n      case 'flying':\n        return new FlyingEnemy(x, y);\n      case 'ranged':\n        return new RangedEnemy(x, y);\n      case 'teleporting':\n        return new TeleportingEnemy(x, y);\n      case 'splitting':\n        return new SplittingEnemy(x, y);\n      case 'shielded':\n        return new ShieldedEnemy(x, y);\n      case 'basic':\n      case 'fast':\n      case 'tank':\n        return new Enemy(x, y, type);\n      default:\n        return new Enemy(x, y, 'basic');\n    }\n  }\n\n  public static createFlyingEnemy(x: number, y: number): FlyingEnemy {\n    return new FlyingEnemy(x, y);\n  }\n\n  public static createRangedEnemy(x: number, y: number): RangedEnemy {\n    return new RangedEnemy(x, y);\n  }\n\n  public static createTeleportingEnemy(x: number, y: number): TeleportingEnemy {\n    return new TeleportingEnemy(x, y);\n  }\n\n  public static createSplittingEnemy(x: number, y: number, splitLevel: number = 0): SplittingEnemy {\n    return new SplittingEnemy(x, y, splitLevel);\n  }\n\n  public static createShieldedEnemy(x: number, y: number): ShieldedEnemy {\n    return new ShieldedEnemy(x, y);\n  }\n\n  public static createRandomEnemy(x: number, y: number, currentWave: number = 1): IEnemy {\n    const availableTypes = this.spawnWeights.filter(sw => currentWave >= sw.minWave);\n    \n    const totalWeight = availableTypes.reduce((sum, sw) => sum + sw.weight, 0);\n    let random = Math.random() * totalWeight;\n    \n    for (const spawnWeight of availableTypes) {\n      random -= spawnWeight.weight;\n      if (random <= 0) {\n        return this.createEnemy(spawnWeight.type, x, y);\n      }\n    }\n    \n    return this.createEnemy('basic', x, y);\n  }\n\n  public static getAvailableTypesForWave(wave: number): EnemyType[] {\n    return this.spawnWeights\n      .filter(sw => wave >= sw.minWave)\n      .map(sw => sw.type);\n  }\n\n  public static getSpawnChance(type: EnemyType, wave: number): number {\n    const spawnWeight = this.spawnWeights.find(sw => sw.type === type);\n    if (!spawnWeight || wave < spawnWeight.minWave) return 0;\n    \n    const availableTypes = this.spawnWeights.filter(sw => wave >= sw.minWave);\n    const totalWeight = availableTypes.reduce((sum, sw) => sum + sw.weight, 0);\n    \n    return spawnWeight.weight / totalWeight;\n  }\n}\n","path":null,"size_bytes":3554,"size_tokens":null},"client/src/lib/game/entities/collectibles/PowerUp.ts":{"content":"\nimport { IPlayer } from \"../../core/interfaces/IPlayer\";\n\nexport interface PowerUpDefinition {\n  id: string;\n  name: string;\n  description: string;\n  color: string;\n  apply: (player: IPlayer) => void;\n  characterRestriction?: \"sylph\" | \"assassin\";\n}\n\nexport class PowerUp {\n  constructor(\n    public x: number,\n    public y: number,\n    public definition: PowerUpDefinition\n  ) {}\n\n  public apply(player: IPlayer): void {\n    this.definition.apply(player);\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.fillStyle = this.definition.color;\n    ctx.fillRect(this.x - 10, this.y - 10, 20, 20);\n    \n    ctx.shadowColor = this.definition.color;\n    ctx.shadowBlur = 10;\n    ctx.fillRect(this.x - 8, this.y - 8, 16, 16);\n    ctx.shadowBlur = 0;\n  }\n}\n","path":null,"size_bytes":768,"size_tokens":null},"client/src/components/ui/hover-card.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","path":null,"size_bytes":1198,"size_tokens":null},"client/src/index.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    width: 100vw;\n    height: 100vh;\n  }\n}\n\n#root {\n  width: 100%;\n  height: 100%;\n  position: fixed;\n}\n\ncanvas {\n  width: 100% !important;\n  height: 100% !important;\n  touch-action: none;\n  image-rendering: auto;\n}","path":null,"size_bytes":452,"size_tokens":null},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-xl border bg-card text-card-foreground shadow\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"font-semibold leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","path":null,"size_bytes":1828,"size_tokens":null},"client/src/lib/stores/useGame.tsx":{"content":"import { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\n\nexport type GamePhase = \"ready\" | \"playing\" | \"ended\";\n\ninterface GameState {\n  phase: GamePhase;\n  \n  // Actions\n  start: () => void;\n  restart: () => void;\n  end: () => void;\n}\n\nexport const useGame = create<GameState>()(\n  subscribeWithSelector((set) => ({\n    phase: \"ready\",\n    \n    start: () => {\n      set((state) => {\n        // Only transition from ready to playing\n        if (state.phase === \"ready\") {\n          return { phase: \"playing\" };\n        }\n        return {};\n      });\n    },\n    \n    restart: () => {\n      set(() => ({ phase: \"ready\" }));\n    },\n    \n    end: () => {\n      set((state) => {\n        // Only transition from playing to ended\n        if (state.phase === \"playing\") {\n          return { phase: \"ended\" };\n        }\n        return {};\n      });\n    }\n  }))\n);\n","path":null,"size_bytes":893,"size_tokens":null},"client/src/lib/game/weapons/projectiles/Projectile.ts":{"content":"import { IProjectile } from \"../../core/interfaces/IProjectile\";\nimport { IGameObject } from \"../../core/interfaces/IGameObject\";\n\nexport class Projectile implements IProjectile, IGameObject {\n  public x: number;\n  public y: number;\n  public width = 8;\n  public height = 8;\n  public vx: number;\n  public vy: number;\n  private damage: number;\n  private alive = true;\n  private lifetime = 8;\n  private piercing = false;\n  private hitCount = 0;\n  private maxHits = 1;\n  private isSylphOrb = false;\n\n  constructor(x: number, y: number, vx: number, vy: number, damage: number) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.damage = damage;\n  }\n\n  public update(deltaTime: number): void {\n    if (!this.alive) return;\n\n    const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) && deltaTime > 0 ?\n      Math.min(deltaTime, 1/30) : 0.016;\n\n    // Update position\n    this.x += this.vx * validDeltaTime;\n    this.y += this.vy * validDeltaTime;\n\n    this.lifetime -= validDeltaTime;\n    if (this.lifetime <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public isAlive(): boolean {\n    return this.alive;\n  }\n\n  public destroy(): void {\n    this.alive = false;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public setSylphOrb(isSylph: boolean): void {\n    this.isSylphOrb = isSylph;\n  }\n\n  public isSylphOrbProjectile(): boolean {\n    return this.isSylphOrb;\n  }\n\n  public isPiercing(): boolean {\n    return this.piercing;\n  }\n\n  public setPiercing(piercing: boolean, maxHits: number = 3): void {\n    this.piercing = piercing;\n    this.maxHits = maxHits;\n  }\n\n  public addHit(): boolean {\n    if (this.piercing) {\n      this.hitCount++;\n      if (this.hitCount >= this.maxHits) {\n        this.destroy();\n        return true;\n      }\n      return false;\n    } else {\n      this.destroy();\n      return true;\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number = 0, cameraY: number = 0): void {\n    const screenX = this.x - cameraX;\n    const screenY = this.y - cameraY;\n\n    ctx.save();\n\n    if (this.isSylphOrb) {\n      this.renderSylphOrb(ctx, screenX, screenY);\n    } else if (this.damage >= 1.5) {\n      this.renderEmeraldBolt(ctx, screenX, screenY);\n    } else {\n      this.renderRegularProjectile(ctx, screenX, screenY);\n    }\n\n    ctx.restore();\n  }\n\n  private renderSylphOrb(ctx: CanvasRenderingContext2D, screenX: number, screenY: number): void {\n    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;\n\n    ctx.shadowColor = \"#e91e63\";\n    ctx.shadowBlur = 15;\n    ctx.fillStyle = `rgba(233, 30, 99, ${pulse})`;\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, this.width / 2 + 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.shadowBlur = 0;\n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, this.width / 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (Math.random() < 0.5) {\n      ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8})`;\n      ctx.beginPath();\n      ctx.arc(\n        screenX + (Math.random() - 0.5) * 10,\n        screenY + (Math.random() - 0.5) * 10,\n        1,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n    }\n  }\n\n  private renderEmeraldBolt(ctx: CanvasRenderingContext2D, screenX: number, screenY: number): void {\n    ctx.shadowColor = \"#50c878\";\n    ctx.shadowBlur = 12;\n    ctx.fillStyle = \"#50c878\";\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.shadowBlur = 0;\n    ctx.fillStyle = \"#90ee90\";\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(screenX - 2, screenY - 2, 1, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private renderRegularProjectile(ctx: CanvasRenderingContext2D, screenX: number, screenY: number): void {\n    const size = 8;\n\n    ctx.fillStyle = \"#ffff00\";\n    ctx.fillRect(screenX - size / 2, screenY - size / 2, size, size);\n\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillRect(screenX - 2, screenY - 2, 4, 4);\n\n    ctx.strokeStyle = \"#ff0000\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(screenX - size / 2, screenY - size / 2, size, size);\n\n    ctx.shadowColor = \"#ffff00\";\n    ctx.shadowBlur = 6;\n    ctx.fillStyle = \"#ffff00\";\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, size / 2, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}","path":null,"size_bytes":4359,"size_tokens":null},"client/src/components/ui/form.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-[0.8rem] text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-[0.8rem] font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","path":null,"size_bytes":4132,"size_tokens":null},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\n      \"p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n      className\n    )}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","path":null,"size_bytes":2859,"size_tokens":null},"client/src/lib/game/managers/WaveManager.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { BossEnemy, BossType } from \"../entities/enemies/BossEnemy\";\nimport { FlyingEnemy } from \"../entities/enemies/FlyingEnemy\";\nimport { RangedEnemy } from \"../entities/enemies/RangedEnemy\";\nimport { TeleportingEnemy } from \"../entities/enemies/TeleportingEnemy\";\nimport { SplittingEnemy } from \"../entities/enemies/SplittingEnemy\";\nimport { ShieldedEnemy } from \"../entities/enemies/ShieldedEnemy\";\nimport { EnemyFactory, EnemyType } from \"../factories/EnemyFactory\";\nimport { IEnemy } from \"../core/interfaces/IEnemy\";\n\nexport class WaveManager {\n  private currentWave = 1;\n  private enemiesSpawned = 0;\n  private enemiesPerWave = 5;\n  private spawnTimer = 0;\n  private spawnInterval = 2;\n  private waveStartTime = 0;\n  private waveDuration = 30;\n  \n  private bossSpawnInterval = 5;\n  private bossSpawned = false;\n  private bossDefeated = false;\n  private bossWarningTriggered = false;\n  private bossWarningTime = 5;\n  private timeUntilBoss = 0;\n  \n  private onBossWarning: (() => void) | null = null;\n  private onBossSpawn: ((boss: BossEnemy) => void) | null = null;\n\n  public update(deltaTime: number) {\n    this.waveStartTime += deltaTime;\n    this.spawnTimer += deltaTime;\n    \n    if (this.isBossWave() && !this.bossSpawned) {\n      this.timeUntilBoss = Math.max(0, this.bossWarningTime - this.waveStartTime);\n      \n      if (this.waveStartTime >= (this.bossWarningTime - 5) && !this.bossWarningTriggered) {\n        this.bossWarningTriggered = true;\n        if (this.onBossWarning) {\n          this.onBossWarning();\n        }\n      }\n    }\n  }\n\n  public spawnEnemies(canvasWidth: number, canvasHeight: number, playerPos?: { x: number; y: number }): Enemy[] {\n    const enemies: Enemy[] = [];\n\n    if (this.isBossWave()) {\n      if (!this.bossSpawned && this.waveStartTime >= this.bossWarningTime) {\n        const boss = this.spawnBoss(canvasWidth, canvasHeight, playerPos);\n        enemies.push(boss);\n        this.bossSpawned = true;\n        \n        if (this.onBossSpawn) {\n          this.onBossSpawn(boss);\n        }\n      }\n      \n      if (this.bossSpawned && !this.bossDefeated) {\n        return enemies;\n      }\n      \n      if (this.bossDefeated) {\n        if (this.waveStartTime >= this.waveDuration) {\n          this.advanceWave();\n        }\n      }\n      \n      return enemies;\n    }\n\n    if (this.waveStartTime >= this.waveDuration) {\n      this.advanceWave();\n    }\n\n    if (this.spawnTimer >= this.spawnInterval && this.enemiesSpawned < this.getEnemiesForCurrentWave()) {\n      const enemy = this.createRandomEnemy(canvasWidth, canvasHeight, playerPos);\n      enemies.push(enemy as Enemy);\n      this.enemiesSpawned++;\n      this.spawnTimer = 0;\n    }\n\n    return enemies;\n  }\n\n  public spawnBoss(canvasWidth: number, canvasHeight: number, playerPos?: { x: number; y: number }): BossEnemy {\n    const bossTypes: BossType[] = [\"necromancer\", \"vampire_lord\", \"ancient_golem\"];\n    const bossIndex = Math.floor((this.currentWave / this.bossSpawnInterval) - 1) % bossTypes.length;\n    const bossType = bossTypes[bossIndex];\n    \n    let x: number, y: number;\n    const margin = 200;\n    \n    if (playerPos) {\n      const angle = Math.random() * Math.PI * 2;\n      const distance = 400 + Math.random() * 200;\n      x = playerPos.x + Math.cos(angle) * distance;\n      y = playerPos.y + Math.sin(angle) * distance;\n    } else {\n      const edge = Math.floor(Math.random() * 4);\n      switch (edge) {\n        case 0:\n          x = Math.random() * canvasWidth;\n          y = -margin;\n          break;\n        case 1:\n          x = canvasWidth + margin;\n          y = Math.random() * canvasHeight;\n          break;\n        case 2:\n          x = Math.random() * canvasWidth;\n          y = canvasHeight + margin;\n          break;\n        case 3:\n          x = -margin;\n          y = Math.random() * canvasHeight;\n          break;\n        default:\n          x = canvasWidth / 2;\n          y = -margin;\n      }\n    }\n    \n    console.log(`Boss spawned: ${bossType} at wave ${this.currentWave}`);\n    return new BossEnemy(x, y, bossType, this.currentWave);\n  }\n\n  public isBossWave(): boolean {\n    return this.currentWave % this.bossSpawnInterval === 0;\n  }\n\n  public onBossDefeated() {\n    this.bossDefeated = true;\n    console.log(`Boss defeated at wave ${this.currentWave}!`);\n  }\n\n  public isBossActive(): boolean {\n    return this.isBossWave() && this.bossSpawned && !this.bossDefeated;\n  }\n\n  public getTimeUntilBoss(): number {\n    if (!this.isBossWave() || this.bossSpawned) return 0;\n    return Math.max(0, this.bossWarningTime - this.waveStartTime);\n  }\n\n  public setOnBossWarning(callback: () => void) {\n    this.onBossWarning = callback;\n  }\n\n  public setOnBossSpawn(callback: (boss: BossEnemy) => void) {\n    this.onBossSpawn = callback;\n  }\n\n  private advanceWave() {\n    this.currentWave++;\n    this.enemiesSpawned = 0;\n    this.waveStartTime = 0;\n    this.spawnInterval = Math.max(0.5, this.spawnInterval * 0.95);\n    \n    this.bossSpawned = false;\n    this.bossDefeated = false;\n    this.bossWarningTriggered = false;\n    this.timeUntilBoss = 0;\n    \n    console.log(`Wave ${this.currentWave} started!`);\n  }\n\n  private getEnemiesForCurrentWave(): number {\n    return this.enemiesPerWave + Math.floor(this.currentWave / 2);\n  }\n\n  private getSpawnPosition(canvasWidth: number, canvasHeight: number, playerPos?: { x: number; y: number }): { x: number; y: number } {\n    const margin = 50;\n    \n    if (playerPos) {\n      const angle = Math.random() * Math.PI * 2;\n      const distance = 300 + Math.random() * 200;\n      return {\n        x: playerPos.x + Math.cos(angle) * distance,\n        y: playerPos.y + Math.sin(angle) * distance\n      };\n    } else {\n      const edge = Math.floor(Math.random() * 4);\n      switch (edge) {\n        case 0:\n          return { x: Math.random() * canvasWidth, y: -margin };\n        case 1:\n          return { x: canvasWidth + margin, y: Math.random() * canvasHeight };\n        case 2:\n          return { x: Math.random() * canvasWidth, y: canvasHeight + margin };\n        case 3:\n          return { x: -margin, y: Math.random() * canvasHeight };\n        default:\n          return { x: canvasWidth / 2, y: -margin };\n      }\n    }\n  }\n\n  private createRandomEnemy(canvasWidth: number, canvasHeight: number, playerPos?: { x: number; y: number }): IEnemy {\n    const pos = this.getSpawnPosition(canvasWidth, canvasHeight, playerPos);\n    return EnemyFactory.createRandomEnemy(pos.x, pos.y, this.currentWave);\n  }\n\n  public getCurrentWave(): number {\n    return this.currentWave;\n  }\n\n  public reset() {\n    this.currentWave = 1;\n    this.enemiesSpawned = 0;\n    this.spawnTimer = 0;\n    this.waveStartTime = 0;\n    this.spawnInterval = 2;\n    this.bossSpawned = false;\n    this.bossDefeated = false;\n    this.bossWarningTriggered = false;\n    this.timeUntilBoss = 0;\n  }\n}\n","path":null,"size_bytes":6884,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","path":null,"size_bytes":1012,"size_tokens":null},"client/src/lib/game/managers/CollectibleManager.ts":{"content":"\nimport { ICollectible } from \"../core/interfaces/ICollectible\";\nimport { ExperienceOrb } from \"../entities/collectibles/ExperienceOrb\";\nimport { PowerUp } from \"../entities/collectibles/PowerUp\";\n\nexport class CollectibleManager {\n  private collectibles: ICollectible[] = [];\n\n  public spawnExperienceOrb(x: number, y: number, value: number = 5): void {\n    this.collectibles.push(new ExperienceOrb(x, y, value));\n  }\n\n  public spawnPowerUp(x: number, y: number, type: string = \"health\"): void {\n    this.collectibles.push(new PowerUp(x, y, type));\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    // Remove expired collectibles\n    this.collectibles = this.collectibles.filter(c => !c.isExpired());\n\n    // Update remaining collectibles\n    this.collectibles.forEach(collectible => {\n      collectible.update(deltaTime, playerPos);\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    this.collectibles.forEach(collectible => {\n      collectible.render(ctx);\n    });\n  }\n\n  public checkCollections(playerPos: { x: number; y: number }): ICollectible[] {\n    const collected: ICollectible[] = [];\n    \n    this.collectibles = this.collectibles.filter(collectible => {\n      if (collectible.canBeCollected(playerPos)) {\n        collected.push(collectible);\n        return false;\n      }\n      return true;\n    });\n\n    return collected;\n  }\n\n  public getCollectibles(): ICollectible[] {\n    return [...this.collectibles];\n  }\n\n  public clear(): void {\n    this.collectibles = [];\n  }\n}\n","path":null,"size_bytes":1544,"size_tokens":null},"client/src/lib/game/entities/Player.ts":{"content":"import { Projectile } from \"./Projectile\";\nimport { OrbitalWeapon } from \"../weapons/OrbitalWeapon\";\nimport { BaseWeapon } from \"./WeaponTypes\";\nimport { SylphBloomsWeapon } from \"../weapons/SylphBloomsWeapon\";\nimport { useGameState } from \"../../stores/useGameState\";\nimport { SpriteManager } from \"../rendering/SpriteManager\";\nimport { AnimationManager } from \"../rendering/AnimationManager\";\n\nexport interface GameObject {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport class Player implements GameObject {\n  public x: number;\n  public y: number;\n  public width = 96;\n  public height = 96;\n  public collisionWidth = 60; // Larger collision box for better collision detection\n  public collisionHeight = 70; // Taller collision box for better vertical collision\n  public speed = 200;\n  public health = 100;\n  public maxHealth = 100;\n  private lastDamageTime = 0;\n  private orbitalWeapons: OrbitalWeapon[] = [];\n  private orbitalPositions: { x: number; y: number }[] = [];\n  private lastMoveDirection = { x: 1, y: 0 }; // Default to right\n  private isMoving = false;\n  protected instanceId: string;\n  protected animationManager: AnimationManager;\n  protected currentAnimation = \"idle\";\n  protected lastAnimationFrame: any = null;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.weapon = new SylphBloomsWeapon();\n    this.instanceId = `player_${Date.now()}_${Math.random()}`;\n    this.animationManager = new AnimationManager();\n    this.setupAnimations();\n  }\n\n  private updateAnimationSpeed(animationName: string, frameDuration: number) {\n    // Get the current animation frames\n    const currentFrames = this.getCurrentAnimationFrames(animationName);\n    if (currentFrames) {\n      this.animationManager.addAnimation(animationName, currentFrames, frameDuration, true);\n    }\n  }\n\n  private getCurrentAnimationFrames(animationName: string) {\n    switch (animationName) {\n      case \"walk\":\n        return [\n          { x: 0, y: 0, width: 450, height: 450 },\n          { x: 450, y: 0, width: 450, height: 450 },\n          { x: 900, y: 0, width: 450, height: 450 },\n          { x: 1350, y: 0, width: 450, height: 450 },\n        ];\n      case \"walk_diagonal\":\n        const frameWidth = 24000 / 30;\n        const walkDiagonalFrames = [];\n        for (let i = 0; i < 30; i++) {\n          walkDiagonalFrames.push({\n            x: i * frameWidth,\n            y: 0,\n            width: frameWidth,\n            height: 450,\n          });\n        }\n        return walkDiagonalFrames;\n      case \"walk_forward\":\n        const walkForwardFrames = [];\n        const forwardFrameWidth = 800;\n        for (let i = 0; i < 30; i++) {\n          walkForwardFrames.push({\n            x: i * forwardFrameWidth,\n            y: 0,\n            width: forwardFrameWidth,\n            height: 450,\n          });\n        }\n        return walkForwardFrames;\n      case \"walk_sideways\":\n        const walkSidewaysFrames = [];\n        const sidewaysFrameWidth = 800;\n        for (let i = 0; i < 30; i++) {\n          walkSidewaysFrames.push({\n            x: i * sidewaysFrameWidth,\n            y: 0,\n            width: sidewaysFrameWidth,\n            height: 450,\n          });\n        }\n        return walkSidewaysFrames;\n      case \"walk_down\":\n        const walkDownFrames = [];\n        const downFrameWidth = 800;\n        for (let i = 0; i < 30; i++) {\n          walkDownFrames.push({\n            x: i * downFrameWidth,\n            y: 0,\n            width: downFrameWidth,\n            height: 450,\n          });\n        }\n        return walkDownFrames;\n      case \"walk_diagonal_down\":\n        const walkDiagonalDownFrames = [];\n        const diagonalDownFrameWidth = 800;\n        for (let i = 0; i < 30; i++) {\n          walkDiagonalDownFrames.push({\n            x: i * diagonalDownFrameWidth,\n            y: 0,\n            width: diagonalDownFrameWidth,\n            height: 450,\n          });\n        }\n        return walkDiagonalDownFrames;\n      case \"walk_up\":\n        const walkUpFrames = [];\n        const upFrameWidth = 800;\n        for (let i = 0; i < 30; i++) {\n          walkUpFrames.push({\n            x: i * upFrameWidth,\n            y: 0,\n            width: upFrameWidth,\n            height: 450,\n          });\n        }\n        return walkUpFrames;\n      default:\n        return null;\n    }\n  }\n\n  private setupAnimations() {\n    // Regular walking animation (4 frames, each 450x450 in a 1800x450 spritesheet)\n    const walkFrames = [\n      { x: 0, y: 0, width: 450, height: 450 },\n      { x: 450, y: 0, width: 450, height: 450 },\n      { x: 900, y: 0, width: 450, height: 450 },\n      { x: 1350, y: 0, width: 450, height: 450 },\n    ];\n\n    // Diagonal walking animation (36 frames, each ~667x450 in a 24000x450 spritesheet)\n    const frameWidth = 24000 / 30; // 666.67 pixels per frame\n    const walkDiagonalFrames = [];\n    for (let i = 0; i < 30; i++) {\n      walkDiagonalFrames.push({\n        x: i * frameWidth,\n        y: 0,\n        width: frameWidth,\n        height: 450,\n      });\n    }\n\n    // Forward walking animation (30 frames, each 800x450 in a 24000x450 spritesheet)\n    const walkForwardFrames = [];\n    const forwardFrameWidth = 800; // Each frame is 800px wide (24000 / 30 = 800)\n    const forwardFrameCount = 30; // 30 frames total\n    for (let i = 0; i < forwardFrameCount; i++) {\n      walkForwardFrames.push({\n        x: i * forwardFrameWidth,\n        y: 0,\n        width: forwardFrameWidth,\n        height: 450,\n      });\n    }\n\n    // Sideways walking animation - assuming similar structure to forward (will need need adjustment based on actual sprite dimensions)\n    const walkSidewaysFrames = [];\n    const sidewaysFrameWidth = 800; // Adjust based on your sideways sprite sheet dimensions\n    const sidewaysFrameCount = 30; // Adjust based on your sideways sprite sheet frame count\n    for (let i = 0; i < sidewaysFrameCount; i++) {\n      walkSidewaysFrames.push({\n        x: i * sidewaysFrameWidth,\n        y: 0,\n        width: sidewaysFrameWidth,\n        height: 450, // Adjust based on your sideways sprite sheet height\n      });\n    }\n\n    // Downward walking animation - assuming similar structure to forward\n    const walkDownFrames = [];\n    const downFrameWidth = 800; // Adjust based on your down sprite sheet dimensions\n    const downFrameCount = 30; // Adjust based on your down sprite sheet frame count\n    for (let i = 0; i < downFrameCount; i++) {\n      walkDownFrames.push({\n        x: i * downFrameWidth,\n        y: 0,\n        width: downFrameWidth,\n        height: 450, // Adjust based on your down sprite sheet height\n      });\n    }\n\n    // Diagonal down walking animation - similar structure to diagonal up\n    const walkDiagonalDownFrames = [];\n    const diagonalDownFrameWidth = 800; // Adjust based on your diagonal down sprite sheet dimensions\n    const diagonalDownFrameCount = 30; // Adjust based on your diagonal down sprite sheet frame count\n    for (let i = 0; i < diagonalDownFrameCount; i++) {\n      walkDiagonalDownFrames.push({\n        x: i * diagonalDownFrameWidth,\n        y: 0,\n        width: diagonalDownFrameWidth,\n        height: 450, // Adjust based on your diagonal down sprite sheet height\n      });\n    }\n\n    // Upward walking animation\n    const walkUpFrames = [];\n    const upFrameWidth = 800;\n    const upFrameCount = 30;\n    for (let i = 0; i < upFrameCount; i++) {\n      walkUpFrames.push({\n        x: i * upFrameWidth,\n        y: 0,\n        width: upFrameWidth,\n        height: 450,\n      });\n    }\n\n    this.animationManager.addAnimation(\"walk\", walkFrames, 0.1, true);\n    this.animationManager.addAnimation(\n      \"walk_diagonal\",\n      walkDiagonalFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\n      \"walk_forward\",\n      walkForwardFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\n      \"walk_sideways\",\n      walkSidewaysFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\n      \"walk_down\",\n      walkDownFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\n      \"walk_diagonal_down\",\n      walkDiagonalDownFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\n      \"walk_up\",\n      walkUpFrames,\n      0.05,\n      true,\n    );\n    this.animationManager.addAnimation(\"idle\", [walkDownFrames[0]], 1, true);\n\n    // Store the first frame of walking down as initial last frame\n    this.lastAnimationFrame = walkDownFrames[0];\n  }\n\n  public getWeapon() {\n    return this.weapon;\n  }\n\n  public update(\n    deltaTime: number,\n    input: any,\n    canvasWidth: number,\n    canvasHeight: number,\n    tileRenderer?: any\n  ) {\n    // Handle movement\n    let moveX = 0;\n    let moveY = 0;\n\n    if (input.left) moveX -= 1;\n    if (input.right) moveX += 1;\n    if (input.up) moveY -= 1;\n    if (input.down) moveY += 1;\n\n    // Normalize diagonal movement\n    if (moveX !== 0 && moveY !== 0) {\n      moveX *= 0.707; // 1/sqrt(2)\n      moveY *= 0.707;\n    }\n\n    // Update last move direction if player is moving\n    const wasMoving = this.isMoving;\n    if (moveX !== 0 || moveY !== 0) {\n      this.lastMoveDirection = { x: moveX, y: moveY };\n      this.isMoving = true;\n    } else {\n      this.isMoving = false;\n    }\n\n    // Determine which animation to use based on movement\n    let targetAnimation = \"idle\";\n    if (this.isMoving) {\n      // Check if moving diagonally up (either direction)\n      if (moveY < 0 && Math.abs(moveX) > 0) {\n        targetAnimation = \"walk_diagonal\";\n      } else if (moveY > 0 && Math.abs(moveX) > 0) {\n        // Moving diagonally down - use diagonal down animation\n        targetAnimation = \"walk_diagonal_down\";\n      } else if (moveY > 0) {\n        // Moving straight down - use down animation\n        targetAnimation = \"walk_down\";\n      } else if (moveY < 0 && Math.abs(moveX) === 0) {\n        // Moving straight up - use up animation\n        targetAnimation = \"walk_up\";\n      } else if (Math.abs(moveX) > 0 && moveY === 0) {\n        // Pure horizontal movement - use sideways animation\n        targetAnimation = \"walk_sideways\";\n      } else {\n        // For other movements, use regular walk animation\n        targetAnimation = \"walk\";\n      }\n    }\n\n    // Use fixed frame duration for consistent animation timing\n    const baseFrameDuration = 0.1; // Slower, more visible animation timing\n\n    // Only log when animation changes, not every frame\n    // Debug logging removed to reduce console spam\n\n    // Switch animation if needed or update frame rate\n    if (this.currentAnimation !== targetAnimation) {\n      console.log(`Switching animation from ${this.currentAnimation} to ${targetAnimation}`);\n\n      // If switching to idle, update idle animation with last frame\n      if (targetAnimation === \"idle\" && this.lastAnimationFrame) {\n        this.animationManager.addAnimation(\"idle\", [this.lastAnimationFrame], 1, true);\n      }\n\n      this.currentAnimation = targetAnimation;\n      this.animationManager.startAnimation(targetAnimation, this.instanceId);\n    }\n\n    // Don't update animation speed dynamically to avoid interference\n\n    // Calculate new position\n    const newX = this.x + moveX * this.speed * deltaTime;\n    const newY = this.y + moveY * this.speed * deltaTime;\n\n    // Check tile collisions if tileRenderer is available\n    if (tileRenderer && tileRenderer.isSolidAt) {\n      // Check horizontal movement\n      if (!this.checkTileCollision(newX, this.y, tileRenderer)) {\n        this.x = newX;\n      }\n      // Check vertical movement\n      if (!this.checkTileCollision(this.x, newY, tileRenderer)) {\n        this.y = newY;\n      }\n    } else {\n      // Fallback: no tile collision, just update position\n      this.x = newX;\n      this.y = newY;\n    }\n  }\n\n  public fireWeapon(deltaTime: number): Projectile[] {\n    // Always use the last movement direction, even when idle\n    const fireDirection = this.lastMoveDirection;\n\n    const projectiles = this.weapon.fire(\n      deltaTime,\n      this.x,\n      this.y,\n      fireDirection,\n    );\n\n    // Debug logging when projectiles are created\n    if (projectiles.length > 0) {\n      console.log(`Fired ${projectiles.length} projectiles from ${this.weapon.constructor.name} in direction:`, fireDirection);\n      console.log(`First projectile velocity: vx=${projectiles[0].vx}, vy=${projectiles[0].vy}`);\n    }\n\n    // Update orbital weapons and store their positions (no projectiles anymore)\n    this.orbitalPositions = [];\n    this.orbitalWeapons.forEach((orbital) => {\n      const result = orbital.update(deltaTime, this.x, this.y);\n      this.orbitalPositions.push({ x: result.x, y: result.y });\n    });\n\n    return projectiles;\n  }\n\n  public getOrbitalWeapons(): OrbitalWeapon[] {\n    return this.orbitalWeapons;\n  }\n\n  public getPosition() {\n    return { x: this.x, y: this.y };\n  }\n\n  public addOrbitalWeapon() {\n    this.orbitalWeapons.push(new OrbitalWeapon());\n  }\n\n  public upgradeHealth() {\n    const gameState = useGameState.getState();\n    gameState.upgradeHealth();\n  }\n\n  public setWeapon(weapon: BaseWeapon) {\n    this.weapon = weapon;\n  }\n\n  public renderFlowers(ctx: CanvasRenderingContext2D) {\n    if (this.weapon instanceof SylphBloomsWeapon) {\n      this.weapon.renderFlowers(ctx);\n    }\n  }\n\n  public setTileRenderer(tileRenderer: any): void {\n    // Base Player class doesn't need tile renderer integration\n    // This method exists for compatibility with GameEngine\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    this.lastDamageTime = Date.now();\n  }\n\n  public heal(amount: number): void {\n    this.health = Math.min(this.maxHealth, this.health + amount);\n  }\n\n  private checkTileCollision(x: number, y: number, tileRenderer: any): boolean {\n    // Check collision points around the player\n    const margin = 2; // Small margin to prevent getting stuck\n    const points = [\n      { x: x + margin, y: y + margin }, // Top-left\n      { x: x + this.width - margin, y: y + margin }, // Top-right\n      { x: x + margin, y: y + this.height - margin }, // Bottom-left\n      { x: x + this.width - margin, y: y + this.height - margin } // Bottom-right\n    ];\n\n    return points.some(point => tileRenderer.isSolidAt(point.x, point.y));\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number) {\n    const spriteManager = SpriteManager.getInstance();\n    const playerSprite = spriteManager.getSprite(\"player\");\n    const playerDiagonalSprite = spriteManager.getSprite(\"player_diagonal\");\n    const playerForwardSprite = spriteManager.getSprite(\"player_forward\");\n    const playerSidewaysSprite = spriteManager.getSprite(\"player_sideways\");\n    const playerDownSprite = spriteManager.getSprite(\"player_down\");\n    const playerDiagonalDownSprite = spriteManager.getSprite(\"player_diagonal_down\");\n    const playerUpSprite = spriteManager.getSprite(\"player_up\");\n\n    // Debug logging\n    if (!playerSprite) {\n      console.warn(\"Player sprite not found - showing fallback square\");\n    }\n    if (this.currentAnimation === \"walk_diagonal\" && !playerDiagonalSprite) {\n      console.warn(\"Player diagonal sprite not found - using regular sprite\");\n    }\n    if (this.currentAnimation === \"walk_forward\" && !playerForwardSprite) {\n      console.warn(\"Player forward sprite not found - using regular sprite\");\n    }\n    if (this.currentAnimation === \"walk_sideways\" && !playerSidewaysSprite) {\n      console.warn(\"Player sideways sprite not found - using regular sprite\");\n    }\n    if (this.currentAnimation === \"walk_down\" && !playerDownSprite) {\n      console.warn(\"Player down sprite not found - using regular sprite\");\n    }\n    if (this.currentAnimation === \"walk_diagonal_down\" && !playerDiagonalDownSprite) {\n      console.warn(\"Player diagonal down sprite not found - using regular sprite\");\n    }\n    if (this.currentAnimation === \"walk_up\" && !playerUpSprite) {\n      console.warn(\"Player up sprite not found - using regular sprite\");\n    }\n\n    if (playerSprite) {\n      // Update and get current animation frame\n      // Ensure deltaTime is a valid number\n      const validDeltaTime = typeof deltaTime === 'number' && !isNaN(deltaTime) ? deltaTime : 0.016;\n      const currentFrame = this.animationManager.update(\n        validDeltaTime,\n        this.instanceId,\n        this.currentAnimation,\n      );\n\n      // Store the current frame as last animation frame for idle use\n      if (currentFrame && this.currentAnimation !== \"idle\") {\n        this.lastAnimationFrame = currentFrame;\n      }\n\n      // Draw animated sprite using current frame, with fallback\n      ctx.save();\n\n      // Calculate proper draw dimensions based on animation to preserve aspect ratio\n      let drawWidth = this.width;\n      let drawHeight = this.height;\n\n      // For forward, diagonal, sideways, down, up, diagonal down, and idle animations (800x450), maintain proper aspect ratio\n      if (this.currentAnimation === \"walk_forward\" || this.currentAnimation === \"walk_diagonal\" || this.currentAnimation === \"walk_sideways\" || this.currentAnimation === \"walk_down\" || this.currentAnimation === \"walk_up\" || this.currentAnimation === \"walk_diagonal_down\" || this.currentAnimation === \"idle\") {\n        const aspectRatio = 800 / 450; // ~1.78\n        drawWidth = this.height * aspectRatio; // Keep height, adjust width\n      }\n\n      // Calculate draw position\n      const drawX = this.x - drawWidth / 2;\n      const drawY = this.y - drawHeight / 2;\n\n      // Handle sprite flipping based on movement direction\n      // For diagonal animations: sprite shows up-left by default, flip for up-right\n      // For diagonal down animations: sprite shows down-right by default, flip for down-left\n      // For sideways animations: flip when moving left (sprite faces right by default)\n      // For other movements: sprite faces left by default, flip for right movement\n      const shouldFlip =\n        (this.currentAnimation === \"walk_diagonal\" &&\n          this.lastMoveDirection.x > 0) ||\n        (this.currentAnimation === \"walk_diagonal_down\" &&\n          this.lastMoveDirection.x < 0) ||\n        (this.currentAnimation === \"walk_sideways\" &&\n          this.lastMoveDirection.x < 0) ||\n        (this.currentAnimation !== \"walk_diagonal\" && this.currentAnimation !== \"walk_sideways\" && this.currentAnimation !== \"walk_down\" && this.currentAnimation !== \"walk_up\" && this.currentAnimation !== \"walk_diagonal_down\" &&\n          this.lastMoveDirection.x > 0);\n\n      if (shouldFlip) {\n        ctx.translate(this.x, this.y);\n        ctx.scale(-1, 1);\n        ctx.translate(-this.x, -this.y);\n      }\n\n      // Use appropriate spritesheet based on animation\n      let spriteToUse = playerSprite;\n      if (this.currentAnimation === \"walk_diagonal\" && playerDiagonalSprite) {\n        spriteToUse = playerDiagonalSprite;\n      } else if (this.currentAnimation === \"walk_diagonal_down\" && playerDiagonalDownSprite) {\n        spriteToUse = playerDiagonalDownSprite;\n      } else if (\n        this.currentAnimation === \"walk_forward\" &&\n        playerForwardSprite\n      ) {\n        spriteToUse = playerForwardSprite;\n      } else if (\n        this.currentAnimation === \"walk_sideways\" &&\n        playerSidewaysSprite\n      ) {\n        spriteToUse = playerSidewaysSprite;\n      } else if (\n        this.currentAnimation === \"walk_down\" &&\n        playerDownSprite\n      ) {\n        spriteToUse = playerDownSprite;\n      } else if (\n        this.currentAnimation === \"walk_up\" &&\n        playerUpSprite\n      ) {\n        spriteToUse = playerUpSprite;\n      }\n\n      if (currentFrame) {\n        // Use animation frame\n        ctx.drawImage(\n          spriteToUse,\n          currentFrame.x,\n          currentFrame.y,\n          currentFrame.width,\n          currentFrame.height,\n          drawX,\n          drawY,\n          drawWidth,\n          drawHeight,\n        );\n      } else {\n        // Fallback - use first frame manually\n        ctx.drawImage(\n          spriteToUse,\n          0,\n          0,\n          450,\n          450, // First frame coordinates (450x450)\n          drawX,\n          drawY,\n          drawWidth,\n          drawHeight,\n        );\n      }\n\n      ctx.restore();\n    } else {\n      // Fallback to colored square (this should not show if sprite loads)\n      ctx.fillStyle = \"#4444ff\";\n      ctx.fillRect(\n        this.x - this.width / 2,\n        this.y - this.height / 2,\n        this.width,\n        this.height,\n      );\n    }\n\n    // Render orbital weapons\n    this.orbitalWeapons.forEach((orbital) => {\n      orbital.render(ctx);\n    });\n  }\n}","path":null,"size_bytes":20561,"size_tokens":null},"client/src/lib/game/rendering/EndlessCaveRenderer.ts":{"content":"import { SpriteManager } from \"./SpriteManager\";\n\nexport interface Camera {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport class EndlessCaveRenderer {\n  private tileSize = 16;\n  private spriteManager: SpriteManager;\n  private spriteLoaded = false;\n  private srcTileSize = 16; // Source tile size in the Ground_rocks.png (16x16)\n  private srcTileHeight = 16; // Source tile height\n\n  // Tile connection types for seamless blending (16x16 grid)\n  private static readonly TILE_VARIANTS = {\n    CENTER: { x: 0, y: 0 }, // Center tile (default)\n    EDGE_TOP: { x: 16, y: 0 }, // Top edge\n    EDGE_RIGHT: { x: 32, y: 0 }, // Right edge\n    EDGE_BOTTOM: { x: 48, y: 0 }, // Bottom edge\n    EDGE_LEFT: { x: 64, y: 0 }, // Left edge\n    CORNER_TL: { x: 0, y: 16 }, // Top-left corner\n    CORNER_TR: { x: 16, y: 16 }, // Top-right corner\n    CORNER_BR: { x: 32, y: 16 }, // Bottom-right corner\n    CORNER_BL: { x: 48, y: 16 }, // Bottom-left corner\n  };\n\n  constructor() {\n    this.spriteManager = SpriteManager.getInstance();\n    this.loadGroundSprite();\n  }\n\n  private async loadGroundSprite(): Promise<void> {\n    try {\n      await this.spriteManager.loadSprite(\n        \"ground_rocks\",\n        \"/assets/tilesets/PNG/Ground_rocks.png\",\n      );\n      this.spriteLoaded = true;\n      console.log(\"Ground rocks tileset loaded successfully\");\n    } catch (error) {\n      console.warn(\"Failed to load ground rocks tileset:\", error);\n      this.spriteLoaded = false;\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, camera: Camera): void {\n    // Calculate visible tile range\n    const startTileX = Math.floor(camera.x / this.tileSize);\n    const endTileX = Math.ceil((camera.x + camera.width) / this.tileSize);\n    const startTileY = Math.floor(camera.y / this.tileSize);\n    const endTileY = Math.ceil((camera.y + camera.height) / this.tileSize);\n\n    if (!this.spriteLoaded) {\n      this.renderFallback(\n        ctx,\n        startTileX,\n        endTileX,\n        startTileY,\n        endTileY,\n        camera,\n      );\n      return;\n    }\n\n    const groundSprite = this.spriteManager.getSprite(\"ground_rocks\");\n    if (!groundSprite) {\n      this.renderFallback(\n        ctx,\n        startTileX,\n        endTileX,\n        startTileY,\n        endTileY,\n        camera,\n      );\n      return;\n    }\n\n    // Enable high quality rendering\n    ctx.imageSmoothingEnabled = false; // Disable smoothing for pixel-perfect tiles\n    ctx.imageSmoothingQuality = \"low\";\n\n    for (let tileY = startTileY; tileY <= endTileY; tileY++) {\n      for (let tileX = startTileX; tileX <= endTileX; tileX++) {\n        const screenX = tileX * this.tileSize - camera.x;\n        const screenY = tileY * this.tileSize - camera.y;\n\n        // Use a seamless textured ground tile from the tileset\n        ctx.drawImage(\n          groundSprite,\n          160, 80, this.srcTileSize, this.srcTileHeight, // Source: textured ground tile\n          screenX, screenY, this.tileSize, this.tileSize // Destination\n        );\n      }\n    }\n  }\n\n  private renderFallback(\n    ctx: CanvasRenderingContext2D,\n    startTileX: number,\n    endTileX: number,\n    startTileY: number,\n    endTileY: number,\n    camera: { x: number; y: number },\n  ): void {\n    // Fallback to grey colors if sprite fails to load\n    const greyColor = \"#666666\";\n    const darkGreyColor = \"#555555\";\n\n    for (let tileY = startTileY; tileY <= endTileY; tileY++) {\n      for (let tileX = startTileX; tileX <= endTileX; tileX++) {\n        const screenX = tileX * this.tileSize - camera.x;\n        const screenY = tileY * this.tileSize - camera.y;\n\n        const isAlternate = (tileX + tileY) % 2 === 0;\n        ctx.fillStyle = isAlternate ? greyColor : darkGreyColor;\n        ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\n      }\n    }\n  }\n\n  private getTileVariant(\n    tileX: number,\n    tileY: number,\n  ): { x: number; y: number } {\n    // Create a pattern for tile edges and corners\n    // This creates natural-looking variation by using different tile types\n    // based on position to simulate edge detection\n\n    const noise = (tileX * 7 + tileY * 11) % 16;\n\n    // Create edge patterns every few tiles for natural variation\n    const isEdgeX = tileX % 8 === 0 || tileX % 8 === 7;\n    const isEdgeY = tileY % 8 === 0 || tileY % 8 === 7;\n    const isCorner = isEdgeX && isEdgeY;\n\n    if (isCorner) {\n      // Use corner variants for corners\n      if (tileX % 8 === 0 && tileY % 8 === 0)\n        return EndlessCaveRenderer.TILE_VARIANTS.CORNER_TL;\n      if (tileX % 8 === 7 && tileY % 8 === 0)\n        return EndlessCaveRenderer.TILE_VARIANTS.CORNER_TR;\n      if (tileX % 8 === 7 && tileY % 8 === 7)\n        return EndlessCaveRenderer.TILE_VARIANTS.CORNER_BR;\n      if (tileX % 8 === 0 && tileY % 8 === 7)\n        return EndlessCaveRenderer.TILE_VARIANTS.CORNER_BL;\n    } else if (isEdgeX) {\n      // Use left/right edge variants\n      return tileX % 8 === 0\n        ? EndlessCaveRenderer.TILE_VARIANTS.EDGE_LEFT\n        : EndlessCaveRenderer.TILE_VARIANTS.EDGE_RIGHT;\n    } else if (isEdgeY) {\n      // Use top/bottom edge variants\n      return tileY % 8 === 0\n        ? EndlessCaveRenderer.TILE_VARIANTS.EDGE_TOP\n        : EndlessCaveRenderer.TILE_VARIANTS.EDGE_BOTTOM;\n    }\n\n    // For most tiles, use center variant with occasional variation\n    return noise < 2\n      ? EndlessCaveRenderer.TILE_VARIANTS.EDGE_TOP\n      : EndlessCaveRenderer.TILE_VARIANTS.CENTER;\n  }\n\n  public getTileSize(): number {\n    return this.tileSize;\n  }\n\n  public cleanupChunks(camera: Camera): void {\n    // No chunks to cleanup for simple renderer\n  }\n}","path":null,"size_bytes":5615,"size_tokens":null},"client/src/lib/stores/useGameState.tsx":{"content":"import { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { useAudio } from \"./useAudio\";\n\nexport type GamePhase = \"ready\" | \"playing\" | \"ended\" | \"levelUp\" | \"characterSelect\" | \"paused\" | \"gameOver\";\n\nexport type CharacterType = {\n  id?: string;\n  name: string;\n  stats: {\n    health: number;\n  }\n}\n\ninterface GameState {\n  phase: GamePhase;\n  score: number;\n  health: number;\n  maxHealth: number;\n  wave: number;\n  experience: number;\n  experienceToNext: number;\n  level: number;\n  selectedCharacter: CharacterType | null;\n  spiderMode: \"normal\" | \"big\" | \"small\";\n\n  isBossActive: boolean;\n  currentBossHealth: number;\n  currentBossMaxHealth: number;\n  bossName: string;\n  bossDescription: string;\n  currency: number;\n  totalKills: number;\n  bossesDefeated: number;\n  showBossWarning: boolean;\n  isPaused: boolean;\n  comboCount: number;\n  comboMultiplier: number;\n  maxCombo: number;\n  comboTimeRemaining: number;\n\n  start: () => void;\n  restart: () => void;\n  end: () => void;\n  showLevelUp: () => void;\n  hideLevelUp: () => void;\n  showCharacterSelect: () => void;\n  selectCharacter: (character: CharacterType) => void;\n  addScore: (points: number) => void;\n  takeDamage: (damage: number) => void;\n  upgradeHealth: () => void;\n  nextWave: () => void;\n  addExperience: (exp: number) => void;\n  levelUp: () => void;\n  resumeFromLevelUp: () => void;\n  setScore: (score: number) => void;\n  setHealth: (health: number) => void;\n  setWave: (wave: number) => void;\n  setSpiderMode: (mode: \"normal\" | \"big\" | \"small\") => void;\n  pause: () => void;\n  resume: () => void;\n\n  setBossActive: (active: boolean) => void;\n  updateBossHealth: (health: number, maxHealth: number) => void;\n  setBossInfo: (name: string, description: string) => void;\n  triggerBossWarning: (name: string, description: string) => void;\n  hideBossWarning: () => void;\n  onBossDefeated: () => void;\n  addCurrency: (amount: number) => void;\n  spendCurrency: (amount: number) => void;\n  addKill: () => void;\n  addBossKill: () => void;\n  updateCombo: (combo: number, multiplier: number) => void;\n  resetCombo: () => void;\n}\n\nexport const useGameState = create<GameState>()(\n  subscribeWithSelector((set, get) => ({\n    phase: \"ready\",\n    score: 0,\n    health: 100,\n    maxHealth: 100,\n    wave: 1,\n    experience: 0,\n    experienceToNext: 100,\n    level: 1,\n    selectedCharacter: null,\n    spiderMode: \"normal\",\n\n    isBossActive: false,\n    currentBossHealth: 0,\n    currentBossMaxHealth: 0,\n    bossName: \"\",\n    bossDescription: \"\",\n    currency: 0,\n    totalKills: 0,\n    bossesDefeated: 0,\n    showBossWarning: false,\n    isPaused: false,\n    comboCount: 0,\n    comboMultiplier: 1,\n    maxCombo: 0,\n    comboTimeRemaining: 0,\n\n    start: () => {\n      set((state) => {\n        if (state.phase === \"ready\") {\n          return { phase: \"characterSelect\" };\n        }\n        return {};\n      });\n    },\n\n    restart: () => {\n      set(() => ({\n        phase: \"characterSelect\",\n        score: 0,\n        health: 100,\n        maxHealth: 100,\n        wave: 1,\n        level: 1,\n        experience: 0,\n        experienceToNext: 100,\n        selectedCharacter: null,\n        spiderMode: \"normal\",\n        isBossActive: false,\n        currentBossHealth: 0,\n        currentBossMaxHealth: 0,\n        bossName: \"\",\n        bossDescription: \"\",\n        currency: 0,\n        totalKills: 0,\n        bossesDefeated: 0,\n        showBossWarning: false,\n        isPaused: false\n      }));\n    },\n\n    end: () => {\n      set((state) => {\n        if (state.phase === \"playing\") {\n          return { phase: \"ended\" };\n        }\n        return {};\n      });\n    },\n\n    showLevelUp: () => {\n      set(() => ({ phase: \"levelUp\" }));\n    },\n\n    hideLevelUp: () => {\n      set(() => ({ phase: \"playing\" }));\n    },\n\n    showCharacterSelect: () => {\n      set(() => ({ phase: \"characterSelect\" }));\n    },\n\n    selectCharacter: (character: CharacterType) => {\n      set({ selectedCharacter: character, phase: \"playing\" });\n    },\n\n    setScore: (score) => set({ score }),\n    setHealth: (health) => set({ health }),\n    setWave: (wave) => set({ wave }),\n\n    takeDamage: (amount) => {\n      set((state) => {\n        const newHealth = Math.max(0, state.health - amount);\n\n        // Play player hurt sound\n        const audioState = useAudio.getState();\n        if (!audioState.isMuted && newHealth > 0) {\n          audioState.playPlayerHurt();\n        }\n\n        if (newHealth <= 0) {\n          return { health: 0, phase: \"gameOver\" as const };\n        }\n        return { health: newHealth };\n      });\n    },\n\n    addScore: (points: number) => {\n      const { score, experience } = get();\n      const newScore = score + points;\n      const newExp = experience + points;\n      set({ score: newScore, experience: newExp });\n\n      const { experienceToNext } = get();\n      if (newExp >= experienceToNext) {\n        get().levelUp();\n      }\n    },\n\n    addExperience: (amount) => {\n      set((state) => {\n        const newExperience = state.experience + amount;\n        if (newExperience >= state.experienceToNext) {\n          const overflow = newExperience - state.experienceToNext;\n          const newLevel = state.level + 1;\n          const newExpToNext = Math.floor(state.experienceToNext * 1.5);\n\n          // Play level up sound and trigger celebration\n          const audioState = useAudio.getState();\n          if (!audioState.isMuted) {\n            audioState.playLevelUp();\n          }\n\n          // Trigger level-up celebration effect\n          if (typeof window !== 'undefined') {\n            const event = new CustomEvent('levelUp', { detail: { level: newLevel } });\n            window.dispatchEvent(event);\n          }\n\n          return {\n            experience: overflow,\n            level: newLevel,\n            experienceToNext: newExpToNext,\n            phase: \"levelUp\" as const\n          };\n        }\n        return { experience: newExperience };\n      });\n    },\n\n    levelUp: () => {\n      const { level, experienceToNext } = get();\n      const newLevel = level + 1;\n      const newExpToNext = Math.floor(experienceToNext * 1.5);\n\n      set({ \n        phase: \"levelUp\",\n        level: newLevel,\n        experienceToNext: newExpToNext,\n        experience: 0\n      });\n    },\n\n    resumeFromLevelUp: () => {\n      set({ phase: \"playing\" });\n    },\n\n    upgradeHealth: () => {\n      const { health, maxHealth } = get();\n      const newMaxHealth = maxHealth + 25;\n      const newHealth = Math.min(health + 50, newMaxHealth);\n      set({ health: newHealth, maxHealth: newMaxHealth });\n    },\n\n    setSpiderMode: (mode: \"normal\" | \"big\" | \"small\") => {\n      set({ spiderMode: mode });\n    },\n\n    nextWave: () => {\n      const { wave } = get();\n      set({ wave: wave + 1 });\n    },\n\n    pause: () => {\n      set((state) => {\n        if (state.phase === \"playing\") {\n          return { isPaused: true, phase: \"paused\" as const };\n        }\n        return state;\n      });\n    },\n\n    resume: () => {\n      set((state) => {\n        if (state.phase === \"paused\") {\n          return { isPaused: false, phase: \"playing\" as const };\n        }\n        return state;\n      });\n    },\n\n    setBossActive: (active: boolean) => {\n      set({ isBossActive: active });\n      if (!active) {\n        set({ \n          currentBossHealth: 0, \n          currentBossMaxHealth: 0,\n          bossName: \"\",\n          bossDescription: \"\"\n        });\n      }\n    },\n\n    updateBossHealth: (health: number, maxHealth: number) => {\n      set({ \n        currentBossHealth: health, \n        currentBossMaxHealth: maxHealth \n      });\n    },\n\n    setBossInfo: (name: string, description: string) => {\n      set({ \n        bossName: name,\n        bossDescription: description\n      });\n    },\n\n    triggerBossWarning: (name: string, description: string) => {\n      set({ \n        showBossWarning: true,\n        bossName: name,\n        bossDescription: description\n      });\n    },\n\n    hideBossWarning: () => {\n      set({ showBossWarning: false });\n    },\n\n    onBossDefeated: () => {\n      const { score } = get();\n      const bonusScore = 1000;\n      set({ \n        isBossActive: false,\n        currentBossHealth: 0,\n        currentBossMaxHealth: 0,\n        score: score + bonusScore\n      });\n    },\n\n    addCurrency: (amount: number) => {\n      set((state) => ({ currency: state.currency + amount }));\n    },\n\n    spendCurrency: (amount: number) => {\n      set((state) => ({ \n        currency: Math.max(0, state.currency - amount) \n      }));\n    },\n\n    addKill: () => {\n      set((state) => ({ totalKills: state.totalKills + 1 }));\n    },\n\n    addBossKill: () => {\n      set((state) => ({ bossesDefeated: state.bossesDefeated + 1 }));\n    },\n\n    setCombo: (combo: number, multiplier: number, timeRemaining: number = 0) => {\n      set((state) => ({\n        comboCount: combo,\n        comboMultiplier: multiplier,\n        maxCombo: Math.max(state.maxCombo, combo),\n        comboTimeRemaining: timeRemaining\n      }));\n    },\n\n    updateCombo: (combo: number, multiplier: number) => {\n      set((state) => ({\n        comboCount: combo,\n        comboMultiplier: multiplier,\n        maxCombo: Math.max(state.maxCombo, combo)\n      }));\n    },\n\n    resetCombo: () => {\n      set({ comboCount: 0, comboMultiplier: 1 });\n    },\n  }))\n);","path":null,"size_bytes":9311,"size_tokens":null},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","path":null,"size_bytes":157,"size_tokens":null},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","path":null,"size_bytes":1877,"size_tokens":null},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","path":null,"size_bytes":329,"size_tokens":null},"client/src/lib/game/core/interfaces/ICollectible.ts":{"content":"\nimport { IGameObject, IRenderable, IUpdatable } from './IGameObject';\n\nexport interface ICollectible extends IGameObject, IRenderable, IUpdatable {\n  canBeCollected(playerPos: { x: number; y: number }): boolean;\n  getValue(): number;\n  isExpired(): boolean;\n}\n","path":null,"size_bytes":261,"size_tokens":null},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1376,"size_tokens":null},"client/src/components/ui/menubar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-4 w-4 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","path":null,"size_bytes":8522,"size_tokens":null},"client/src/components/UndeadTileMapViewer.tsx":{"content":"import React, { useEffect, useRef, useState } from 'react';\nimport { UndeadTileRenderer } from '../lib/game/rendering/UndeadTileRenderer';\nimport { Button } from './ui/button';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\n\nexport function UndeadTileMapViewer() {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [renderer, setRenderer] = useState<UndeadTileRenderer | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [mapString, setMapString] = useState<string>('');\n\n  useEffect(() => {\n    const initRenderer = async () => {\n      const tileRenderer = new UndeadTileRenderer();\n      await tileRenderer.loadUndeadSprites();\n      setRenderer(tileRenderer);\n      setMapString(tileRenderer.getMapAsString());\n      setIsLoading(false);\n    };\n\n    initRenderer();\n  }, []);\n\n  useEffect(() => {\n    if (renderer && canvasRef.current) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      // Clear canvas\n      ctx.fillStyle = '#1a1a1a';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Draw the undead scene centered\n      const offsetX = (canvas.width - 16 * 32) / 2;\n      const offsetY = (canvas.height - 16 * 32) / 2;\n\n      renderer.drawUndeadScene(ctx, offsetX, offsetY);\n    }\n  }, [renderer]);\n\n  const regenerateMap = () => {\n    if (renderer && canvasRef.current) {\n      renderer.regenerateMap();\n      setMapString(renderer.getMapAsString());\n\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      ctx.fillStyle = '#1a1a1a';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      const offsetX = (canvas.width - 16 * 32) / 2;\n      const offsetY = (canvas.height - 16 * 32) / 2;\n\n      renderer.drawUndeadScene(ctx, offsetX, offsetY);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <div className=\"text-lg\">Loading undead tileset...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col gap-6 p-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"text-2xl font-bold text-center\">\n             Undead Tileset Scene (1616) \n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"flex flex-col items-center gap-4\">\n          <canvas\n            ref={canvasRef}\n            width={600}\n            height={600}\n            className=\"border border-gray-600 rounded-lg bg-gray-900\"\n            style={{ imageRendering: 'pixelated' }}\n          />\n          <Button onClick={regenerateMap} className=\"mt-4\">\n            Generate New Scene\n          </Button>\n        </CardContent>\n      </Card>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>Map Grid Export</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <pre className=\"bg-gray-900 text-green-400 p-4 rounded-lg text-xs overflow-auto max-h-96 font-mono\">\n            {mapString}\n          </pre>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}","path":null,"size_bytes":3090,"size_tokens":null},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","path":null,"size_bytes":711,"size_tokens":null},"client/src/lib/game/managers/ParticleManager.ts":{"content":"\nimport { Particle } from \"../rendering/Particle\";\n\nexport class ParticleManager {\n  private particles: Particle[] = [];\n\n  public createHitParticles(x: number, y: number, color = \"#ffff44\"): void {\n    for (let i = 0; i < 5; i++) {\n      this.particles.push(new Particle(\n        x + (Math.random() - 0.5) * 20,\n        y + (Math.random() - 0.5) * 20,\n        (Math.random() - 0.5) * 100,\n        (Math.random() - 0.5) * 100,\n        color,\n        0.5\n      ));\n    }\n  }\n\n  public createDeathParticles(x: number, y: number): void {\n    for (let i = 0; i < 12; i++) {\n      this.particles.push(new Particle(\n        x + (Math.random() - 0.5) * 30,\n        y + (Math.random() - 0.5) * 30,\n        (Math.random() - 0.5) * 150,\n        (Math.random() - 0.5) * 150,\n        Math.random() > 0.5 ? \"#ff4444\" : \"#ff8844\",\n        1.0\n      ));\n    }\n  }\n\n  public update(deltaTime: number): void {\n    this.particles = this.particles.filter(p => p.isAlive());\n    this.particles.forEach(p => p.update(deltaTime));\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    this.particles.forEach(p => p.render(ctx));\n  }\n\n  public clear(): void {\n    this.particles = [];\n  }\n}\n","path":null,"size_bytes":1178,"size_tokens":null},"client/src/lib/game/entities/enemies/Enemy.ts":{"content":"\nimport { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\nimport { SpriteManager } from '../../rendering/SpriteManager';\n\nexport type EnemyType = \"basic\" | \"fast\" | \"tank\";\n\nexport class Enemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  private type: EnemyType;\n\n  constructor(x: number, y: number, type: EnemyType = \"basic\") {\n    super(x, y, 80, 80);\n    this.type = type;\n    this.collisionWidth = 32;\n    this.collisionHeight = 32;\n\n    const stats = this.getStatsForType(type);\n    this.speed = stats.speed;\n    this.health = stats.health;\n    this.maxHealth = stats.maxHealth;\n    this.damage = stats.damage;\n    this.scoreValue = stats.scoreValue;\n    this.width = stats.width;\n    this.height = stats.height;\n    this.collisionWidth = stats.collisionWidth;\n    this.collisionHeight = stats.collisionHeight;\n  }\n\n  private getStatsForType(type: EnemyType) {\n    const statsMap = {\n      fast: {\n        speed: 80,\n        health: 1,\n        maxHealth: 1,\n        damage: 15,\n        scoreValue: 15,\n        width: 70,\n        height: 70,\n        collisionWidth: 28,\n        collisionHeight: 28\n      },\n      tank: {\n        speed: 30,\n        health: 5,\n        maxHealth: 5,\n        damage: 30,\n        scoreValue: 50,\n        width: 120,\n        height: 120,\n        collisionWidth: 48,\n        collisionHeight: 48\n      },\n      basic: {\n        speed: 50,\n        health: 2,\n        maxHealth: 2,\n        damage: 20,\n        scoreValue: 10,\n        width: 80,\n        height: 80,\n        collisionWidth: 32,\n        collisionHeight: 32\n      }\n    };\n\n    return statsMap[type];\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance > 0) {\n      const moveX = (dx / distance) * this.speed * deltaTime;\n      const moveY = (dy / distance) * this.speed * deltaTime;\n\n      this.x += moveX;\n      this.y += moveY;\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    const spriteManager = SpriteManager.getInstance();\n    const { spriteName, fallbackColor } = this.getSpriteInfo();\n    const sprite = spriteManager.getSprite(spriteName);\n\n    if (sprite) {\n      ctx.drawImage(sprite, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\n    } else {\n      ctx.fillStyle = fallbackColor;\n      ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\n    }\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n  }\n\n  private getSpriteInfo(): { spriteName: string; fallbackColor: string } {\n    if (this.speed > 60) {\n      return { spriteName: 'enemy_fast', fallbackColor: \"#ff8844\" };\n    } else if (this.maxHealth > 2) {\n      return { spriteName: 'enemy_tank', fallbackColor: \"#ff44ff\" };\n    }\n    return { spriteName: 'enemy_basic', fallbackColor: \"#ff4444\" };\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 8, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 8, barWidth * healthPercent, barHeight);\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return this.type;\n  }\n}\n","path":null,"size_bytes":4184,"size_tokens":null},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","path":null,"size_bytes":1037,"size_tokens":null},"client/src/lib/game/core/interfaces/IWeapon.ts":{"content":"\nimport { IProjectile } from './IProjectile';\n\nexport interface IWeapon {\n  fire(deltaTime: number, x: number, y: number, direction?: { x: number; y: number }): IProjectile[];\n  getDamage(): number;\n  getFireRate(): number;\n}\n\nexport interface IUpgradeable {\n  upgrade(): void;\n  getLevel(): number;\n}\n","path":null,"size_bytes":302,"size_tokens":null},"client/src/lib/game/rendering/InfiniteTileRenderer.ts":{"content":"import { SpriteManager } from './SpriteManager';\n\nexport interface Camera {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface FlowerTile {\n  tileX: number;\n  tileY: number;\n  age: number;\n  maxAge: number;\n  bloomStage: number;\n  lastShot: number;\n  shotCooldown: number;\n  shotsRemaining: number;\n  id: number;\n}\n\nexport interface SylphOrb {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  life: number;\n  maxLife: number;\n  size: number;\n  color: string;\n  age: number;\n  targetEnemyId?: number;\n  homingSpeed: number;\n  damage: number;\n  phase: 'rising' | 'homing';\n  riseStartY: number;\n  riseTargetY: number;\n  riseProgress: number;\n  targetX?: number;\n  targetY?: number;\n}\n\n// Assuming SpiderEntity is defined elsewhere - add its interface here\nexport interface SpiderEntity {\n    x: number;\n    y: number;\n    // ... other spider properties\n}\n\nexport class InfiniteTileRenderer {\n  private spriteManager: SpriteManager;\n  private tileSize = 32;\n  private srcTileSize = 256; // Source tile size in Ground_new.png (256x256 pixels)\n  private tilesPerRow = 4; // 4 tiles across in Ground_new.png\n  private chunkSize = 32; // 32x32 tiles per chunk\n  private loadedChunks = new Map<string, number[][]>();\n  private spriteLoaded = false;\n\n  // Flower management as part of tile system\n  private flowers = new Map<string, FlowerTile>(); // Key: \"tileX,tileY\"\n  private flowerTiles: HTMLImageElement[] = [];\n  private flowersLoaded = false;\n  private nextFlowerId = 0;\n\n  // Orb management as part of tile system\n  private orbs: SylphOrb[] = [];\n\n  // Spider management as part of tile system\n  private spiders: SpiderEntity[] = [];\n  private lastSpiderRender = 0;\n\n  // Ground tile types using different tiles from the 4x4 grid in Ground_new.png\n  private static readonly GROUND_TILES = {\n    GRASS_1: 0,      // Top-left grass\n    GRASS_2: 1,      // Top-middle grass  \n    GRASS_3: 2,      // Top-right grass\n    GRASS_4: 3,      // Top-far-right grass\n    DIRT_1: 4,       // Second row, left dirt\n    DIRT_2: 5,       // Second row, middle dirt\n    DIRT_3: 6,       // Second row, right dirt\n    DIRT_4: 7,       // Second row, far-right dirt\n    STONE_1: 8,      // Third row, left stone\n    STONE_2: 9,      // Third row, middle stone\n    STONE_3: 10,     // Third row, right stone\n    STONE_4: 11,     // Third row, far-right stone\n    DARK_1: 12,      // Bottom row, left dark\n    DARK_2: 13,      // Bottom row, middle dark\n    DARK_3: 14,      // Bottom row, right dark\n    DARK_4: 15,      // Bottom row, far-right dark\n  };\n\n  constructor() {\n    this.spriteManager = SpriteManager.getInstance();\n    this.loadUndeadSprite();\n    this.loadFlowerSprites();\n  }\n\n  private async loadUndeadSprite(): Promise<void> {\n    try {\n      await this.spriteManager.loadSprite(\n        'undead_tileset', \n        '/assets/tilesets/PNG/Ground_new.png'\n      );\n      this.spriteLoaded = true;\n      console.log('Undead tileset loaded successfully');\n    } catch (error) {\n      console.warn('Failed to load undead tileset:', error);\n      this.spriteLoaded = false;\n    }\n  }\n\n  private async loadFlowerSprites(): Promise<void> {\n    try {\n      const spritesheet = new Image();\n      spritesheet.src = '/assets/sprites/flower_growing.png';\n      await new Promise((resolve, reject) => {\n        spritesheet.onload = resolve;\n        spritesheet.onerror = reject;\n      });\n\n      const frameWidth = spritesheet.width / 6;\n      const frameHeight = spritesheet.height;\n\n      // Create 6 individual flower tile images - much larger than tiles\n      for (let i = 0; i < 6; i++) {\n        const flowerSize = this.tileSize * 3; // Make flowers 3x larger than tiles\n        const canvas = document.createElement('canvas');\n        canvas.width = flowerSize;\n        canvas.height = flowerSize;\n        const ctx = canvas.getContext('2d')!;\n\n        // Calculate scale to fit the flower while maintaining aspect ratio\n        // Use the smaller scale to ensure the entire flower fits\n        const scaleX = flowerSize / frameWidth;\n        const scaleY = flowerSize / frameHeight;\n        const scale = Math.min(scaleX, scaleY) * 0.9; // Slightly smaller to ensure no cropping\n\n        const scaledWidth = frameWidth * scale;\n        const scaledHeight = frameHeight * scale;\n\n        // Center the flower in the canvas\n        const offsetX = (flowerSize - scaledWidth) / 2;\n        const offsetY = (flowerSize - scaledHeight) / 2;\n\n        ctx.drawImage(\n          spritesheet,\n          i * frameWidth, 0,\n          frameWidth, frameHeight,\n          offsetX, offsetY,\n          scaledWidth, scaledHeight\n        );\n\n        const tileImg = new Image();\n        tileImg.src = canvas.toDataURL();\n        this.flowerTiles.push(tileImg);\n      }\n\n      this.flowersLoaded = true;\n      console.log('Flower sprites loaded and integrated into tile system');\n    } catch (error) {\n      console.warn('Failed to load flower sprites:', error);\n    }\n  }\n\n  private getChunkKey(chunkX: number, chunkY: number): string {\n    return `${chunkX},${chunkY}`;\n  }\n\n  private generateChunk(chunkX: number, chunkY: number): number[][] {\n    const chunk: number[][] = [];\n\n    for (let y = 0; y < this.chunkSize; y++) {\n      chunk[y] = [];\n      for (let x = 0; x < this.chunkSize; x++) {\n        const worldX = chunkX * this.chunkSize + x;\n        const worldY = chunkY * this.chunkSize + y;\n        chunk[y][x] = this.generateCleanTileAt(worldX, worldY);\n      }\n    }\n\n    return chunk;\n  }\n\n  private generateCleanTileAt(worldX: number, worldY: number): number {\n    // Create multiple noise layers for varied terrain\n    const scale1 = 0.03; // Large regions\n    const scale2 = 0.08; // Medium features  \n    const scale3 = 0.15; // Fine details\n\n    // Base terrain noise\n    const noise1 = Math.sin(worldX * scale1) * Math.cos(worldY * scale1);\n    const noise2 = Math.sin(worldX * scale2 + 100) * Math.cos(worldY * scale2 + 100);\n    const noise3 = Math.sin(worldX * scale3 + 200) * Math.cos(worldY * scale3 + 200);\n\n    // Combine noises with different weights\n    const terrainNoise = (noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1);\n\n    // Path/feature noise\n    const pathNoise = Math.sin(worldX * 0.01 + worldY * 0.015);\n    const stoneNoise = Math.sin(worldX * 0.025 + 50) * Math.cos(worldY * 0.025 + 75);\n\n    // Add some deterministic variation based on position\n    const posVariation = ((worldX * 7 + worldY * 11) % 1000) / 1000.0 - 0.5;\n    const finalNoise = terrainNoise + posVariation * 0.2;\n\n    // Generate varied terrain with multiple tile types\n    if (pathNoise > 0.75) {\n      // Stone paths and rocky areas\n      if (stoneNoise > 0.3) return InfiniteTileRenderer.GROUND_TILES.STONE_1;\n      if (stoneNoise > 0.0) return InfiniteTileRenderer.GROUND_TILES.STONE_2;\n      if (stoneNoise > -0.3) return InfiniteTileRenderer.GROUND_TILES.STONE_3;\n      return InfiniteTileRenderer.GROUND_TILES.STONE_4;\n    } else if (finalNoise > 0.4) {\n      // Dark/corrupted areas\n      if (finalNoise > 0.7) return InfiniteTileRenderer.GROUND_TILES.DARK_1;\n      if (finalNoise > 0.5) return InfiniteTileRenderer.GROUND_TILES.DARK_2;\n      return InfiniteTileRenderer.GROUND_TILES.DARK_3;\n    } else if (finalNoise > 0.1) {\n      // Dirt areas\n      if (finalNoise > 0.3) return InfiniteTileRenderer.GROUND_TILES.DIRT_1;\n      if (finalNoise > 0.2) return InfiniteTileRenderer.GROUND_TILES.DIRT_2;\n      return InfiniteTileRenderer.GROUND_TILES.DIRT_3;\n    } else if (finalNoise > -0.2) {\n      // Grass areas\n      if (finalNoise > 0.0) return InfiniteTileRenderer.GROUND_TILES.GRASS_1;\n      if (finalNoise > -0.1) return InfiniteTileRenderer.GROUND_TILES.GRASS_2;\n      return InfiniteTileRenderer.GROUND_TILES.GRASS_3;\n    } else {\n      // Base ground variation\n      if (finalNoise > -0.4) return InfiniteTileRenderer.GROUND_TILES.GRASS_4;\n      if (finalNoise > -0.6) return InfiniteTileRenderer.GROUND_TILES.DIRT_4;\n      return InfiniteTileRenderer.GROUND_TILES.STONE_1;\n    }\n  }\n\n  private getChunk(chunkX: number, chunkY: number): number[][] {\n    const key = this.getChunkKey(chunkX, chunkY);\n    if (!this.loadedChunks.has(key)) {\n      this.loadedChunks.set(key, this.generateChunk(chunkX, chunkY));\n    }\n    return this.loadedChunks.get(key)!;\n  }\n\n  public getTileAt(worldX: number, worldY: number): number {\n    const chunkX = Math.floor(worldX / this.chunkSize);\n    const chunkY = Math.floor(worldY / this.chunkSize);\n    const localX = worldX - chunkX * this.chunkSize;\n    const localY = worldY - chunkY * this.chunkSize;\n\n    const chunk = this.getChunk(chunkX, chunkY);\n    return chunk[localY] ? chunk[localY][localX] || InfiniteTileRenderer.GROUND_TILES.GRASS_1 : InfiniteTileRenderer.GROUND_TILES.GRASS_1;\n  }\n\n  public isSolidAt(worldX: number, worldY: number): boolean {\n    // All ground tiles are walkable - no solid tiles for basic terrain\n    return false;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, camera: Camera): void {\n    if (!this.spriteLoaded) {\n      this.renderFallback(ctx, camera);\n      return;\n    }\n\n    const sprite = this.spriteManager.getSprite('undead_tileset');\n    if (!sprite) {\n      this.renderFallback(ctx, camera);\n      return;\n    }\n\n    // Calculate visible tile range with buffer\n    const buffer = 2;\n    const startTileX = Math.floor(camera.x / this.tileSize) - buffer;\n    const endTileX = Math.ceil((camera.x + camera.width) / this.tileSize) + buffer;\n    const startTileY = Math.floor(camera.y / this.tileSize) - buffer;\n    const endTileY = Math.ceil((camera.y + camera.height) / this.tileSize) + buffer;\n\n    // Disable smoothing for pixel-perfect tiles\n    ctx.imageSmoothingEnabled = false;\n    ctx.imageSmoothingQuality = 'low';\n\n    // Render visible ground tiles\n    for (let tileY = startTileY; tileY <= endTileY; tileY++) {\n      for (let tileX = startTileX; tileX <= endTileX; tileX++) {\n        const tileId = this.getTileAt(tileX, tileY);\n        const screenX = Math.floor(tileX * this.tileSize - camera.x);\n        const screenY = Math.floor(tileY * this.tileSize - camera.y);\n\n        this.drawTile(ctx, sprite, tileId, screenX, screenY);\n\n        // Render flower on this tile if it exists\n        const flowerKey = `${tileX},${tileY}`;\n        const flower = this.flowers.get(flowerKey);\n        if (flower) {\n          this.drawFlower(ctx, flower, screenX, screenY);\n        }\n      }\n    }\n\n    // Render spiders as background layer\n    this.renderSpiders(ctx, camera);\n\n    // Render flowers and orbs\n    this.renderOrbs(ctx, camera);\n  }\n\n  private drawTile(ctx: CanvasRenderingContext2D, sprite: HTMLImageElement, tileId: number, x: number, y: number): void {\n    // Calculate source coordinates based on tileId\n    // Ground_new.png has a 4x4 grid of 256x256 tiles\n    const tileRow = Math.floor(tileId / this.tilesPerRow);\n    const tileCol = tileId % this.tilesPerRow;\n\n    // Crop more aggressively to remove all borders and ensure seamless tiling\n    const cropMargin = 16; // Crop 16 pixels from each side\n    const srcX = cropMargin + (tileCol * this.srcTileSize);\n    const srcY = cropMargin + (tileRow * this.srcTileSize);\n    const actualTileSize = this.srcTileSize - (cropMargin * 2); // 224 pixels after cropping\n\n    // Render slightly larger to ensure no gaps between tiles\n    const renderSize = this.tileSize + 1;\n    const renderX = Math.floor(x);\n    const renderY = Math.floor(y);\n\n    ctx.drawImage(\n      sprite,\n      srcX, srcY, actualTileSize, actualTileSize,\n      renderX, renderY, renderSize, renderSize\n    );\n  }\n\n  private renderFallback(ctx: CanvasRenderingContext2D, camera: Camera): void {\n    const startTileX = Math.floor(camera.x / this.tileSize);\n    const endTileX = Math.ceil((camera.x + camera.width) / this.tileSize);\n    const startTileY = Math.floor(camera.y / this.tileSize);\n    const endTileY = Math.ceil((camera.y + camera.height) / this.tileSize);\n\n    // Fallback colors matching the new tile variety\n    const getColorForTile = (tileId: number): string => {\n      // Grass colors (0-3)\n      if (tileId <= 3) return ['#4a5c2a', '#5a6b3a', '#3a4c1a', '#6a7b4a'][tileId];\n      // Dirt colors (4-7)  \n      if (tileId <= 7) return ['#8b7355', '#9b8365', '#7b6345', '#ab9375'][tileId - 4];\n      // Stone colors (8-11)\n      if (tileId <= 11) return ['#666666', '#777777', '#555555', '#888888'][tileId - 8];\n      // Dark colors (12-15)\n      return ['#2a2a2a', '#3a3a3a', '#1a1a1a', '#4a4a4a'][tileId - 12] || '#4a5c2a';\n    };\n\n    for (let tileY = startTileY; tileY <= endTileY; tileY++) {\n      for (let tileX = startTileX; tileX <= endTileX; tileX++) {\n        const tileId = this.getTileAt(tileX, tileY);\n        const screenX = tileX * this.tileSize - camera.x;\n        const screenY = tileY * this.tileSize - camera.y;\n\n        ctx.fillStyle = getColorForTile(tileId);\n        ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\n      }\n    }\n  }\n\n  private drawFlower(ctx: CanvasRenderingContext2D, flower: FlowerTile, screenX: number, screenY: number): void {\n    const flowerSize = this.tileSize * 3; // 3x larger than tiles\n\n    if (!this.flowersLoaded || this.flowerTiles.length === 0) {\n      // Fallback flower rendering - much larger and more visible\n      ctx.save();\n      const colors = ['#32cd32', '#90ee90', '#ff69b4', '#ff1493', '#9370db', '#4169e1'];\n      ctx.fillStyle = colors[flower.bloomStage] || colors[0];\n\n      const size = flowerSize * 0.6; // Large visible size\n      const centerX = screenX + this.tileSize / 2;\n      const centerY = screenY + this.tileSize / 2;\n\n      // Draw flower with multiple petals for better visibility\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Add center\n      ctx.fillStyle = '#ffff00';\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, size / 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      ctx.restore();\n      return;\n    }\n\n    const frameIndex = Math.min(Math.max(flower.bloomStage, 0), 5);\n    const flowerTile = this.flowerTiles[frameIndex];\n\n    ctx.save();\n\n    // Fade out in last 20% of life\n    const ageRatio = flower.age / flower.maxAge;\n    if (ageRatio > 0.8) {\n      ctx.globalAlpha = (1 - ageRatio) / 0.2;\n    }\n\n    // Anchor flower to ground - center horizontally but align bottom with tile\n    const offsetX = screenX - (flowerSize - this.tileSize) / 2;\n    const offsetY = screenY - (flowerSize - this.tileSize); // Align bottom of flower with tile\n\n    // Draw large flower centered on tile\n    ctx.drawImage(\n      flowerTile,\n      0, 0,\n      flowerSize, flowerSize,\n      offsetX, offsetY,\n      flowerSize, flowerSize\n    );\n\n    // Add sparkle effect for mature flowers\n    if (flower.bloomStage >= 4) {\n      ctx.globalAlpha = 0.6;\n      ctx.fillStyle = '#ffffff';\n      for (let i = 0; i < 4; i++) { // More sparkles for larger flowers\n        const sparkleX = offsetX + Math.random() * flowerSize;\n        const sparkleY = offsetY + Math.random() * flowerSize;\n        const sparkleSize = 2 + Math.random() * 4; // Larger sparkles\n        ctx.beginPath();\n        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    ctx.restore();\n  }\n\n  private renderOrbs(ctx: CanvasRenderingContext2D, camera: Camera): void {\n    this.orbs.forEach((orb) => {\n      const screenX = Math.floor(orb.x - camera.x);\n      const screenY = Math.floor(orb.y - camera.y);\n\n      // Expand culling bounds to account for full orb sprite size\n      const maxRadius = orb.size * 3.0;\n      if (\n        screenX < -maxRadius ||\n        screenX > camera.width + maxRadius ||\n        screenY < -maxRadius ||\n        screenY > camera.height + maxRadius\n      ) {\n        return;\n      }\n\n      ctx.save();\n      ctx.globalAlpha = orb.life;\n\n      // Enhanced mystical orb rendering\n      const time = Date.now() * 0.008;\n      const orbLifeRatio = orb.age / orb.maxLife;\n      const pulse = Math.sin(time + orb.age * 0.01) * 0.4 + 0.6;\n\n      // Move to center position\n      ctx.translate(screenX, screenY);\n\n      // Smooth rotation based on movement direction\n      const rotationSpeed = Math.sqrt(orb.vx * orb.vx + orb.vy * orb.vy) * 0.01;\n      ctx.rotate(orb.age * rotationSpeed * 0.003);\n\n      // Mystical outer glow\n      ctx.shadowColor = orb.color;\n      ctx.shadowBlur = 8 * pulse;\n\n      // Draw flower petals with enhanced mystical effect\n      const petalCount = 5;\n      for (let i = 0; i < petalCount; i++) {\n        ctx.save();\n        ctx.rotate((Math.PI * 2 * i) / petalCount);\n\n        // Gradient petal effect\n        const gradient = ctx.createRadialGradient(0, -orb.size * 0.3, 0, 0, -orb.size * 0.3, orb.size * 0.5);\n        gradient.addColorStop(0, orb.color);\n        gradient.addColorStop(0.7, `${orb.color}80`); // Semi-transparent\n        gradient.addColorStop(1, `${orb.color}20`); // Very transparent\n\n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.ellipse(\n          0,\n          -orb.size * 0.35,\n          orb.size * 0.25,\n          orb.size * 0.5,\n          0,\n          0,\n          Math.PI * 2,\n        );\n        ctx.fill();\n\n        ctx.restore();\n      }\n\n      // Pulsing core with gradient\n      const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orb.size * 0.3);\n      coreGradient.addColorStop(0, \"#ffffff\");\n      coreGradient.addColorStop(0.3, \"#ffff88\");\n      coreGradient.addColorStop(1, orb.color);\n\n      ctx.fillStyle = coreGradient;\n      ctx.beginPath();\n      ctx.arc(0, 0, orb.size * 0.2 * pulse, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Reduced sparkle frequency from 0.15 to 0.05 for better performance\n      if (Math.random() < 0.05 && orbLifeRatio < 0.8) {\n        const sparkleAlpha = (1 - orbLifeRatio) * Math.random() * 0.7;\n        ctx.fillStyle = `rgba(255, 255, 255, ${sparkleAlpha})`;\n        const sparkleDistance = orb.size * 0.8;\n        const sparkleAngle = Math.random() * Math.PI * 2;\n        const sparkleX = Math.cos(sparkleAngle) * sparkleDistance * Math.random();\n        const sparkleY = Math.sin(sparkleAngle) * sparkleDistance * Math.random();\n        ctx.beginPath();\n        ctx.arc(sparkleX, sparkleY, 0.5 + Math.random() * 1, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      ctx.restore();\n    });\n  }\n\n  // New method to render spiders\n  private renderSpiders(ctx: CanvasRenderingContext2D, camera: Camera): void {\n    // Render spiders every frame for smooth animation (no throttling)\n    \n    this.spiders.forEach((spider) => {\n      const screenX = Math.floor(spider.x - camera.x);\n      const screenY = Math.floor(spider.y - camera.y);\n\n      // Check if spider is within camera bounds\n      const spiderHeight = this.tileSize * 1.5;\n      const spiderWidth = spiderHeight * (800 / 450);\n      if (\n        screenX < -spiderWidth ||\n        screenX > camera.width + spiderWidth ||\n        screenY < -spiderHeight ||\n        screenY > camera.height + spiderHeight\n      ) {\n        return;\n      }\n\n      this.drawSpider(ctx, spider, screenX, screenY);\n    });\n  }\n\n  private drawSpider(ctx: CanvasRenderingContext2D, spider: any, screenX: number, screenY: number): void {\n    const spiderHeight = this.tileSize * 1.5; // Height based on tile size\n    const spiderWidth = spiderHeight * (800 / 450); // Maintain 800:450 aspect ratio\n\n    ctx.save();\n    \n    // Store previous position for clearing\n    if (!spider.previousScreenX) spider.previousScreenX = screenX;\n    if (!spider.previousScreenY) spider.previousScreenY = screenY;\n    \n    // Remove clearRect to prevent black squares - canvas is cleared each frame by GameEngine\n    \n    // Update stored position\n    spider.previousScreenX = screenX;\n    spider.previousScreenY = screenY;\n\n    // Get the appropriate sprite for current animation\n    let spriteName = 'spider_down';\n    if (spider.currentAnimation) {\n      switch (spider.currentAnimation) {\n        case 'spider_walk_up':\n          spriteName = 'spider_up';\n          break;\n        case 'spider_walk_down':\n          spriteName = 'spider_down';\n          break;\n        case 'spider_walk_side':\n          spriteName = 'spider_side';\n          break;\n        case 'spider_walk_diagonal_up':\n          spriteName = 'spider_diagonal_up';\n          break;\n        case 'spider_walk_diagonal_down':\n          spriteName = 'spider_diagonal_down';\n          break;\n        case 'spider_jumping':\n          spriteName = 'spider_jumping';\n          break;\n        default:\n          spriteName = 'spider_down';\n      }\n    }\n\n    const sprite = this.spriteManager.getSprite(spriteName);\n\n    if (sprite && sprite.complete) {\n      try {\n        // Disable smoothing for crisp sprites\n        ctx.imageSmoothingEnabled = false;\n        ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing mode\n        \n        // No shadow effects to prevent trails\n        ctx.shadowColor = 'transparent';\n        ctx.shadowBlur = 0;\n        ctx.globalAlpha = 1.0;\n\n        // Optimize frame calculation - use simpler modulo approach\n        const frameCount = spriteName === 'spider_jumping' ? 4 : 30;\n        const frameWidth = sprite.naturalWidth / frameCount;\n        const frameHeight = sprite.naturalHeight;\n\n        // Use frame counter instead of time-based updates for better performance\n        if (!spider.frameCounter) spider.frameCounter = 0;\n        spider.frameCounter++;\n        const frameIndex = Math.floor(spider.frameCounter / 12) % frameCount; // Update every 12 game frames\n\n        const drawX = Math.floor(screenX - (spiderWidth - this.tileSize) / 2);\n        const drawY = Math.floor(screenY - (spiderHeight - this.tileSize) / 2);\n        \n        // Simplified sprite drawing\n        ctx.drawImage(\n          sprite,\n          frameIndex * frameWidth, 0, frameWidth, frameHeight,\n          drawX, drawY, spiderWidth, spiderHeight\n        );\n\n        // Remove sparkle effects entirely to prevent trails\n        // No sparkle effects\n\n      } catch (error) {\n        console.error(\"Error drawing spider sprite:\", error, spriteName);\n        this.renderFallbackSpider(ctx, screenX, screenY, spiderSize);\n      }\n    } else {\n      this.renderFallbackSpider(ctx, screenX, screenY, spiderSize);\n    }\n\n    ctx.restore();\n  }\n\n  private renderFallbackSpider(ctx: CanvasRenderingContext2D, screenX: number, screenY: number, spiderSize: number): void {\n    ctx.save();\n    \n    // Enhanced fallback spider - much more visible like flowers\n    const centerX = screenX + this.tileSize / 2;\n    const centerY = screenY + this.tileSize / 2;\n\n    // Main body\n    ctx.fillStyle = '#333333';\n    ctx.beginPath();\n    ctx.ellipse(centerX, centerY, spiderSize * 0.3, spiderSize * 0.2, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Abdomen\n    ctx.fillStyle = '#444444';\n    ctx.beginPath();\n    ctx.ellipse(centerX, centerY + spiderSize * 0.1, spiderSize * 0.2, spiderSize * 0.3, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Legs\n    ctx.strokeStyle = '#222222';\n    ctx.lineWidth = 3;\n    for (let i = 0; i < 8; i++) {\n      const angle = (i * Math.PI) / 4;\n      const legLength = spiderSize * 0.4;\n      const startX = centerX + Math.cos(angle) * spiderSize * 0.15;\n      const startY = centerY + Math.sin(angle) * spiderSize * 0.1;\n      const endX = centerX + Math.cos(angle) * legLength;\n      const endY = centerY + Math.sin(angle) * legLength * 0.6;\n      \n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n    }\n\n    // Eyes\n    ctx.fillStyle = '#ff3333';\n    ctx.beginPath();\n    ctx.arc(centerX - spiderSize * 0.1, centerY - spiderSize * 0.05, 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(centerX + spiderSize * 0.1, centerY - spiderSize * 0.05, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Blue glow for mechanical effect\n    ctx.shadowColor = \"#3333ff\";\n    ctx.shadowBlur = 4;\n    ctx.strokeStyle = \"#6666ff\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(screenX, screenY, spiderSize, spiderSize);\n\n    ctx.restore();\n  }\n\n  // Spider management methods\n  public addSpider(spider: any): void {\n    // Remove any existing spider with the same instanceId to prevent duplicates\n    this.spiders = this.spiders.filter(s => s.instanceId !== spider.instanceId);\n    // Add the new/updated spider\n    this.spiders.push(spider);\n  }\n\n  public removeSpider(instanceId: string): void {\n    this.spiders = this.spiders.filter(spider => spider.instanceId !== instanceId);\n  }\n\n  public updateSpider(instanceId: string, x: number, y: number, currentAnimation: string, lastDirection: any): void {\n    const spider = this.spiders.find(s => s.instanceId === instanceId);\n    if (spider) {\n      spider.x = x;\n      spider.y = y;\n      spider.currentAnimation = currentAnimation;\n      spider.lastDirection = lastDirection;\n    }\n  }\n\n  public addFlower(tileX: number, tileY: number, maxAge: number = 15000): FlowerTile | null {\n    const flowerKey = `${tileX},${tileY}`;\n\n    // Don't place flower if tile is already occupied\n    if (this.flowers.has(flowerKey)) {\n      return null;\n    }\n\n    const flower: FlowerTile = {\n      tileX,\n      tileY,\n      age: 0,\n      maxAge,\n      bloomStage: 0,\n      lastShot: 0,\n      shotCooldown: 2500,\n      shotsRemaining: 6,\n      id: this.nextFlowerId++\n    };\n\n    this.flowers.set(flowerKey, flower);\n    return flower;\n  }\n\n  public removeFlower(tileX: number, tileY: number): void {\n    const flowerKey = `${tileX},${tileY}`;\n    this.flowers.delete(flowerKey);\n  }\n\n  public getFlower(tileX: number, tileY: number): FlowerTile | null {\n    const flowerKey = `${tileX},${tileY}`;\n    return this.flowers.get(flowerKey) || null;\n  }\n\n  public getAllFlowers(): FlowerTile[] {\n    return Array.from(this.flowers.values());\n  }\n\n  public updateFlowers(deltaTime: number): void {\n    const now = Date.now();\n    const flowersToRemove: string[] = [];\n\n    for (const [key, flower] of this.flowers.entries()) {\n      flower.age += deltaTime * 1000;\n\n      // Update bloom stage based on age - grow over 1.5 seconds (faster growth)\n      const growthTime = 1500; // 1.5 seconds to fully grow\n      const ageRatio = flower.age / flower.maxAge;\n\n      if (flower.age < growthTime) {\n        // Growing phase - progress through stages 0-5 over 1.5 seconds\n        const growthProgress = flower.age / growthTime;\n        flower.bloomStage = Math.min(Math.floor(growthProgress * 6), 5);\n      } else {\n        // Fully mature\n        flower.bloomStage = 5;\n      }\n\n      // Check if flower should be removed\n      if (flower.age >= flower.maxAge || flower.shotsRemaining <= 0) {\n        flowersToRemove.push(key);\n      }\n    }\n\n    // Remove expired flowers\n    flowersToRemove.forEach(key => this.flowers.delete(key));\n  }\n\n  public canFlowerShoot(flower: FlowerTile): boolean {\n    const now = Date.now();\n    return flower.bloomStage >= 5 && // Only fully grown flowers can shoot\n           now - flower.lastShot >= flower.shotCooldown && \n           flower.shotsRemaining > 0;\n  }\n\n  public flowerShoot(flower: FlowerTile): void {\n    flower.lastShot = Date.now();\n    flower.shotsRemaining--;\n  }\n\n  public getTileSize(): number {\n    return this.tileSize;\n  }\n\n  // Cleanup old chunks that are far from camera to prevent memory leaks\n  public cleanupChunks(camera: Camera): void {\n    const currentChunkX = Math.floor(camera.x / (this.chunkSize * this.tileSize));\n    const currentChunkY = Math.floor(camera.y / (this.chunkSize * this.tileSize));\n    const maxDistance = 3; // Keep chunks within 3 chunks of camera\n\n    const chunksToRemove: string[] = [];\n    for (const [key, _] of this.loadedChunks) {\n      const [chunkX, chunkY] = key.split(',').map(Number);\n      const distance = Math.max(Math.abs(chunkX - currentChunkX), Math.abs(chunkY - currentChunkY));\n\n      if (distance > maxDistance) {\n        chunksToRemove.push(key);\n      }\n    }\n\n    chunksToRemove.forEach(key => this.loadedChunks.delete(key));\n  }\n\n  // Orb management methods\n  public addOrb(orb: SylphOrb): void {\n    this.orbs.push(orb);\n  }\n\n  public updateOrbs(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.orbs = this.orbs.filter((orb) => {\n      orb.age += deltaTime * 1000;\n      orb.life = Math.max(0, 1 - orb.age / orb.maxLife);\n\n      if (orb.life <= 0) return false;\n\n      // Homing phase - fast tracking toward nearest enemy\n      const nearestEnemy = this.findNearestEnemy(enemies, orb.x, orb.y, 400);\n\n      if (nearestEnemy) {\n        const dx = nearestEnemy.x - orb.x;\n        const dy = nearestEnemy.y - orb.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n          // Strong homing with mystical curves\n          const orbLifeRatio = orb.age / orb.maxLife;\n          const waveIntensity = Math.sin(orb.age * 0.004) * 20 * (1 - orbLifeRatio);\n          const perpX = -dy / distance;\n          const perpY = dx / distance;\n\n          // Accelerating homing force\n          const proximityBoost = Math.max(0.7, 1 - (distance / 250));\n          const homingForce = orb.homingSpeed * deltaTime * proximityBoost * 1.5;\n\n          orb.vx += (dx / distance) * homingForce;\n          orb.vy += (dy / distance) * homingForce;\n\n          // Mystical wave motion\n          orb.vx += perpX * waveIntensity * deltaTime;\n          orb.vy += perpY * waveIntensity * deltaTime;\n\n          // Dynamic speed limit - much faster when homing\n          const maxSpeed = 300 + (proximityBoost * 200);\n          const currentSpeed = Math.sqrt(orb.vx * orb.vx + orb.vy * orb.vy);\n          if (currentSpeed > maxSpeed) {\n            const speedRatio = maxSpeed / currentSpeed;\n            orb.vx *= speedRatio;\n            orb.vy *= speedRatio;\n          }\n        }\n      } else {\n        // No target - gentle floating\n        orb.vx *= 0.95;\n        orb.vy *= 0.95;\n      }\n\n      // Always update position\n      orb.x += orb.vx * deltaTime;\n      orb.y += orb.vy * deltaTime;\n\n      // Efficient cleanup\n      const playerDistSq = (orb.x - playerX) * (orb.x - playerX) + (orb.y - playerY) * (orb.y - playerY);\n      return playerDistSq < 4000000;\n    });\n  }\n\n  public checkOrbCollisions(enemies: any[]): { enemy: any; damage: number; orbX: number; orbY: number }[] {\n    const collisions: { enemy: any; damage: number; orbX: number; orbY: number }[] = [];\n\n    this.orbs.forEach((orb) => {\n      if (orb.life <= 0) return;\n\n      enemies.forEach((enemy) => {\n        if (enemy.health <= 0) return;\n\n        const dx = enemy.x - orb.x;\n        const dy = enemy.y - orb.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        const collisionRadius = orb.size + 8;\n\n        if (distance < collisionRadius) {\n          const wasAlive = enemy.isAlive();\n          enemy.takeDamage(orb.damage);\n          orb.life = 0;\n\n          // Record collision for experience orb spawning\n          collisions.push({\n            enemy: enemy,\n            damage: orb.damage,\n            orbX: orb.x,\n            orbY: orb.y\n          });\n        }\n      });\n    });\n\n    this.orbs = this.orbs.filter((orb) => orb.life > 0);\n    return collisions;\n  }\n\n  public getAllOrbs(): SylphOrb[] {\n    return [...this.orbs];\n  }\n\n  private findNearestEnemy(enemies: any[], x: number, y: number, maxRange: number): any | null {\n    let nearest: any | null = null;\n    let nearestDistance = maxRange;\n\n    enemies.forEach((enemy) => {\n      if (enemy.health <= 0) return;\n\n      const dx = enemy.x - x;\n      const dy = enemy.y - y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < nearestDistance) {\n        nearest = enemy;\n        nearestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  public fireOrbFromFlower(flower: FlowerTile, targetEnemy: any, damage: number): void {\n    const flowerSize = this.tileSize * 3;\n\n    // Position orb at the flower bud (start directly from bud)\n    const flowerCenterX = flower.tileX * this.tileSize + Math.floor(this.tileSize / 2);\n    const flowerGroundY = flower.tileY * this.tileSize + Math.floor(this.tileSize / 2);\n    const flowerBudY = flowerGroundY - Math.floor(flowerSize * 0.3);\n\n    // Calculate initial velocity toward target\n    const dx = targetEnemy.x - flowerCenterX;\n    const dy = targetEnemy.y - flowerBudY;\n    const distance = Math.sqrt(dx * dx + dy * dy);    const initialSpeed = 250;\n\n    const orb: SylphOrb = {\n      x: flowerCenterX,\n      y: flowerBudY,\n      vx: distance > 0 ? (dx / distance) * initialSpeed : 0,\n      vy: distance > 0 ? (dy / distance) * initialSpeed : 0,\n      life: 1,\n      maxLife: 5000,\n      size: 6,\n      color: \"#ff69b4\",\n      age: 0,\n      targetEnemyId: Math.random(),\n      homingSpeed: 300,\n      damage: damage * (1 + flower.bloomStage * 0.2),\n      phase: 'homing',\n      riseStartY: flowerBudY,\n      riseTargetY: flowerBudY,\n      riseProgress: 1,\n      targetX: targetEnemy.x,\n      targetY: targetEnemy.y\n    };\n\n    this.addOrb(orb);\n  }\n}","path":null,"size_bytes":32960,"size_tokens":null},"shared/schema.ts":{"content":"import { pgTable, text, serial, integer, boolean } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  username: text(\"username\").notNull().unique(),\n  password: text(\"password\").notNull(),\n});\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  username: true,\n  password: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\n","path":null,"size_bytes":533,"size_tokens":null},"client/src/lib/game/services/IAudioService.ts":{"content":"\nexport interface IAudioService {\n  playHit(): void;\n  playSuccess(): void;\n  playBackgroundMusic(): void;\n  stopBackgroundMusic(): void;\n  toggleMute(): void;\n  isMuted(): boolean;\n}\n","path":null,"size_bytes":184,"size_tokens":null},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path, { dirname } from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { fileURLToPath } from \"url\";\nimport glsl from \"vite-plugin-glsl\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    glsl(), // Add GLSL shader support\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(__dirname, \"shared\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: path.resolve(__dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  // Add support for large models and audio files\n  assetsInclude: [\"**/*.gltf\", \"**/*.glb\", \"**/*.mp3\", \"**/*.ogg\", \"**/*.wav\"],\n});\n","path":null,"size_bytes":896,"size_tokens":null},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationLink,\n  PaginationItem,\n  PaginationPrevious,\n  PaginationNext,\n  PaginationEllipsis,\n}\n","path":null,"size_bytes":2751,"size_tokens":null},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Minus } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-1 ring-ring\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Minus />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","path":null,"size_bytes":2143,"size_tokens":null},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1))\",\n          \"2\": \"hsl(var(--chart-2))\",\n          \"3\": \"hsl(var(--chart-3))\",\n          \"4\": \"hsl(var(--chart-4))\",\n          \"5\": \"hsl(var(--chart-5))\",\n        },\n        sidebar: {\n          DEFAULT: \"hsl(var(--sidebar-background))\",\n          foreground: \"hsl(var(--sidebar-foreground))\",\n          primary: \"hsl(var(--sidebar-primary))\",\n          \"primary-foreground\": \"hsl(var(--sidebar-primary-foreground))\",\n          accent: \"hsl(var(--sidebar-accent))\",\n          \"accent-foreground\": \"hsl(var(--sidebar-accent-foreground))\",\n          border: \"hsl(var(--sidebar-border))\",\n          ring: \"hsl(var(--sidebar-ring))\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","path":null,"size_bytes":2787,"size_tokens":null},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","path":null,"size_bytes":710,"size_tokens":null},"client/src/lib/game/services/ICollisionService.ts":{"content":"\nimport { ICollidable } from '../core/interfaces/IGameObject';\n\nexport interface ICollisionService {\n  checkCollision(obj1: ICollidable, obj2: ICollidable): boolean;\n  getDistance(obj1: ICollidable, obj2: ICollidable): number;\n}\n","path":null,"size_bytes":229,"size_tokens":null},"client/src/lib/game/systems/CollisionDetection.ts":{"content":"import { GameObject } from \"../entities/Player\";\nimport { Projectile } from \"../weapons/Projectile\";\nimport { Enemy } from \"../entities/Enemy\";\nimport { ShieldedEnemy } from \"../entities/enemies/ShieldedEnemy\";\nimport { FlyingEnemy } from \"../entities/enemies/FlyingEnemy\";\nimport { EnemyProjectile } from \"../entities/enemies/EnemyProjectile\";\n\nexport class CollisionDetection {\n  public checkCollision(obj1: GameObject, obj2: GameObject): boolean {\n    const obj1Width = (obj1 as any).collisionWidth || obj1.width;\n    const obj1Height = (obj1 as any).collisionHeight || obj1.height;\n    const obj2Width = (obj2 as any).collisionWidth || obj2.width;\n    const obj2Height = (obj2 as any).collisionHeight || obj2.height;\n    \n    return (\n      obj1.x - obj1Width / 2 < obj2.x + obj2Width / 2 &&\n      obj1.x + obj1Width / 2 > obj2.x - obj2Width / 2 &&\n      obj1.y - obj1Height / 2 < obj2.y + obj2Height / 2 &&\n      obj1.y + obj1Height / 2 > obj2.y - obj2Height / 2\n    );\n  }\n\n  public getDistance(obj1: GameObject, obj2: GameObject): number {\n    const dx = obj1.x - obj2.x;\n    const dy = obj1.y - obj2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  public checkTerrainCollision(obj: GameObject, terrainBounds?: { x: number; y: number; width: number; height: number }): boolean {\n    if ((obj as any).ignoresTerrain) {\n      return false;\n    }\n    \n    if (!terrainBounds) {\n      return false;\n    }\n\n    const objWidth = (obj as any).collisionWidth || obj.width;\n    const objHeight = (obj as any).collisionHeight || obj.height;\n    \n    return (\n      obj.x - objWidth / 2 < terrainBounds.x ||\n      obj.x + objWidth / 2 > terrainBounds.x + terrainBounds.width ||\n      obj.y - objHeight / 2 < terrainBounds.y ||\n      obj.y + objHeight / 2 > terrainBounds.y + terrainBounds.height\n    );\n  }\n\n  public canDamageEnemy(enemy: Enemy): boolean {\n    if (enemy instanceof ShieldedEnemy) {\n      return !enemy.isShieldActive();\n    }\n    return true;\n  }\n\n  public isFlying(obj: GameObject): boolean {\n    return (obj as any).ignoresTerrain === true || obj instanceof FlyingEnemy;\n  }\n\n  public checkEnemyProjectilePlayerCollision(projectile: EnemyProjectile, player: GameObject): boolean {\n    if (!projectile.isAlive()) return false;\n    return this.checkCollision(projectile, player);\n  }\n\n  public static checkCollision(obj1: GameObject, obj2: GameObject): boolean {\n    const obj1Width = (obj1 as any).collisionWidth || obj1.width;\n    const obj1Height = (obj1 as any).collisionHeight || obj1.height;\n    const obj2Width = (obj2 as any).collisionWidth || obj2.width;\n    const obj2Height = (obj2 as any).collisionHeight || obj2.height;\n    \n    return (\n      obj1.x - obj1Width / 2 < obj2.x + obj2Width / 2 &&\n      obj1.x + obj1Width / 2 > obj2.x - obj2Width / 2 &&\n      obj1.y - obj1Height / 2 < obj2.y + obj2Height / 2 &&\n      obj1.y + obj1Height / 2 > obj2.y - obj2Height / 2\n    );\n  }\n\n  public static canDamageEnemy(enemy: Enemy): boolean {\n    if (enemy instanceof ShieldedEnemy) {\n      return !enemy.isShieldActive();\n    }\n    return true;\n  }\n\n  public static checkProjectileEnemyCollisions(projectiles: Projectile[], enemies: Enemy[]): { projectilesToRemove: number[], enemiesToRemove: number[], damageDealt: number } {\n    const projectilesToRemove: number[] = [];\n    const enemiesToRemove: number[] = [];\n    let damageDealt = 0;\n\n    for (let i = 0; i < projectiles.length; i++) {\n      const projectile = projectiles[i];\n      const isPiercing = (projectile as any).piercing;\n      let hitCount = (projectile as any).hitCount || 0;\n      const maxHits = (projectile as any).maxHits || 1;\n\n      for (let j = 0; j < enemies.length; j++) {\n        const enemy = enemies[j];\n\n        if (this.checkCollision(projectile, enemy)) {\n          if (!this.canDamageEnemy(enemy)) {\n            continue;\n          }\n\n          enemy.takeDamage(projectile.damage);\n          damageDealt += projectile.damage;\n\n          if (enemy.health <= 0 && !enemiesToRemove.includes(j)) {\n            enemiesToRemove.push(j);\n          }\n\n          if (isPiercing) {\n            hitCount++;\n            (projectile as any).hitCount = hitCount;\n\n            if (hitCount >= maxHits && !projectilesToRemove.includes(i)) {\n              projectilesToRemove.push(i);\n            }\n          } else {\n            if (!projectilesToRemove.includes(i)) {\n              projectilesToRemove.push(i);\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    return { projectilesToRemove, enemiesToRemove, damageDealt };\n  }\n}\n","path":null,"size_bytes":4544,"size_tokens":null},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 5000\n  // this serves both the API and the client\n  const port = 5000;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();\n","path":null,"size_bytes":1871,"size_tokens":null},"client/src/lib/game/GameEngine.ts":{"content":"import { Player } from './entities/characters/Player';\nimport { AssassinPlayer } from './entities/characters/AssassinPlayer';\nimport { Enemy } from './entities/enemies/Enemy';\nimport { BossEnemy } from './entities/enemies/BossEnemy';\nimport { FlyingEnemy } from './entities/enemies/FlyingEnemy';\nimport { RangedEnemy } from './entities/enemies/RangedEnemy';\nimport { TeleportingEnemy } from './entities/enemies/TeleportingEnemy';\nimport { SplittingEnemy } from './entities/enemies/SplittingEnemy';\nimport { ShieldedEnemy } from './entities/enemies/ShieldedEnemy';\nimport { EnemyProjectile } from './entities/enemies/EnemyProjectile';\nimport { Projectile } from './weapons/projectiles/Projectile';\nimport { IProjectile } from './core/interfaces/IProjectile';\nimport { ExperienceOrb } from './entities/collectibles/ExperienceOrb';\nimport { SylphBloomsWeapon } from './weapons/SylphBloomsWeapon';\nimport { OrbitalWeapon } from './weapons/OrbitalWeapon';\nimport { CollisionDetection } from './systems/CollisionDetection';\nimport { WaveManager } from './managers/WaveManager';\nimport { SpriteManager } from './rendering/SpriteManager';\nimport { CameraSystem } from './rendering/CameraSystem';\nimport { InfiniteTileRenderer } from './rendering/InfiniteTileRenderer';\nimport { Particle } from './rendering/Particle';\nimport { InputManager } from './systems/InputManager';\nimport { useGameState } from \"../stores/useGameState\";\nimport { useAudio } from \"../stores/useAudio\";\nimport { WeaponEvolutionSystem } from './systems/WeaponEvolution';\nimport { ComboSystem } from './systems/ComboSystem';\nimport { PassiveItemManager } from './entities/collectibles/PassiveItem';\nimport { DamageNumberManager } from './rendering/DamageNumber';\nimport { BossLoot, generateBossLoot } from './entities/collectibles/BossLoot';\nimport { ComboSystem } from './systems/ComboSystem';\nimport { ScreenShakeSystem } from './rendering/ScreenShake';\n\nexport class GameEngine {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private player: Player | AssassinPlayer;\n  private enemies: Enemy[] = [];\n  private projectiles: IProjectile[] = [];\n  private enemyProjectiles: EnemyProjectile[] = [];\n  private particles: Particle[] = [];\n  private experienceOrbs: ExperienceOrb[] = [];\n  private waveManager: WaveManager;\n  private collisionDetection: CollisionDetection;\n  private inputManager: InputManager;\n  private animationFrameId: number | null = null;\n  private lastTime = 0;\n  private lastMuteState = false;\n  private lastRestartState = false;\n  private lastPauseState = false;\n  private lastWeapon1State = false;\n  private lastWeapon2State = false;\n  private lastWeapon3State = false;\n  private lastWeapon4State = false;\n  private lastWeapon5State = false;\n  private spriteManager: SpriteManager;\n  private infiniteTileRenderer: InfiniteTileRenderer;\n  private camera: CameraSystem;\n\n  private currentBoss: BossEnemy | null = null;\n  private isBossActive: boolean = false;\n  private bossDefeatedCelebrationTimer: number = 0;\n  private weaponEvolution: WeaponEvolutionSystem;\n  private passiveItems: PassiveItemManager;\n  private damageNumbers: DamageNumberManager;\n  private bossLoot: BossLoot[] = [];\n  private comboSystem: ComboSystem;\n  private gameStartTime: number = 0;\n  private totalDamageDealt: number = 0;\n  private totalDamageTaken: number = 0;\n  private screenShake: ScreenShakeSystem;\n\n  constructor(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n    this.gameStartTime = Date.now();\n    this.canvas = canvas;\n    this.ctx = ctx;\n\n    this.player = new Player(canvas.width / 2, canvas.height / 2);\n    this.waveManager = new WaveManager();\n    this.collisionDetection = new CollisionDetection();\n    this.inputManager = new InputManager();\n    this.spriteManager = SpriteManager.getInstance();\n    this.infiniteTileRenderer = new InfiniteTileRenderer();\n    this.camera = new CameraSystem(canvas.width, canvas.height);\n    this.weaponEvolution = new WeaponEvolutionSystem();\n    this.passiveItems = new PassiveItemManager();\n    this.damageNumbers = new DamageNumberManager();\n    this.comboSystem = new ComboSystem();\n    this.screenShake = new ScreenShakeSystem();\n\n    this.setupBossCallbacks();\n    this.setupInput();\n    this.initializeSprites();\n  }\n\n  private setupBossCallbacks() {\n    this.waveManager.setOnBossWarning(() => {\n      const wave = this.waveManager.getCurrentWave();\n      const bossTypes = [\"necromancer\", \"vampire_lord\", \"ancient_golem\"];\n      const bossIndex = Math.floor((wave / 5) - 1) % bossTypes.length;\n      \n      const bossInfo = {\n        necromancer: { name: \"The Necromancer\", description: \"Master of death, commands the undead\" },\n        vampire_lord: { name: \"Vampire Lord\", description: \"Ancient bloodsucker with supernatural speed\" },\n        ancient_golem: { name: \"Ancient Golem\", description: \"Stone guardian with impenetrable defense\" }\n      };\n      \n      const info = bossInfo[bossTypes[bossIndex] as keyof typeof bossInfo];\n      const gameState = useGameState.getState();\n      gameState.triggerBossWarning(info.name, info.description);\n    });\n\n    this.waveManager.setOnBossSpawn((boss: BossEnemy) => {\n      this.currentBoss = boss;\n      this.isBossActive = true;\n      \n      const gameState = useGameState.getState();\n      gameState.setBossActive(true);\n      gameState.setBossInfo(boss.getBossName(), boss.getBossDescription());\n      gameState.updateBossHealth(boss.getHealth(), boss.getMaxHealth());\n      \n      console.log(`Boss spawned: ${boss.getBossName()}`);\n    });\n  }\n\n  private setupInput() {\n    const handleStart = () => {\n      const gameState = useGameState.getState();\n      if (gameState.phase === \"ready\") {\n        gameState.start();\n        const audioState = useAudio.getState();\n        if (audioState.backgroundMusic && !audioState.isMuted) {\n          audioState.backgroundMusic.play().catch(console.warn);\n        }\n      }\n    };\n\n    const handleRestart = (e: KeyboardEvent) => {\n      if (e.key === \"r\" || e.key === \"R\") {\n        const gameState = useGameState.getState();\n        if (gameState.phase === \"gameOver\" || gameState.phase === \"playing\") {\n          gameState.restart();\n          this.resetGame();\n        }\n      }\n    };\n\n    const handleSoundToggle = (e: KeyboardEvent) => {\n      if (e.key === \"m\" || e.key === \"M\") {\n        const audioState = useAudio.getState();\n        audioState.toggleMute();\n\n        if (audioState.backgroundMusic) {\n          if (audioState.isMuted) {\n            audioState.backgroundMusic.pause();\n          } else {\n            audioState.backgroundMusic.play().catch(console.warn);\n          }\n        }\n      }\n    };\n\n    const handleWindowBlur = () => {\n      const gameState = useGameState.getState();\n      if (gameState.phase === \"playing\") {\n        gameState.pause();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleStart);\n    document.addEventListener(\"click\", handleStart);\n    document.addEventListener(\"keydown\", handleRestart);\n    document.addEventListener(\"keydown\", handleSoundToggle);\n    window.addEventListener(\"blur\", handleWindowBlur);\n\n    this.inputManager.addEventListeners();\n  }\n\n  private resetGame() {\n    this.setupPlayer();\n    this.enemies = [];\n    this.projectiles = [];\n    this.enemyProjectiles = [];\n    this.particles = [];\n    this.experienceOrbs = [];\n    this.bossLoot = [];\n    this.currentBoss = null;\n    this.isBossActive = false;\n    this.bossDefeatedCelebrationTimer = 0;\n    this.waveManager.reset();\n    \n    const gameState = useGameState.getState();\n    gameState.setBossActive(false);\n    gameState.hideBossWarning();\n  }\n\n  public start() {\n    this.gameLoop(0);\n  }\n\n  public stop() {\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n    this.inputManager.removeEventListeners();\n  }\n\n  private gameLoop = (currentTime: number) => {\n    const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.02);\n    this.lastTime = currentTime;\n\n    const gameState = useGameState.getState();\n\n    if (gameState.selectedCharacter && gameState.phase === \"playing\") {\n      const isAssassin = gameState.selectedCharacter.id === \"assassin\";\n      const hasAssassinPlayer = this.player instanceof AssassinPlayer;\n\n      if (isAssassin && !hasAssassinPlayer) {\n        this.setupPlayer();\n      } else if (!isAssassin && hasAssassinPlayer) {\n        this.setupPlayer();\n      }\n    }\n\n    if (gameState.phase === \"playing\") {\n      this.update(deltaTime);\n    }\n\n    this.render(deltaTime);\n    this.animationFrameId = requestAnimationFrame(this.gameLoop);\n  };\n\n  public getPlayer() {\n    return this.player;\n  }\n\n  private update(deltaTime: number) {\n    const gameState = useGameState.getState();\n    const input = this.inputManager.getInput();\n\n    // Handle pause\n    if (input.pause && !this.lastPauseState) {\n      if (gameState.phase === \"playing\") {\n        gameState.pause();\n      } else if (gameState.phase === \"paused\") {\n        gameState.resume();\n      }\n    }\n    this.lastPauseState = input.pause;\n\n    // Don't update game if paused or game over\n    if (gameState.phase === \"paused\" || gameState.phase === \"gameOver\") {\n      return;\n    }\n\n    // Check for player death\n    if (gameState.health <= 0 && gameState.phase === \"playing\") {\n      this.handlePlayerDeath();\n      return;\n    }\n\n    this.player.update(deltaTime, input, this.canvas.width, this.canvas.height, this.infiniteTileRenderer);\n\n    if (this.player instanceof AssassinPlayer) {\n      this.player.setTileRenderer(this.infiniteTileRenderer);\n      this.player.updateSpiders(deltaTime, this.enemies, this.player.getPosition());\n      this.handleSpiderKills();\n    }\n\n    this.camera.update(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, deltaTime);\n\n    if (this.camera.width !== this.canvas.width || this.camera.height !== this.canvas.height) {\n      this.camera.setSize(this.canvas.width, this.canvas.height);\n    }\n\n    this.waveManager.update(deltaTime);\n    const playerPos = this.player.getPosition();\n    const newEnemies = this.waveManager.spawnEnemies(this.canvas.width, this.canvas.height, playerPos);\n    \n    newEnemies.forEach(enemy => {\n      if (enemy instanceof BossEnemy) {\n        this.currentBoss = enemy;\n        this.isBossActive = true;\n      }\n      this.enemies.push(enemy);\n    });\n\n    gameState.setWave(this.waveManager.getCurrentWave());\n\n    this.enemies.forEach(enemy => {\n      enemy.update(deltaTime, this.player.getPosition());\n      \n      if (enemy instanceof RangedEnemy) {\n        const newProjectiles = enemy.getProjectiles();\n        this.enemyProjectiles.push(...newProjectiles);\n      }\n    });\n\n    if (this.currentBoss && this.currentBoss.isAlive()) {\n      gameState.updateBossHealth(this.currentBoss.getHealth(), this.currentBoss.getMaxHealth());\n      \n      const minionSpawns = this.currentBoss.getMinionSpawnQueue();\n      minionSpawns.forEach(spawn => {\n        const minion = new Enemy(spawn.x, spawn.y, \"basic\");\n        this.enemies.push(minion);\n      });\n\n      if (this.currentBoss.isGroundPounding()) {\n        const groundPoundRadius = this.currentBoss.getGroundPoundRadius();\n        const groundPoundDamage = this.currentBoss.getGroundPoundDamage();\n        \n        const dx = this.player.x - this.currentBoss.x;\n        const dy = this.player.y - this.currentBoss.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance <= groundPoundRadius) {\n          gameState.takeDamage(groundPoundDamage * deltaTime);\n          this.screenShake.trigger(15, 0.4);\n        }\n      }\n    }\n\n    const newProjectiles = this.player.fireWeapon(deltaTime);\n    this.projectiles.push(...newProjectiles);\n\n    if (!(this.player instanceof AssassinPlayer)) {\n      const weapon = this.player.getWeapon();\n      if (weapon instanceof SylphBloomsWeapon) {\n        weapon.setTileRenderer(this.infiniteTileRenderer);\n        weapon.update(deltaTime, this.enemies, this.player.x, this.player.y);\n      }\n    }\n\n    this.projectiles = this.projectiles.filter(projectile => {\n      projectile.update(deltaTime);\n      return projectile.isAlive();\n    });\n\n    this.enemyProjectiles = this.enemyProjectiles.filter(projectile => {\n      projectile.update(deltaTime);\n      return projectile.isAlive();\n    });\n\n    this.particles = this.particles.filter(particle => {\n      particle.update(deltaTime);\n      return particle.isAlive();\n    });\n\n    this.damageNumbers.update(deltaTime);\n    \n    this.comboSystem.update(deltaTime);\n    gameState.setCombo(\n      this.comboSystem.getComboCount(), \n      this.comboSystem.getComboMultiplier(),\n      this.comboSystem.getTimeRemaining()\n    );\n    \n    this.screenShake.update(deltaTime);\n\n    this.passiveItems.applyEffects(this.player);\n\n    this.experienceOrbs = this.experienceOrbs.filter(orb => {\n      orb.update(deltaTime, this.player.getPosition());\n      return !orb.isExpired();\n    });\n\n    this.bossLoot = this.bossLoot.filter(loot => {\n      loot.update(deltaTime, this.player.getPosition());\n      \n      if (loot.canBeCollected(this.player.getPosition())) {\n        loot.collect();\n        gameState.addCurrency(100);\n        \n        if (!audioState.isMuted) {\n          audioState.playSuccess();\n        }\n        \n        console.log(`Collected boss loot: ${loot.getName()}`);\n        return false;\n      }\n      \n      return !loot.isCollected();\n    });\n\n    this.handleCollisions();\n\n    if (this.bossDefeatedCelebrationTimer > 0) {\n      this.bossDefeatedCelebrationTimer -= deltaTime;\n      \n      if (Math.random() < 0.3) {\n        this.createCelebrationParticles();\n      }\n    }\n\n    this.handleSplittingEnemies();\n\n    this.enemies = this.enemies.filter(enemy => enemy.isAlive());\n\n    if (this.currentBoss && !this.currentBoss.isAlive() && this.isBossActive) {\n      this.handleBossDefeated();\n    }\n  }\n\n  private handleSplittingEnemies() {\n    const newSplitEnemies: SplittingEnemy[] = [];\n    \n    this.enemies.forEach(enemy => {\n      if (enemy instanceof SplittingEnemy && !enemy.isAlive()) {\n        const spawns = enemy.getSpawnQueue();\n        newSplitEnemies.push(...spawns);\n      }\n    });\n    \n    newSplitEnemies.forEach(splitEnemy => {\n      this.enemies.push(splitEnemy as unknown as Enemy);\n      \n      for (let i = 0; i < 3; i++) {\n        this.particles.push(new Particle(\n          splitEnemy.x + (Math.random() - 0.5) * 20,\n          splitEnemy.y + (Math.random() - 0.5) * 20,\n          (Math.random() - 0.5) * 80,\n          (Math.random() - 0.5) * 80,\n          \"#44ff44\",\n          0.5\n        ));\n      }\n    });\n  }\n\n  private handleBossDefeated() {\n    const gameState = useGameState.getState();\n    const audioState = useAudio.getState();\n    \n    const bossScore = this.currentBoss?.getScoreValue() || 500;\n    const bonusXP = bossScore * 2;\n    \n    gameState.addScore(bossScore);\n    gameState.addExperience(bonusXP);\n    \n    this.experienceOrbs.push(new ExperienceOrb(this.currentBoss!.x, this.currentBoss!.y, bonusXP));\n    \n    // Generate boss loot\n    const loot = generateBossLoot(this.currentBoss!.x, this.currentBoss!.y, this.currentBoss!.getBossType());\n    this.bossLoot.push(...loot);\n    \n    for (let i = 0; i < 30; i++) {\n      this.particles.push(new Particle(\n        this.currentBoss!.x + (Math.random() - 0.5) * 100,\n        this.currentBoss!.y + (Math.random() - 0.5) * 100,\n        (Math.random() - 0.5) * 300,\n        (Math.random() - 0.5) * 300,\n        Math.random() > 0.5 ? \"#ffd700\" : \"#ff6600\",\n        2.0\n      ));\n    }\n    \n    this.screenShake.trigger(20, 0.8);\n    this.bossDefeatedCelebrationTimer = 3;\n    \n    if (!audioState.isMuted) {\n      audioState.playSuccess();\n    }\n    \n    this.waveManager.onBossDefeated();\n    gameState.setBossActive(false);\n    gameState.addBossKill();\n    \n    this.currentBoss = null;\n    this.isBossActive = false;\n    \n    console.log(\"Boss defeated! Bonus XP and score awarded!\");\n  }\n\n  private handlePlayerDeath() {\n    const gameState = useGameState.getState();\n    const audioState = useAudio.getState();\n    \n    // Create death particles\n    for (let i = 0; i < 50; i++) {\n      this.particles.push(new Particle(\n        this.player.x + (Math.random() - 0.5) * 60,\n        this.player.y + (Math.random() - 0.5) * 60,\n        (Math.random() - 0.5) * 200,\n        (Math.random() - 0.5) * 200,\n        Math.random() > 0.5 ? \"#ff0000\" : \"#880000\",\n        1.5\n      ));\n    }\n    \n    // Record statistics\n    const playTime = Math.floor((Date.now() - this.gameStartTime) / 1000);\n    const characterId = gameState.selectedCharacter?.id || \"guardian\";\n    \n    const { StatisticsSystem } = require('./systems/StatisticsSystem');\n    StatisticsSystem.recordRun({\n      characterId,\n      kills: gameState.totalKills,\n      wave: gameState.wave,\n      level: gameState.level,\n      score: gameState.score,\n      playTime,\n      damageTaken: this.totalDamageTaken,\n      damageDealt: this.totalDamageDealt,\n      experienceGained: gameState.experience,\n      maxCombo: gameState.maxCombo,\n      bossesDefeated: gameState.bossesDefeated\n    });\n    \n    // Save persistent progression\n    const { PersistentProgressionSystem } = require('./systems/PersistentProgressionSystem');\n    PersistentProgressionSystem.recordRunEnd(\n      gameState.score,\n      gameState.wave,\n      gameState.totalKills,\n      gameState.maxCombo,\n      gameState.bossesDefeated,\n      playTime\n    );\n    \n    // Add currency based on performance\n    const currencyEarned = Math.floor(gameState.score / 100) + (gameState.wave * 10);\n    PersistentProgressionSystem.addCurrency(currencyEarned);\n    \n    // Play death sound\n    if (!audioState.isMuted) {\n      audioState.playPlayerHurt();\n    }\n    \n    // Trigger game over\n    gameState.end();\n  }\n\n  private createCelebrationParticles() {\n    const colors = [\"#ffd700\", \"#ff6600\", \"#00ff00\", \"#00ffff\", \"#ff00ff\"];\n    const x = this.player.x + (Math.random() - 0.5) * 400;\n    const y = this.player.y + (Math.random() - 0.5) * 400;\n    \n    this.particles.push(new Particle(\n      x, y,\n      (Math.random() - 0.5) * 100,\n      (Math.random() - 0.5) * 100 - 50,\n      colors[Math.floor(Math.random() * colors.length)],\n      1.5\n    ));\n  }\n\n  private handleCollisions() {\n    const gameState = useGameState.getState();\n    const audioState = useAudio.getState();\n\n    this.projectiles.forEach(projectile => {\n      if (!projectile.isAlive()) return;\n\n      this.enemies.forEach(enemy => {\n        if (!enemy.isAlive()) return;\n\n        if (this.collisionDetection.checkCollision(projectile, enemy)) {\n          if (!this.collisionDetection.canDamageEnemy(enemy)) {\n            this.createHitParticles(enemy.x, enemy.y, \"#0088ff\");\n            return;\n          }\n          \n          const damage = projectile.getDamage();\n          enemy.takeDamage(damage);\n          this.totalDamageDealt += damage;\n          projectile.addHit();\n          this.createHitParticles(enemy.x, enemy.y);\n          this.damageNumbers.addDamageNumber(enemy.x, enemy.y - 20, damage, false);\n\n          if (!audioState.isMuted) {\n            audioState.playHit();\n          }\n\n          if (!enemy.isAlive()) {\n            if (!(enemy instanceof BossEnemy)) {\n              this.comboSystem.addKill();\n              gameState.addKill();\n              const scoreWithCombo = Math.floor(enemy.getScoreValue() * this.comboSystem.getComboMultiplier());\n              gameState.addScore(scoreWithCombo);\n              this.createDeathParticles(enemy.x, enemy.y);\n              const expValue = Math.max(1, Math.floor(enemy.getScoreValue() / 2));\n              this.experienceOrbs.push(new ExperienceOrb(enemy.x, enemy.y, expValue));\n            }\n          }\n        }\n      });\n    });\n\n    this.enemyProjectiles.forEach(projectile => {\n      if (!projectile.isAlive()) return;\n\n      if (this.collisionDetection.checkEnemyProjectilePlayerCollision(projectile, this.player)) {\n        gameState.takeDamage(projectile.getDamage());\n        projectile.markForRemoval();\n        this.createHitParticles(this.player.x, this.player.y, \"#cc00cc\");\n\n        if (!audioState.isMuted) {\n          audioState.playHit();\n        }\n      }\n    });\n\n    this.enemies.forEach(enemy => {\n      if (!enemy.isAlive()) return;\n\n      if (this.collisionDetection.checkCollision(this.player, enemy)) {\n        const damage = enemy.getDamage();\n        this.totalDamageTaken += damage;\n        gameState.takeDamage(damage);\n        \n        this.screenShake.trigger(5, 0.2);\n\n        const dx = enemy.x - this.player.x;\n        const dy = enemy.y - this.player.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance > 0) {\n          enemy.x += (dx / distance) * 30;\n          enemy.y += (dy / distance) * 30;\n        }\n\n        this.createHitParticles(this.player.x, this.player.y, \"#ff4444\");\n      }\n    });\n\n    const orbitalWeapons = this.player.getOrbitalWeapons();\n    orbitalWeapons.forEach(orbital => {\n      this.enemies.forEach(enemy => {\n        if (!enemy.isAlive()) return;\n\n        if (this.collisionDetection.checkCollision(orbital, enemy)) {\n          if (!this.collisionDetection.canDamageEnemy(enemy)) {\n            this.createHitParticles(orbital.x, orbital.y, \"#0088ff\");\n            return;\n          }\n          \n          const damage = orbital.dealDamage();\n          if (damage > 0) {\n            enemy.takeDamage(damage);\n            this.createHitParticles(orbital.x, orbital.y, \"#4444ff\");\n\n            if (!audioState.isMuted) {\n              audioState.playHit();\n            }\n\n            if (!enemy.isAlive() && !(enemy instanceof BossEnemy)) {\n              this.comboSystem.addKill();\n              gameState.addKill();\n              const scoreWithCombo = Math.floor(enemy.getScoreValue() * this.comboSystem.getComboMultiplier());\n              gameState.addScore(scoreWithCombo);\n              this.createDeathParticles(enemy.x, enemy.y);\n              const expValue = Math.max(1, Math.floor(enemy.getScoreValue() / 2));\n              this.experienceOrbs.push(new ExperienceOrb(enemy.x, enemy.y, expValue));\n            }\n          }\n        }\n      });\n    });\n\n    if (!(this.player instanceof AssassinPlayer)) {\n      const weapon = this.player.getWeapon();\n      if (weapon instanceof SylphBloomsWeapon) {\n        const orbCollisions = weapon.checkCollisions(this.enemies);\n\n        orbCollisions.forEach(collision => {\n          this.createHitParticles(collision.orbX, collision.orbY);\n\n          if (!audioState.isMuted) {\n            audioState.playHit();\n          }\n\n          if (!collision.enemy.isAlive() && !(collision.enemy instanceof BossEnemy)) {\n            this.comboSystem.addKill();\n            gameState.addKill();\n            const scoreWithCombo = Math.floor(collision.enemy.getScoreValue() * this.comboSystem.getComboMultiplier());\n            gameState.addScore(scoreWithCombo);\n            this.createDeathParticles(collision.enemy.x, collision.enemy.y);\n            const expValue = Math.max(1, Math.floor(collision.enemy.getScoreValue() / 2));\n            this.experienceOrbs.push(new ExperienceOrb(collision.enemy.x, collision.enemy.y, expValue));\n          }\n        });\n      }\n    }\n\n    this.experienceOrbs = this.experienceOrbs.filter(orb => {\n      if (orb.canBeCollected(this.player.getPosition())) {\n        gameState.addExperience(orb.getValue());\n\n        if (!audioState.isMuted) {\n          audioState.playSuccess();\n        }\n\n        return false;\n      }\n      return true;\n    });\n  }\n\n  private createHitParticles(x: number, y: number, color = \"#ffff44\") {\n    for (let i = 0; i < 3; i++) {\n      this.particles.push(new Particle(\n        x + (Math.random() - 0.5) * 20,\n        y + (Math.random() - 0.5) * 20,\n        (Math.random() - 0.5) * 100,\n        (Math.random() - 0.5) * 100,\n        color,\n        0.5\n      ));\n    }\n  }\n\n  private createDeathParticles(x: number, y: number) {\n    for (let i = 0; i < 6; i++) {\n      this.particles.push(new Particle(\n        x + (Math.random() - 0.5) * 30,\n        y + (Math.random() - 0.5) * 30,\n        (Math.random() - 0.5) * 150,\n        (Math.random() - 0.5) * 150,\n        Math.random() > 0.5 ? \"#ff4444\" : \"#ff8844\",\n        1.0\n      ));\n    }\n  }\n\n  private handleSpiderKills() {\n    const gameState = useGameState.getState();\n    const audioState = useAudio.getState();\n\n    const deadEnemies = this.enemies.filter(enemy => !enemy.isAlive());\n\n    deadEnemies.forEach(enemy => {\n      const spiders = (this.player as AssassinPlayer).getSpiders();\n      const isSpiderKill = spiders.some(spider => {\n        return spider.isAttached && Math.abs(spider.x - enemy.x) < 5 && Math.abs(spider.y - enemy.y) < 5;\n      });\n\n      if (isSpiderKill && !(enemy instanceof BossEnemy)) {\n        this.comboSystem.addKill();\n        gameState.addKill();\n        const scoreWithCombo = Math.floor(enemy.getScoreValue() * this.comboSystem.getComboMultiplier());\n        gameState.addScore(scoreWithCombo);\n        this.createDeathParticles(enemy.x, enemy.y);\n\n        if (!audioState.isMuted) {\n          audioState.playHit();\n        }\n\n        const expValue = Math.max(1, Math.floor(enemy.getScoreValue() / 2));\n        this.experienceOrbs.push(new ExperienceOrb(enemy.x, enemy.y, expValue));\n      }\n    });\n  }\n\n  private render(deltaTime: number) {\n    this.ctx.fillStyle = \"#1a1a1a\";\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.infiniteTileRenderer.render(this.ctx, {\n      x: this.camera.x,\n      y: this.camera.y,\n      width: this.camera.width,\n      height: this.camera.height\n    });\n\n    const gameState = useGameState.getState();\n\n    if (gameState.phase !== \"playing\") return;\n\n    this.ctx.save();\n    const shakeOffset = this.screenShake.getOffset();\n    this.ctx.translate(-this.camera.x + shakeOffset.x, -this.camera.y + shakeOffset.y);\n\n    this.particles.forEach(particle => {\n      particle.render(this.ctx);\n    });\n\n    this.experienceOrbs.forEach(orb => {\n      orb.render(this.ctx);\n    });\n\n    this.bossLoot.forEach(loot => {\n      loot.render(this.ctx);\n    });\n\n    this.projectiles.forEach(projectile => {\n      projectile.render(this.ctx, 0, 0);\n    });\n\n    this.enemyProjectiles.forEach(projectile => {\n      projectile.render(this.ctx);\n    });\n\n    if (!(this.player instanceof AssassinPlayer)) {\n      const weapon = this.player.getWeapon();\n      if (weapon instanceof SylphBloomsWeapon) {\n        weapon.render(this.ctx, this.camera.x, this.camera.y);\n      }\n    }\n\n    this.player.render(this.ctx, deltaTime);\n\n    this.enemies.forEach(enemy => {\n      if (enemy.isAlive()) {\n        enemy.render(this.ctx, deltaTime);\n      }\n    });\n\n    this.damageNumbers.render(this.ctx);\n\n    this.ctx.restore();\n\n    if (process.env.NODE_ENV === \"development\") {\n      this.ctx.fillStyle = \"#ffffff\";\n      this.ctx.font = \"12px monospace\";\n      this.ctx.fillText(`Enemies: ${this.enemies.length}`, 10, this.canvas.height - 100);\n      this.ctx.fillText(`Projectiles: ${this.projectiles.length}`, 10, this.canvas.height - 80);\n      this.ctx.fillText(`Enemy Projectiles: ${this.enemyProjectiles.length}`, 10, this.canvas.height - 60);\n      this.ctx.fillText(`Particles: ${this.particles.length}`, 10, this.canvas.height - 40);\n      this.ctx.fillText(`Boss Active: ${this.isBossActive}`, 10, this.canvas.height - 20);\n    }\n  }\n\n  private async initializeSprites() {\n    await this.spriteManager.loadAllSprites();\n  }\n\n  private setupPlayer() {\n    const gameState = useGameState.getState();\n    const character = gameState.selectedCharacter;\n\n    if (character?.id === \"assassin\") {\n      this.player = new AssassinPlayer(this.canvas.width / 2, this.canvas.height / 2);\n    } else {\n      this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);\n    }\n  }\n}\n","path":null,"size_bytes":27935,"size_tokens":null},"client/src/lib/game/services/GameStateService.ts":{"content":"\nimport { IGameStateService } from './IGameStateService';\nimport { useGameState } from '../../stores/useGameState';\n\nexport class GameStateService implements IGameStateService {\n  public addScore(points: number): void {\n    useGameState.getState().addScore(points);\n  }\n\n  public addExperience(amount: number): void {\n    useGameState.getState().addExperience(amount);\n  }\n\n  public takeDamage(amount: number): void {\n    useGameState.getState().takeDamage(amount);\n  }\n\n  public setWave(wave: number): void {\n    useGameState.getState().setWave(wave);\n  }\n\n  public getCurrentPhase(): string {\n    return useGameState.getState().phase;\n  }\n}\n","path":null,"size_bytes":643,"size_tokens":null},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Portal>\n    <TooltipPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </TooltipPrimitive.Portal>\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","path":null,"size_bytes":1217,"size_tokens":null},"client/src/lib/game/weapons/PoisonCloudWeapon.ts":{"content":"\nimport { BaseWeapon } from \"../core/base/BaseWeapon\";\nimport { IProjectile } from \"../core/interfaces/IProjectile\";\n\ninterface PoisonCloud {\n  x: number;\n  y: number;\n  radius: number;\n  lifetime: number;\n  maxLifetime: number;\n  damage: number;\n}\n\nexport class PoisonCloudWeapon extends BaseWeapon {\n  private clouds: PoisonCloud[] = [];\n  private spawnTimer: number = 0;\n  private spawnInterval: number = 3;\n  private cloudDamage: number = 5;\n  private cloudRadius: number = 100;\n  private cloudLifetime: number = 5;\n  private maxClouds: number = 3;\n\n  constructor() {\n    super();\n    this.damage = 5;\n    this.fireRate = 0.3;\n  }\n\n  public update(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.spawnTimer += deltaTime;\n\n    if (this.spawnTimer >= this.spawnInterval && this.clouds.length < this.maxClouds) {\n      const angle = Math.random() * Math.PI * 2;\n      const distance = 100 + Math.random() * 100;\n      \n      this.clouds.push({\n        x: playerX + Math.cos(angle) * distance,\n        y: playerY + Math.sin(angle) * distance,\n        radius: this.cloudRadius,\n        lifetime: this.cloudLifetime,\n        maxLifetime: this.cloudLifetime,\n        damage: this.cloudDamage\n      });\n\n      this.spawnTimer = 0;\n    }\n\n    this.clouds = this.clouds.filter(cloud => {\n      cloud.lifetime -= deltaTime;\n      \n      enemies.forEach(enemy => {\n        if (!enemy.isAlive()) return;\n        const dx = enemy.x - cloud.x;\n        const dy = enemy.y - cloud.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= cloud.radius) {\n          enemy.takeDamage(cloud.damage * deltaTime);\n        }\n      });\n\n      return cloud.lifetime > 0;\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    this.clouds.forEach(cloud => {\n      const alpha = cloud.lifetime / cloud.maxLifetime;\n      \n      ctx.save();\n      ctx.globalAlpha = alpha * 0.5;\n      \n      const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius);\n      gradient.addColorStop(0, \"rgba(0, 255, 0, 0.8)\");\n      gradient.addColorStop(0.5, \"rgba(0, 200, 0, 0.4)\");\n      gradient.addColorStop(1, \"rgba(0, 150, 0, 0)\");\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);\n      ctx.fill();\n\n      ctx.restore();\n    });\n  }\n\n  public fire(x: number, y: number, direction: { x: number; y: number }): IProjectile[] {\n    return [];\n  }\n\n  public upgrade(): void {\n    this.cloudDamage += 2;\n    this.cloudRadius += 10;\n    this.maxClouds = Math.min(6, this.maxClouds + 1);\n    this.cloudLifetime += 0.5;\n  }\n\n  public getType(): string {\n    return \"poison_cloud\";\n  }\n\n  public getClouds(): PoisonCloud[] {\n    return this.clouds;\n  }\n}\n","path":null,"size_bytes":2834,"size_tokens":null},"client/src/lib/game/weapons/BoomerangWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { WeaponRarity } from \"./WeaponRarity\";\n\ninterface Boomerang {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  startX: number;\n  startY: number;\n  maxDistance: number;\n  returning: boolean;\n  hitEnemies: Set<Enemy>;\n  rotation: number;\n  active: boolean;\n}\n\nexport class BoomerangWeapon {\n  private damage: number;\n  private cooldown: number;\n  private maxDistance: number;\n  private speed: number;\n  private lastFireTime: number = 0;\n  private activeBoomerangs: Boomerang[] = [];\n  private level: number = 1;\n  private rarity: WeaponRarity = WeaponRarity.Common;\n  private evolved: boolean = false;\n  private boomerangCount: number = 1;\n  private hitCooldowns: Map<Enemy, number> = new Map();\n\n  constructor() {\n    this.damage = 15;\n    this.cooldown = 2.5;\n    this.maxDistance = 200;\n    this.speed = 350;\n  }\n\n  public update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number,\n    direction?: { x: number; y: number }\n  ): { enemy: Enemy; damage: number }[] {\n    this.lastFireTime += deltaTime;\n    const hits: { enemy: Enemy; damage: number }[] = [];\n\n    for (const [enemy, time] of this.hitCooldowns) {\n      this.hitCooldowns.set(enemy, time - deltaTime);\n      if (time - deltaTime <= 0) {\n        this.hitCooldowns.delete(enemy);\n      }\n    }\n\n    this.updateBoomerangs(deltaTime, playerX, playerY, enemies, hits);\n\n    if (this.lastFireTime >= this.getEffectiveCooldown() && this.activeBoomerangs.length === 0) {\n      this.lastFireTime = 0;\n      this.fireBoomerangs(playerX, playerY, direction);\n    }\n\n    return hits;\n  }\n\n  private fireBoomerangs(\n    playerX: number,\n    playerY: number,\n    direction?: { x: number; y: number }\n  ): void {\n    const count = this.evolved ? this.boomerangCount + 2 : this.boomerangCount;\n    const baseDir = direction || { x: 1, y: 0 };\n    const magnitude = Math.sqrt(baseDir.x * baseDir.x + baseDir.y * baseDir.y);\n    const normalizedDir = magnitude > 0 \n      ? { x: baseDir.x / magnitude, y: baseDir.y / magnitude }\n      : { x: 1, y: 0 };\n\n    for (let i = 0; i < count; i++) {\n      let angle = Math.atan2(normalizedDir.y, normalizedDir.x);\n      \n      if (count > 1) {\n        const spreadAngle = Math.PI / 4;\n        angle += spreadAngle * (i - (count - 1) / 2) / ((count - 1) / 2 || 1);\n      }\n\n      const vx = Math.cos(angle) * this.speed;\n      const vy = Math.sin(angle) * this.speed;\n\n      this.activeBoomerangs.push({\n        x: playerX,\n        y: playerY,\n        vx,\n        vy,\n        startX: playerX,\n        startY: playerY,\n        maxDistance: this.getEffectiveDistance(),\n        returning: false,\n        hitEnemies: new Set(),\n        rotation: 0,\n        active: true\n      });\n    }\n  }\n\n  private updateBoomerangs(\n    deltaTime: number,\n    playerX: number,\n    playerY: number,\n    enemies: Enemy[],\n    hits: { enemy: Enemy; damage: number }[]\n  ): void {\n    this.activeBoomerangs = this.activeBoomerangs.filter(boomerang => {\n      if (!boomerang.active) return false;\n\n      boomerang.rotation += deltaTime * 15;\n      boomerang.x += boomerang.vx * deltaTime;\n      boomerang.y += boomerang.vy * deltaTime;\n\n      const dx = boomerang.x - boomerang.startX;\n      const dy = boomerang.y - boomerang.startY;\n      const distanceTraveled = Math.sqrt(dx * dx + dy * dy);\n\n      if (!boomerang.returning && distanceTraveled >= boomerang.maxDistance) {\n        boomerang.returning = true;\n        boomerang.hitEnemies.clear();\n      }\n\n      if (boomerang.returning) {\n        const toPlayerX = playerX - boomerang.x;\n        const toPlayerY = playerY - boomerang.y;\n        const distToPlayer = Math.sqrt(toPlayerX * toPlayerX + toPlayerY * toPlayerY);\n        \n        if (distToPlayer < 20) {\n          boomerang.active = false;\n          return false;\n        }\n\n        const homingStrength = 8;\n        boomerang.vx += (toPlayerX / distToPlayer) * homingStrength;\n        boomerang.vy += (toPlayerY / distToPlayer) * homingStrength;\n\n        const currentSpeed = Math.sqrt(boomerang.vx * boomerang.vx + boomerang.vy * boomerang.vy);\n        if (currentSpeed > this.speed * 1.5) {\n          boomerang.vx = (boomerang.vx / currentSpeed) * this.speed * 1.5;\n          boomerang.vy = (boomerang.vy / currentSpeed) * this.speed * 1.5;\n        }\n      }\n\n      for (const enemy of enemies) {\n        if (!enemy.isAlive() || enemy.getHealth() <= 0) continue;\n        if (this.hitCooldowns.has(enemy)) continue;\n\n        const ex = enemy.x - boomerang.x;\n        const ey = enemy.y - boomerang.y;\n        const dist = Math.sqrt(ex * ex + ey * ey);\n\n        if (dist < 30) {\n          hits.push({ enemy, damage: this.getBaseDamage() });\n          this.hitCooldowns.set(enemy, 0.3);\n        }\n      }\n\n      return true;\n    });\n  }\n\n  private getEffectiveCooldown(): number {\n    let cd = this.cooldown - (this.level - 1) * 0.2;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        cd *= 0.9;\n        break;\n      case WeaponRarity.Legendary:\n        cd *= 0.8;\n        break;\n    }\n\n    if (this.evolved) {\n      cd *= 0.7;\n    }\n\n    return Math.max(cd, 0.5);\n  }\n\n  private getEffectiveDistance(): number {\n    let distance = this.maxDistance + (this.level - 1) * 30;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        distance *= 1.15;\n        break;\n      case WeaponRarity.Legendary:\n        distance *= 1.3;\n        break;\n    }\n\n    if (this.evolved) {\n      distance *= 1.5;\n    }\n\n    return distance;\n  }\n\n  private getBaseDamage(): number {\n    let baseDamage = this.damage + (this.level - 1) * 4;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        baseDamage *= 1.25;\n        break;\n      case WeaponRarity.Legendary:\n        baseDamage *= 1.5;\n        break;\n    }\n\n    if (this.evolved) {\n      baseDamage *= 2;\n    }\n\n    return Math.floor(baseDamage);\n  }\n\n  public render(\n    ctx: CanvasRenderingContext2D,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    for (const boomerang of this.activeBoomerangs) {\n      if (!boomerang.active) continue;\n      this.renderBoomerang(ctx, boomerang, cameraX, cameraY);\n    }\n  }\n\n  private renderBoomerang(\n    ctx: CanvasRenderingContext2D,\n    boomerang: Boomerang,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    const screenX = boomerang.x - cameraX;\n    const screenY = boomerang.y - cameraY;\n\n    ctx.save();\n    ctx.translate(screenX, screenY);\n    ctx.rotate(boomerang.rotation);\n\n    const baseColor = this.evolved ? \"#FFD700\" : \"#8B4513\";\n    const glowColor = this.evolved ? \"#FFA500\" : \"#D2691E\";\n\n    ctx.shadowColor = glowColor;\n    ctx.shadowBlur = this.evolved ? 15 : 8;\n\n    ctx.fillStyle = baseColor;\n    ctx.beginPath();\n\n    const size = this.evolved ? 20 : 15;\n    ctx.moveTo(-size, -size / 4);\n    ctx.quadraticCurveTo(0, -size / 2, size, -size / 4);\n    ctx.quadraticCurveTo(size + size / 3, 0, size, size / 4);\n    ctx.quadraticCurveTo(0, size / 2, -size, size / 4);\n    ctx.quadraticCurveTo(-size - size / 3, 0, -size, -size / 4);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = glowColor;\n    ctx.beginPath();\n    ctx.arc(0, 0, size / 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (this.evolved) {\n      ctx.strokeStyle = \"#FFFFFF\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  public upgrade(): void {\n    this.level = Math.min(this.level + 1, 5);\n    this.damage += 4;\n    this.maxDistance += 30;\n    if (this.level >= 3 && this.boomerangCount < 2) {\n      this.boomerangCount = 2;\n    }\n    if (this.level >= 5 && this.boomerangCount < 3) {\n      this.boomerangCount = 3;\n    }\n  }\n\n  public evolve(): void {\n    if (this.level >= 5 && !this.evolved) {\n      this.evolved = true;\n      this.damage *= 2;\n      this.boomerangCount += 2;\n      this.speed *= 1.3;\n    }\n  }\n\n  public getLevel(): number {\n    return this.level;\n  }\n\n  public isEvolved(): boolean {\n    return this.evolved;\n  }\n\n  public setRarity(rarity: WeaponRarity): void {\n    this.rarity = rarity;\n  }\n\n  public getRarity(): WeaponRarity {\n    return this.rarity;\n  }\n\n  public getName(): string {\n    return this.evolved ? \"Glaive Storm\" : \"Boomerang\";\n  }\n\n  public getDescription(): string {\n    return this.evolved \n      ? \"Multiple razor-sharp glaives tear through enemies\"\n      : \"A returning weapon that hits enemies twice\";\n  }\n}\nimport { BaseWeapon } from \"../core/base/BaseWeapon\";\nimport { IProjectile } from \"../core/interfaces/IProjectile\";\n\ninterface Boomerang {\n  x: number;\n  y: number;\n  angle: number;\n  distance: number;\n  maxDistance: number;\n  returning: boolean;\n  damage: number;\n  speed: number;\n  hitEnemies: Set<any>;\n}\n\nexport class BoomerangWeapon extends BaseWeapon {\n  private boomerangs: Boomerang[] = [];\n  private throwCooldown: number = 2;\n  private throwTimer: number = 0;\n  private boomerangCount: number = 1;\n  private boomerangDamage: number = 25;\n  private maxDistance: number = 300;\n  private speed: number = 400;\n\n  constructor() {\n    super(25, 0.5, 400);\n    this.damage = 25;\n  }\n\n  public update(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.throwTimer += deltaTime;\n\n    if (this.throwTimer >= this.throwCooldown) {\n      for (let i = 0; i < this.boomerangCount; i++) {\n        const angle = (Math.PI * 2 / this.boomerangCount) * i;\n        this.boomerangs.push({\n          x: playerX,\n          y: playerY,\n          angle,\n          distance: 0,\n          maxDistance: this.maxDistance,\n          returning: false,\n          damage: this.boomerangDamage,\n          speed: this.speed,\n          hitEnemies: new Set()\n        });\n      }\n      this.throwTimer = 0;\n    }\n\n    this.boomerangs = this.boomerangs.filter(boomerang => {\n      const moveDistance = boomerang.speed * deltaTime;\n\n      if (!boomerang.returning) {\n        boomerang.distance += moveDistance;\n        if (boomerang.distance >= boomerang.maxDistance) {\n          boomerang.returning = true;\n        }\n      } else {\n        boomerang.distance -= moveDistance;\n        if (boomerang.distance <= 0) {\n          return false;\n        }\n      }\n\n      boomerang.x = playerX + Math.cos(boomerang.angle) * boomerang.distance;\n      boomerang.y = playerY + Math.sin(boomerang.angle) * boomerang.distance;\n\n      enemies.forEach((enemy: any) => {\n        if (!enemy.isAlive() || boomerang.hitEnemies.has(enemy)) return;\n\n        const dx = enemy.x - boomerang.x;\n        const dy = enemy.y - boomerang.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 30) {\n          enemy.takeDamage(boomerang.damage);\n          boomerang.hitEnemies.add(enemy);\n        }\n      });\n\n      return true;\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    this.boomerangs.forEach(boomerang => {\n      ctx.save();\n\n      ctx.translate(boomerang.x, boomerang.y);\n      ctx.rotate(boomerang.distance * 0.05);\n\n      ctx.fillStyle = \"#00ffff\";\n      ctx.shadowColor = \"#00ffff\";\n      ctx.shadowBlur = 10;\n\n      ctx.beginPath();\n      ctx.moveTo(-15, 0);\n      ctx.quadraticCurveTo(-5, -10, 15, -5);\n      ctx.quadraticCurveTo(10, 0, 15, 5);\n      ctx.quadraticCurveTo(-5, 10, -15, 0);\n      ctx.closePath();\n      ctx.fill();\n\n      ctx.restore();\n    });\n  }\n\n  public fire(x: number, y: number, direction: { x: number; y: number }): IProjectile[] {\n    return [];\n  }\n\n  public upgrade(): void {\n    this.boomerangDamage += 8;\n    this.maxDistance += 50;\n    this.speed += 50;\n    if (this.boomerangCount < 4) {\n      this.boomerangCount++;\n    }\n  }\n\n  public getType(): string {\n    return \"boomerang\";\n  }\n}\n","path":null,"size_bytes":11758,"size_tokens":null},"client/src/lib/game/entities/collectibles/BossLoot.ts":{"content":"\nimport { ExperienceOrb } from \"./ExperienceOrb\";\n\nexport type BossLootType = \"legendary_item\" | \"rare_weapon\" | \"currency_bonus\" | \"power_up\" | \"evolution_item\";\n\nexport interface BossLootDrop {\n  type: BossLootType;\n  itemId: string;\n  name: string;\n  rarity: \"rare\" | \"epic\" | \"legendary\";\n  x: number;\n  y: number;\n  collected: boolean;\n}\n\nexport class BossLoot {\n  public x: number;\n  public y: number;\n  private type: BossLootType;\n  private itemId: string;\n  private name: string;\n  private rarity: \"rare\" | \"epic\" | \"legendary\";\n  private collected: boolean = false;\n  private attractionRadius: number = 150;\n  private attractionSpeed: number = 300;\n  private glowIntensity: number = 0;\n\n  constructor(x: number, y: number, type: BossLootType, itemId: string, name: string, rarity: \"rare\" | \"epic\" | \"legendary\") {\n    this.x = x;\n    this.y = y;\n    this.type = type;\n    this.itemId = itemId;\n    this.name = name;\n    this.rarity = rarity;\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < this.attractionRadius) {\n      const moveX = (dx / distance) * this.attractionSpeed * deltaTime;\n      const moveY = (dy / distance) * this.attractionSpeed * deltaTime;\n      this.x += moveX;\n      this.y += moveY;\n    }\n\n    this.glowIntensity = Math.sin(Date.now() / 200) * 0.5 + 0.5;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    const colors = {\n      rare: \"#4287f5\",\n      epic: \"#9b59b6\",\n      legendary: \"#f39c12\"\n    };\n\n    const color = colors[this.rarity];\n\n    ctx.save();\n    ctx.shadowColor = color;\n    ctx.shadowBlur = 20 + this.glowIntensity * 10;\n\n    // Draw outer glow\n    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 30);\n    gradient.addColorStop(0, color + \"80\");\n    gradient.addColorStop(1, color + \"00\");\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw item icon\n    ctx.fillStyle = color;\n    ctx.font = \"bold 24px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    \n    const icons = {\n      legendary_item: \"\",\n      rare_weapon: \"\",\n      currency_bonus: \"\",\n      power_up: \"\",\n      evolution_item: \"\"\n    };\n    \n    ctx.fillText(icons[this.type], this.x, this.y);\n\n    // Draw rarity indicator\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, 20 + this.glowIntensity * 5, 0, Math.PI * 2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  public canBeCollected(playerPos: { x: number; y: number }): boolean {\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < 30;\n  }\n\n  public collect(): void {\n    this.collected = true;\n  }\n\n  public isCollected(): boolean {\n    return this.collected;\n  }\n\n  public getType(): BossLootType {\n    return this.type;\n  }\n\n  public getItemId(): string {\n    return this.itemId;\n  }\n\n  public getName(): string {\n    return this.name;\n  }\n\n  public getRarity(): \"rare\" | \"epic\" | \"legendary\" {\n    return this.rarity;\n  }\n}\n\nexport function generateBossLoot(bossX: number, bossY: number, bossType: string): BossLoot[] {\n  const loot: BossLoot[] = [];\n  \n  // Always drop currency\n  loot.push(new BossLoot(\n    bossX + (Math.random() - 0.5) * 100,\n    bossY + (Math.random() - 0.5) * 100,\n    \"currency_bonus\",\n    \"boss_currency\",\n    \"Boss Bounty\",\n    \"legendary\"\n  ));\n\n  // Chance for evolution item\n  if (Math.random() < 0.4) {\n    const evolutionItems = [\"ancient_seed\", \"star_fragment\", \"storm_essence\", \"venom_core\", \"energy_crystal\"];\n    const item = evolutionItems[Math.floor(Math.random() * evolutionItems.length)];\n    loot.push(new BossLoot(\n      bossX + (Math.random() - 0.5) * 100,\n      bossY + (Math.random() - 0.5) * 100,\n      \"evolution_item\",\n      item,\n      item.split(\"_\").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(\" \"),\n      \"epic\"\n    ));\n  }\n\n  // Chance for legendary item\n  if (Math.random() < 0.2) {\n    loot.push(new BossLoot(\n      bossX + (Math.random() - 0.5) * 100,\n      bossY + (Math.random() - 0.5) * 100,\n      \"legendary_item\",\n      \"legendary_artifact\",\n      \"Legendary Artifact\",\n      \"legendary\"\n    ));\n  }\n\n  return loot;\n}\n","path":null,"size_bytes":4455,"size_tokens":null},"client/src/lib/systems/InputManager.ts":{"content":"export interface InputState {\n  left: boolean;\n  right: boolean;\n  up: boolean;\n  down: boolean;\n  mute: boolean;\n  restart: boolean;\n  pause: boolean;\n  weapon1: boolean;\n  weapon2: boolean;\n  weapon3: boolean;\n  weapon4: boolean;\n  weapon5: boolean;\n}\n\nexport class InputManager {\n  private keys: { [key: string]: boolean };\n\n  constructor() {\n    this.keys = {};\n\n    document.addEventListener(\"keydown\", (event) => {\n      this.keys[event.code] = true;\n    });\n\n    document.addEventListener(\"keyup\", (event) => {\n      this.keys[event.code] = false;\n    });\n  }\n\n  public getInput() {\n    return {\n      up: this.keys[\"KeyW\"] || this.keys[\"ArrowUp\"],\n      down: this.keys[\"KeyS\"] || this.keys[\"ArrowDown\"],\n      left: this.keys[\"KeyA\"] || this.keys[\"ArrowLeft\"],\n      right: this.keys[\"KeyD\"] || this.keys[\"ArrowRight\"],\n      weapon1: this.keys[\"Digit1\"],\n      weapon2: this.keys[\"Digit2\"],\n      weapon3: this.keys[\"Digit3\"],\n      weapon4: this.keys[\"Digit4\"],\n      weapon5: this.keys[\"Digit5\"],\n      mute: this.keys[\"KeyM\"],\n      restart: this.keys[\"KeyR\"],\n      pause: this.keys[\"Escape\"]\n    };\n  }\n}","path":null,"size_bytes":1119,"size_tokens":null},"client/src/lib/game/entities/enemies/TeleportingEnemy.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\n\nexport class TeleportingEnemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  \n  private teleportTimer: number = 0;\n  private teleportCooldown: number = 3.5;\n  private isTelegraphing: boolean = false;\n  private telegraphTimer: number = 0;\n  private telegraphDuration: number = 0.8;\n  private teleportTargetX: number = 0;\n  private teleportTargetY: number = 0;\n  private justTeleported: boolean = false;\n  private postTeleportAttackWindow: number = 0;\n  private attackWindowDuration: number = 1.5;\n  private opacity: number = 1;\n\n  constructor(x: number, y: number) {\n    super(x, y, 75, 75);\n    this.collisionWidth = 30;\n    this.collisionHeight = 30;\n    \n    this.speed = 0;\n    this.health = 2;\n    this.maxHealth = 2;\n    this.damage = 35;\n    this.scoreValue = 35;\n    \n    this.teleportCooldown = 3 + Math.random();\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    if (this.justTeleported) {\n      this.postTeleportAttackWindow += deltaTime;\n      if (this.postTeleportAttackWindow >= this.attackWindowDuration) {\n        this.justTeleported = false;\n        this.postTeleportAttackWindow = 0;\n      }\n    }\n\n    if (this.isTelegraphing) {\n      this.telegraphTimer += deltaTime;\n      this.opacity = 0.3 + Math.sin(this.telegraphTimer * 20) * 0.3;\n      \n      if (this.telegraphTimer >= this.telegraphDuration) {\n        this.executeTeleport();\n      }\n    } else {\n      this.teleportTimer += deltaTime;\n      this.opacity = Math.min(1, this.opacity + deltaTime * 2);\n      \n      if (this.teleportTimer >= this.teleportCooldown) {\n        this.startTelegraph(playerPos);\n      }\n    }\n  }\n\n  private startTelegraph(playerPos: { x: number; y: number }): void {\n    this.isTelegraphing = true;\n    this.telegraphTimer = 0;\n    \n    const angle = Math.random() * Math.PI * 2;\n    const distance = 50 + Math.random() * 50;\n    this.teleportTargetX = playerPos.x + Math.cos(angle) * distance;\n    this.teleportTargetY = playerPos.y + Math.sin(angle) * distance;\n  }\n\n  private executeTeleport(): void {\n    this.x = this.teleportTargetX;\n    this.y = this.teleportTargetY;\n    this.isTelegraphing = false;\n    this.teleportTimer = 0;\n    this.justTeleported = true;\n    this.postTeleportAttackWindow = 0;\n    this.opacity = 1;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    ctx.globalAlpha = this.opacity;\n    \n    if (this.isTelegraphing) {\n      ctx.strokeStyle = \"#00ffff\";\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.beginPath();\n      ctx.arc(this.teleportTargetX, this.teleportTargetY, 30, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      \n      ctx.fillStyle = \"rgba(0, 255, 255, 0.2)\";\n      ctx.beginPath();\n      ctx.arc(this.teleportTargetX, this.teleportTargetY, 30, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    ctx.fillStyle = this.justTeleported ? \"#ff4444\" : \"#00cccc\";\n    \n    const centerX = this.x;\n    const centerY = this.y;\n    const size = this.width / 2;\n    \n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY - size);\n    ctx.lineTo(centerX + size * 0.7, centerY - size * 0.3);\n    ctx.lineTo(centerX + size, centerY);\n    ctx.lineTo(centerX + size * 0.7, centerY + size * 0.3);\n    ctx.lineTo(centerX, centerY + size);\n    ctx.lineTo(centerX - size * 0.7, centerY + size * 0.3);\n    ctx.lineTo(centerX - size, centerY);\n    ctx.lineTo(centerX - size * 0.7, centerY - size * 0.3);\n    ctx.closePath();\n    ctx.fill();\n    \n    ctx.fillStyle = this.justTeleported ? \"#ffaaaa\" : \"#66ffff\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(this.x - 8, this.y - 5, 5, 0, Math.PI * 2);\n    ctx.arc(this.x + 8, this.y - 5, 5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#000000\";\n    ctx.beginPath();\n    ctx.arc(this.x - 8, this.y - 5, 2, 0, Math.PI * 2);\n    ctx.arc(this.x + 8, this.y - 5, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n    \n    ctx.restore();\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth * healthPercent, barHeight);\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.justTeleported ? this.damage * 1.5 : this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return \"teleporting\";\n  }\n\n  public isTeleporting(): boolean {\n    return this.isTelegraphing;\n  }\n\n  public hasJustTeleported(): boolean {\n    return this.justTeleported;\n  }\n}\n","path":null,"size_bytes":5601,"size_tokens":null},"client/src/lib/game/weapons/IceNovaWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { WeaponRarity } from \"./WeaponRarity\";\n\ninterface SlowEffect {\n  enemy: Enemy;\n  remainingTime: number;\n  slowMultiplier: number;\n  originalSpeed: number;\n}\n\ninterface NovaWave {\n  x: number;\n  y: number;\n  currentRadius: number;\n  maxRadius: number;\n  alpha: number;\n  hitEnemies: Set<Enemy>;\n}\n\nexport class IceNovaWeapon {\n  private damage: number;\n  private cooldown: number;\n  private novaRadius: number;\n  private slowAmount: number;\n  private slowDuration: number;\n  private lastFireTime: number = 0;\n  private activeNovas: NovaWave[] = [];\n  private slowEffects: Map<Enemy, SlowEffect> = new Map();\n  private level: number = 1;\n  private rarity: WeaponRarity = WeaponRarity.Common;\n  private evolved: boolean = false;\n  private novaExpansionSpeed: number = 300;\n\n  constructor() {\n    this.damage = 20;\n    this.cooldown = 4;\n    this.novaRadius = 200;\n    this.slowAmount = 0.5;\n    this.slowDuration = 3;\n  }\n\n  public update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number\n  ): { enemy: Enemy; damage: number }[] {\n    this.lastFireTime += deltaTime;\n    const hits: { enemy: Enemy; damage: number }[] = [];\n\n    this.updateSlowEffects(deltaTime);\n    this.updateNovas(deltaTime, enemies, hits);\n\n    if (this.lastFireTime >= this.getEffectiveCooldown()) {\n      this.lastFireTime = 0;\n      this.createNova(playerX, playerY);\n    }\n\n    return hits;\n  }\n\n  private createNova(x: number, y: number): void {\n    const maxRadius = this.getEffectiveRadius();\n    \n    this.activeNovas.push({\n      x,\n      y,\n      currentRadius: 0,\n      maxRadius,\n      alpha: 1,\n      hitEnemies: new Set()\n    });\n\n    if (this.evolved) {\n      setTimeout(() => {\n        this.activeNovas.push({\n          x,\n          y,\n          currentRadius: 0,\n          maxRadius: maxRadius * 0.7,\n          alpha: 1,\n          hitEnemies: new Set()\n        });\n      }, 200);\n    }\n  }\n\n  private updateNovas(\n    deltaTime: number,\n    enemies: Enemy[],\n    hits: { enemy: Enemy; damage: number }[]\n  ): void {\n    this.activeNovas = this.activeNovas.filter(nova => {\n      nova.currentRadius += this.novaExpansionSpeed * deltaTime;\n\n      for (const enemy of enemies) {\n        if (!enemy.isAlive() || enemy.getHealth() <= 0) continue;\n        if (nova.hitEnemies.has(enemy)) continue;\n\n        const dx = enemy.x - nova.x;\n        const dy = enemy.y - nova.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= nova.currentRadius && distance >= nova.currentRadius - 30) {\n          nova.hitEnemies.add(enemy);\n          hits.push({ enemy, damage: this.getBaseDamage() });\n          this.applySlow(enemy);\n        }\n      }\n\n      if (nova.currentRadius >= nova.maxRadius) {\n        nova.alpha -= deltaTime * 2;\n      }\n\n      return nova.alpha > 0;\n    });\n  }\n\n  private updateSlowEffects(deltaTime: number): void {\n    for (const [enemy, slow] of this.slowEffects) {\n      if (!enemy.isAlive() || enemy.getHealth() <= 0) {\n        this.slowEffects.delete(enemy);\n        continue;\n      }\n\n      slow.remainingTime -= deltaTime;\n\n      if (slow.remainingTime <= 0) {\n        this.slowEffects.delete(enemy);\n      }\n    }\n  }\n\n  private applySlow(enemy: Enemy): void {\n    const existingSlow = this.slowEffects.get(enemy);\n    const slowMult = this.evolved ? this.slowAmount * 1.5 : this.slowAmount;\n    const slowTime = this.evolved ? this.slowDuration * 1.5 : this.slowDuration;\n\n    if (existingSlow) {\n      existingSlow.remainingTime = slowTime;\n    } else {\n      this.slowEffects.set(enemy, {\n        enemy,\n        remainingTime: slowTime,\n        slowMultiplier: slowMult,\n        originalSpeed: 1\n      });\n    }\n  }\n\n  public isEnemySlowed(enemy: Enemy): boolean {\n    return this.slowEffects.has(enemy);\n  }\n\n  public getSlowMultiplier(enemy: Enemy): number {\n    const slow = this.slowEffects.get(enemy);\n    return slow ? slow.slowMultiplier : 1;\n  }\n\n  private getEffectiveCooldown(): number {\n    let cd = this.cooldown - (this.level - 1) * 0.3;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        cd *= 0.9;\n        break;\n      case WeaponRarity.Legendary:\n        cd *= 0.8;\n        break;\n    }\n\n    if (this.evolved) {\n      cd *= 0.7;\n    }\n\n    return Math.max(cd, 1);\n  }\n\n  private getEffectiveRadius(): number {\n    let radius = this.novaRadius + (this.level - 1) * 30;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        radius *= 1.15;\n        break;\n      case WeaponRarity.Legendary:\n        radius *= 1.3;\n        break;\n    }\n\n    if (this.evolved) {\n      radius *= 1.5;\n    }\n\n    return radius;\n  }\n\n  private getBaseDamage(): number {\n    let baseDamage = this.damage + (this.level - 1) * 5;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        baseDamage *= 1.25;\n        break;\n      case WeaponRarity.Legendary:\n        baseDamage *= 1.5;\n        break;\n    }\n\n    if (this.evolved) {\n      baseDamage *= 2;\n    }\n\n    return Math.floor(baseDamage);\n  }\n\n  public render(\n    ctx: CanvasRenderingContext2D,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    ctx.save();\n\n    for (const nova of this.activeNovas) {\n      this.renderNova(ctx, nova, cameraX, cameraY);\n    }\n\n    for (const [enemy, slow] of this.slowEffects) {\n      if (enemy.isAlive()) {\n        this.renderSlowEffect(ctx, enemy.x - cameraX, enemy.y - cameraY, slow);\n      }\n    }\n\n    ctx.restore();\n  }\n\n  private renderNova(\n    ctx: CanvasRenderingContext2D,\n    nova: NovaWave,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    const screenX = nova.x - cameraX;\n    const screenY = nova.y - cameraY;\n\n    ctx.globalAlpha = nova.alpha * 0.7;\n\n    const baseColor = this.evolved ? \"#00FFFF\" : \"#87CEEB\";\n    const innerColor = this.evolved ? \"#FFFFFF\" : \"#B0E0E6\";\n\n    const gradient = ctx.createRadialGradient(\n      screenX, screenY, Math.max(0, nova.currentRadius - 20),\n      screenX, screenY, nova.currentRadius\n    );\n    gradient.addColorStop(0, \"rgba(135, 206, 235, 0)\");\n    gradient.addColorStop(0.5, `${baseColor}80`);\n    gradient.addColorStop(1, `${innerColor}40`);\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, nova.currentRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.strokeStyle = baseColor;\n    ctx.lineWidth = this.evolved ? 4 : 2;\n    ctx.shadowColor = baseColor;\n    ctx.shadowBlur = 10;\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, nova.currentRadius, 0, Math.PI * 2);\n    ctx.stroke();\n\n    const crystalCount = 8;\n    for (let i = 0; i < crystalCount; i++) {\n      const angle = (i / crystalCount) * Math.PI * 2;\n      const x = screenX + Math.cos(angle) * nova.currentRadius;\n      const y = screenY + Math.sin(angle) * nova.currentRadius;\n      \n      ctx.fillStyle = innerColor;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private renderSlowEffect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    slow: SlowEffect\n  ): void {\n    const alpha = Math.min(slow.remainingTime / this.slowDuration, 1);\n    \n    ctx.globalAlpha = alpha * 0.5;\n    ctx.fillStyle = \"#87CEEB\";\n    \n    for (let i = 0; i < 5; i++) {\n      const offsetX = (Math.random() - 0.5) * 30;\n      const offsetY = (Math.random() - 0.5) * 30;\n      const size = 2 + Math.random() * 3;\n      \n      ctx.beginPath();\n      ctx.moveTo(x + offsetX, y + offsetY - size);\n      ctx.lineTo(x + offsetX + size * 0.5, y + offsetY);\n      ctx.lineTo(x + offsetX, y + offsetY + size);\n      ctx.lineTo(x + offsetX - size * 0.5, y + offsetY);\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  public upgrade(): void {\n    this.level = Math.min(this.level + 1, 5);\n    this.damage += 5;\n    this.novaRadius += 30;\n    this.slowDuration += 0.5;\n  }\n\n  public evolve(): void {\n    if (this.level >= 5 && !this.evolved) {\n      this.evolved = true;\n      this.damage *= 2;\n      this.novaRadius *= 1.5;\n      this.slowAmount = 0.75;\n      this.cooldown *= 0.7;\n    }\n  }\n\n  public getLevel(): number {\n    return this.level;\n  }\n\n  public isEvolved(): boolean {\n    return this.evolved;\n  }\n\n  public setRarity(rarity: WeaponRarity): void {\n    this.rarity = rarity;\n  }\n\n  public getRarity(): WeaponRarity {\n    return this.rarity;\n  }\n\n  public getName(): string {\n    return this.evolved ? \"Blizzard\" : \"Ice Nova\";\n  }\n\n  public getDescription(): string {\n    return this.evolved \n      ? \"Unleashes a devastating blizzard that freezes all in its path\"\n      : \"Releases a freezing wave that slows enemies\";\n  }\n}\nimport { BaseWeapon } from \"../core/base/BaseWeapon\";\nimport { IProjectile } from \"../core/interfaces/IProjectile\";\nimport { Enemy } from \"../entities/enemies/Enemy\";\n\ninterface IceNova {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  lifetime: number;\n  active: boolean;\n}\n\ninterface SlowEffect {\n  enemy: Enemy;\n  remainingTime: number;\n  slowMultiplier: number;\n}\n\nexport class IceNovaWeapon extends BaseWeapon {\n  private novas: IceNova[] = [];\n  private cooldown: number = 5;\n  private cooldownTimer: number = 0;\n  private novaRadius: number = 200;\n  private novaDamage: number = 30;\n  private slowAmount: number = 0.5;\n  private slowDuration: number = 3;\n  private slowEffects: Map<Enemy, SlowEffect> = new Map();\n\n  constructor() {\n    super(30, 0.2, 0);\n    this.damage = 30;\n  }\n\n  public update(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.cooldownTimer += deltaTime;\n\n    if (this.cooldownTimer >= this.cooldown) {\n      this.novas.push({\n        x: playerX,\n        y: playerY,\n        radius: 0,\n        maxRadius: this.novaRadius,\n        lifetime: 0.5,\n        active: true\n      });\n      this.cooldownTimer = 0;\n    }\n\n    this.novas = this.novas.filter(nova => {\n      if (!nova.active) return false;\n\n      nova.radius += (nova.maxRadius / nova.lifetime) * deltaTime;\n      nova.lifetime -= deltaTime;\n\n      if (nova.lifetime <= 0) {\n        nova.active = false;\n        return false;\n      }\n\n      enemies.forEach((enemy: any) => {\n        if (!enemy.isAlive()) return;\n        const dx = enemy.x - nova.x;\n        const dy = enemy.y - nova.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= nova.radius && distance >= nova.radius - 30) {\n          enemy.takeDamage(this.novaDamage * deltaTime);\n          this.applySlow(enemy);\n        }\n      });\n\n      return true;\n    });\n\n    this.slowEffects.forEach((effect, enemy) => {\n      effect.remainingTime -= deltaTime;\n      if (effect.remainingTime <= 0 || !enemy.isAlive()) {\n        this.slowEffects.delete(enemy);\n      }\n    });\n  }\n\n  private applySlow(enemy: Enemy): void {\n    const existingSlow = this.slowEffects.get(enemy);\n    if (existingSlow) {\n      existingSlow.remainingTime = this.slowDuration;\n    } else {\n      this.slowEffects.set(enemy, {\n        enemy,\n        remainingTime: this.slowDuration,\n        slowMultiplier: this.slowAmount\n      });\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    this.novas.forEach(nova => {\n      const alpha = nova.lifetime / 0.5;\n      \n      ctx.save();\n      ctx.globalAlpha = alpha * 0.6;\n\n      const gradient = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, nova.radius);\n      gradient.addColorStop(0, \"rgba(100, 200, 255, 0)\");\n      gradient.addColorStop(0.7, \"rgba(100, 200, 255, 0.8)\");\n      gradient.addColorStop(1, \"rgba(150, 220, 255, 0.4)\");\n\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);\n      ctx.fill();\n\n      ctx.strokeStyle = \"rgba(200, 240, 255, 0.8)\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);\n      ctx.stroke();\n\n      ctx.restore();\n    });\n  }\n\n  public fire(x: number, y: number, direction: { x: number; y: number }): IProjectile[] {\n    return [];\n  }\n\n  public upgrade(): void {\n    this.novaDamage += 10;\n    this.novaRadius += 30;\n    this.cooldown = Math.max(2, this.cooldown - 0.5);\n    this.slowAmount = Math.min(0.8, this.slowAmount + 0.05);\n  }\n\n  public getType(): string {\n    return \"ice_nova\";\n  }\n\n  public isEnemySlowed(enemy: Enemy): boolean {\n    return this.slowEffects.has(enemy);\n  }\n\n  public getSlowMultiplier(enemy: Enemy): number {\n    const effect = this.slowEffects.get(enemy);\n    return effect ? effect.slowMultiplier : 1;\n  }\n}\n","path":null,"size_bytes":12518,"size_tokens":null},"client/src/lib/game/entities/enemies/BossEnemy.ts":{"content":"import { Enemy } from './Enemy';\nimport { SpriteManager } from '../../rendering/SpriteManager';\n\nexport type BossType = \"necromancer\" | \"vampire_lord\" | \"ancient_golem\";\n\nexport interface AttackPattern {\n  name: string;\n  cooldown: number;\n  currentCooldown: number;\n  damage: number;\n  range: number;\n  execute: (boss: BossEnemy, playerPos: { x: number; y: number }, deltaTime: number) => void;\n}\n\nexport interface BossAbility {\n  name: string;\n  description: string;\n  isActive: boolean;\n  duration: number;\n  currentDuration: number;\n}\n\nexport class BossEnemy extends Enemy {\n  private bossType: BossType;\n  private attackPatterns: AttackPattern[] = [];\n  private abilities: BossAbility[] = [];\n  private phaseThreshold: number = 0.5;\n  private currentPhase: number = 1;\n  private bossName: string = \"\";\n  private bossDescription: string = \"\";\n  \n  private isShielded: boolean = false;\n  private shieldHealth: number = 0;\n  private maxShieldHealth: number = 0;\n  \n  private dashVelocity: { x: number; y: number } = { x: 0, y: 0 };\n  private isDashing: boolean = false;\n  private dashDuration: number = 0;\n  \n  private summonCooldown: number = 0;\n  private minionSpawnQueue: { x: number; y: number }[] = [];\n  \n  private lifeStealAmount: number = 0;\n  private groundPoundActive: boolean = false;\n  private groundPoundRadius: number = 0;\n  private groundPoundDamage: number = 0;\n  \n  private phaseTransitionTimer: number = 0;\n  private isInPhaseTransition: boolean = false;\n\n  constructor(x: number, y: number, bossType: BossType, waveNumber: number = 5) {\n    super(x, y, \"tank\");\n    this.bossType = bossType;\n    \n    const stats = this.getBossStats(bossType, waveNumber);\n    this.initializeBoss(stats);\n    this.setupAttackPatterns();\n    this.setupAbilities();\n  }\n\n  private getBossStats(bossType: BossType, waveNumber: number) {\n    const scaleFactor = 1 + (waveNumber / 10);\n    \n    const bossStats = {\n      necromancer: {\n        name: \"The Necromancer\",\n        description: \"Master of death, commands the undead\",\n        health: 100 * scaleFactor,\n        damage: 25 * scaleFactor,\n        speed: 35,\n        width: 180,\n        height: 180,\n        collisionWidth: 72,\n        collisionHeight: 72,\n        scoreValue: 500 * Math.floor(scaleFactor),\n        color: \"#6b21a8\"\n      },\n      vampire_lord: {\n        name: \"Vampire Lord\",\n        description: \"Ancient bloodsucker with supernatural speed\",\n        health: 80 * scaleFactor,\n        damage: 35 * scaleFactor,\n        speed: 55,\n        width: 160,\n        height: 160,\n        collisionWidth: 64,\n        collisionHeight: 64,\n        scoreValue: 600 * Math.floor(scaleFactor),\n        color: \"#991b1b\"\n      },\n      ancient_golem: {\n        name: \"Ancient Golem\",\n        description: \"Stone guardian with impenetrable defense\",\n        health: 150 * scaleFactor,\n        damage: 40 * scaleFactor,\n        speed: 25,\n        width: 220,\n        height: 220,\n        collisionWidth: 88,\n        collisionHeight: 88,\n        scoreValue: 700 * Math.floor(scaleFactor),\n        color: \"#78716c\"\n      }\n    };\n\n    return bossStats[bossType];\n  }\n\n  private initializeBoss(stats: ReturnType<typeof this.getBossStats>) {\n    this.bossName = stats.name;\n    this.bossDescription = stats.description;\n    this.width = stats.width;\n    this.height = stats.height;\n    this.collisionWidth = stats.collisionWidth;\n    this.collisionHeight = stats.collisionHeight;\n    \n    (this as any).health = stats.health;\n    (this as any).maxHealth = stats.health;\n    (this as any).damage = stats.damage;\n    (this as any).speed = stats.speed;\n    (this as any).scoreValue = stats.scoreValue;\n  }\n\n  private setupAttackPatterns() {\n    switch (this.bossType) {\n      case \"necromancer\":\n        this.attackPatterns = [\n          {\n            name: \"Summon Minions\",\n            cooldown: 8,\n            currentCooldown: 3,\n            damage: 0,\n            range: 500,\n            execute: (boss, playerPos) => {\n              const angles = [0, Math.PI * 0.5, Math.PI, Math.PI * 1.5];\n              angles.forEach(angle => {\n                const spawnX = boss.x + Math.cos(angle) * 100;\n                const spawnY = boss.y + Math.sin(angle) * 100;\n                boss.minionSpawnQueue.push({ x: spawnX, y: spawnY });\n              });\n            }\n          },\n          {\n            name: \"Dark Bolt\",\n            cooldown: 2,\n            currentCooldown: 0,\n            damage: 15,\n            range: 300,\n            execute: () => {}\n          }\n        ];\n        break;\n\n      case \"vampire_lord\":\n        this.attackPatterns = [\n          {\n            name: \"Blood Dash\",\n            cooldown: 4,\n            currentCooldown: 2,\n            damage: 30,\n            range: 400,\n            execute: (boss, playerPos) => {\n              const dx = playerPos.x - boss.x;\n              const dy = playerPos.y - boss.y;\n              const distance = Math.sqrt(dx * dx + dy * dy);\n              if (distance > 0) {\n                boss.dashVelocity = {\n                  x: (dx / distance) * 500,\n                  y: (dy / distance) * 500\n                };\n                boss.isDashing = true;\n                boss.dashDuration = 0.3;\n              }\n            }\n          },\n          {\n            name: \"Life Steal Aura\",\n            cooldown: 6,\n            currentCooldown: 4,\n            damage: 20,\n            range: 150,\n            execute: (boss) => {\n              boss.lifeStealAmount = 30;\n            }\n          }\n        ];\n        break;\n\n      case \"ancient_golem\":\n        this.attackPatterns = [\n          {\n            name: \"Ground Pound\",\n            cooldown: 5,\n            currentCooldown: 3,\n            damage: 50,\n            range: 200,\n            execute: (boss) => {\n              boss.groundPoundActive = true;\n              boss.groundPoundRadius = 0;\n              boss.groundPoundDamage = 50;\n            }\n          },\n          {\n            name: \"Stone Shield\",\n            cooldown: 10,\n            currentCooldown: 5,\n            damage: 0,\n            range: 0,\n            execute: (boss) => {\n              boss.isShielded = true;\n              boss.shieldHealth = boss.getMaxHealth() * 0.3;\n              boss.maxShieldHealth = boss.shieldHealth;\n            }\n          }\n        ];\n        break;\n    }\n  }\n\n  private setupAbilities() {\n    switch (this.bossType) {\n      case \"necromancer\":\n        this.abilities = [\n          {\n            name: \"Death Aura\",\n            description: \"Enemies near the Necromancer gain power\",\n            isActive: true,\n            duration: -1,\n            currentDuration: 0\n          }\n        ];\n        break;\n\n      case \"vampire_lord\":\n        this.abilities = [\n          {\n            name: \"Bloodlust\",\n            description: \"Attacks heal the Vampire Lord\",\n            isActive: true,\n            duration: -1,\n            currentDuration: 0\n          }\n        ];\n        break;\n\n      case \"ancient_golem\":\n        this.abilities = [\n          {\n            name: \"Stone Skin\",\n            description: \"Reduces incoming damage\",\n            isActive: true,\n            duration: -1,\n            currentDuration: 0\n          }\n        ];\n        break;\n    }\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.isAlive()) return;\n\n    if (this.isInPhaseTransition) {\n      this.phaseTransitionTimer -= deltaTime;\n      if (this.phaseTransitionTimer <= 0) {\n        this.isInPhaseTransition = false;\n        this.enterPhase2();\n      }\n      return;\n    }\n\n    this.checkPhaseTransition();\n    this.updateAttackPatterns(deltaTime, playerPos);\n    this.updateSpecialMechanics(deltaTime, playerPos);\n\n    if (this.isDashing) {\n      this.x += this.dashVelocity.x * deltaTime;\n      this.y += this.dashVelocity.y * deltaTime;\n      this.dashDuration -= deltaTime;\n      if (this.dashDuration <= 0) {\n        this.isDashing = false;\n        this.dashVelocity = { x: 0, y: 0 };\n      }\n    } else {\n      super.update(deltaTime, playerPos);\n    }\n  }\n\n  private checkPhaseTransition() {\n    const healthPercent = this.getHealth() / this.getMaxHealth();\n    if (this.currentPhase === 1 && healthPercent <= this.phaseThreshold) {\n      this.currentPhase = 2;\n      this.isInPhaseTransition = true;\n      this.phaseTransitionTimer = 1.5;\n    }\n  }\n\n  private enterPhase2() {\n    this.attackPatterns.forEach(pattern => {\n      pattern.cooldown *= 0.7;\n    });\n    (this as any).speed *= 1.3;\n\n    switch (this.bossType) {\n      case \"necromancer\":\n        const summonPattern = this.attackPatterns.find(p => p.name === \"Summon Minions\");\n        if (summonPattern) {\n          summonPattern.cooldown = 5;\n        }\n        break;\n\n      case \"vampire_lord\":\n        this.lifeStealAmount = 50;\n        break;\n\n      case \"ancient_golem\":\n        this.isShielded = true;\n        this.shieldHealth = this.getMaxHealth() * 0.5;\n        this.maxShieldHealth = this.shieldHealth;\n        break;\n    }\n  }\n\n  private updateAttackPatterns(deltaTime: number, playerPos: { x: number; y: number }) {\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);\n\n    this.attackPatterns.forEach(pattern => {\n      pattern.currentCooldown -= deltaTime;\n      \n      if (pattern.currentCooldown <= 0 && distanceToPlayer <= pattern.range) {\n        pattern.execute(this, playerPos, deltaTime);\n        pattern.currentCooldown = pattern.cooldown;\n      }\n    });\n  }\n\n  private updateSpecialMechanics(deltaTime: number, playerPos: { x: number; y: number }) {\n    if (this.summonCooldown > 0) {\n      this.summonCooldown -= deltaTime;\n    }\n\n    if (this.groundPoundActive) {\n      this.groundPoundRadius += 300 * deltaTime;\n      if (this.groundPoundRadius >= 200) {\n        this.groundPoundActive = false;\n        this.groundPoundRadius = 0;\n      }\n    }\n\n    if (this.lifeStealAmount > 0) {\n      this.lifeStealAmount -= deltaTime * 10;\n      if (this.lifeStealAmount < 0) this.lifeStealAmount = 0;\n    }\n  }\n\n  public takeDamage(amount: number): void {\n    if (this.isInPhaseTransition) return;\n\n    let actualDamage = amount;\n\n    if (this.bossType === \"ancient_golem\") {\n      actualDamage *= 0.7;\n    }\n\n    if (this.isShielded) {\n      this.shieldHealth -= actualDamage;\n      if (this.shieldHealth <= 0) {\n        this.isShielded = false;\n        actualDamage = Math.abs(this.shieldHealth);\n        this.shieldHealth = 0;\n      } else {\n        return;\n      }\n    }\n\n    super.takeDamage(actualDamage);\n\n    if (this.lifeStealAmount > 0 && this.bossType === \"vampire_lord\") {\n      const healAmount = actualDamage * 0.1;\n      const currentHealth = this.getHealth();\n      const maxHealth = this.getMaxHealth();\n      (this as any).health = Math.min(currentHealth + healAmount, maxHealth);\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.isAlive()) return;\n\n    const bossColors = {\n      necromancer: \"#6b21a8\",\n      vampire_lord: \"#991b1b\",\n      ancient_golem: \"#78716c\"\n    };\n\n    const baseColor = bossColors[this.bossType];\n    \n    ctx.save();\n    \n    if (this.isInPhaseTransition) {\n      ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;\n      \n      ctx.fillStyle = \"#ffffff\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.width * 0.8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    if (this.groundPoundActive) {\n      ctx.fillStyle = \"rgba(139, 69, 19, 0.3)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.groundPoundRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      ctx.strokeStyle = \"#8b4513\";\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n\n    ctx.fillStyle = baseColor;\n    \n    if (this.currentPhase === 2) {\n      ctx.shadowColor = baseColor;\n      ctx.shadowBlur = 20;\n    }\n    \n    ctx.fillRect(\n      this.x - this.width / 2,\n      this.y - this.height / 2,\n      this.width,\n      this.height\n    );\n\n    this.renderBossDetails(ctx, baseColor);\n\n    if (this.isShielded) {\n      ctx.strokeStyle = \"#4ade80\";\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.width / 2 + 10, 0, Math.PI * 2);\n      ctx.stroke();\n      \n      ctx.fillStyle = \"rgba(74, 222, 128, 0.2)\";\n      ctx.fill();\n      \n      const shieldPercent = this.shieldHealth / this.maxShieldHealth;\n      const shieldBarWidth = this.width;\n      ctx.fillStyle = \"#166534\";\n      ctx.fillRect(this.x - shieldBarWidth / 2, this.y - this.height / 2 - 20, shieldBarWidth, 6);\n      ctx.fillStyle = \"#4ade80\";\n      ctx.fillRect(this.x - shieldBarWidth / 2, this.y - this.height / 2 - 20, shieldBarWidth * shieldPercent, 6);\n    }\n\n    if (this.isDashing && this.bossType === \"vampire_lord\") {\n      ctx.fillStyle = \"rgba(153, 27, 27, 0.5)\";\n      for (let i = 1; i <= 3; i++) {\n        const trailX = this.x - this.dashVelocity.x * 0.02 * i;\n        const trailY = this.y - this.dashVelocity.y * 0.02 * i;\n        ctx.globalAlpha = 1 - (i * 0.25);\n        ctx.fillRect(\n          trailX - this.width / 2,\n          trailY - this.height / 2,\n          this.width,\n          this.height\n        );\n      }\n      ctx.globalAlpha = 1;\n    }\n\n    ctx.restore();\n  }\n\n  private renderBossDetails(ctx: CanvasRenderingContext2D, baseColor: string) {\n    const iconSize = this.width * 0.4;\n    \n    ctx.fillStyle = \"#ffffff\";\n    ctx.font = `bold ${iconSize}px Arial`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    \n    let icon = \"\";\n    switch (this.bossType) {\n      case \"necromancer\":\n        icon = \"\";\n        break;\n      case \"vampire_lord\":\n        icon = \"\";\n        break;\n      case \"ancient_golem\":\n        icon = \"\";\n        break;\n    }\n    \n    ctx.fillText(icon, this.x, this.y);\n\n    if (this.currentPhase === 2) {\n      ctx.fillStyle = \"#ef4444\";\n      ctx.font = \"bold 16px Arial\";\n      ctx.fillText(\"ENRAGED\", this.x, this.y + this.height / 2 + 20);\n    }\n  }\n\n  public getMinionSpawnQueue(): { x: number; y: number }[] {\n    const queue = [...this.minionSpawnQueue];\n    this.minionSpawnQueue = [];\n    return queue;\n  }\n\n  public isGroundPounding(): boolean {\n    return this.groundPoundActive;\n  }\n\n  public getGroundPoundRadius(): number {\n    return this.groundPoundRadius;\n  }\n\n  public getGroundPoundDamage(): number {\n    return this.groundPoundDamage;\n  }\n\n  public getBossType(): BossType {\n    return this.bossType;\n  }\n\n  public getBossName(): string {\n    return this.bossName;\n  }\n\n  public getBossDescription(): string {\n    return this.bossDescription;\n  }\n\n  public getCurrentPhase(): number {\n    return this.currentPhase;\n  }\n\n  public isInTransition(): boolean {\n    return this.isInPhaseTransition;\n  }\n\n  public getType(): string {\n    return `boss_${this.bossType}`;\n  }\n}\n","path":null,"size_bytes":14839,"size_tokens":null},"client/src/components/BossWarning.tsx":{"content":"import { useGameState } from \"../lib/stores/useGameState\";\nimport { useEffect, useState } from \"react\";\n\nexport default function BossWarning() {\n  const { showBossWarning, bossName, bossDescription } = useGameState();\n  const [visible, setVisible] = useState(false);\n  const [shake, setShake] = useState(false);\n  const [fadeOut, setFadeOut] = useState(false);\n\n  useEffect(() => {\n    if (showBossWarning) {\n      setVisible(true);\n      setFadeOut(false);\n      setShake(true);\n      \n      const shakeInterval = setInterval(() => {\n        setShake(prev => !prev);\n      }, 100);\n      \n      const fadeTimeout = setTimeout(() => {\n        setFadeOut(true);\n      }, 3500);\n      \n      const hideTimeout = setTimeout(() => {\n        setVisible(false);\n        useGameState.getState().hideBossWarning();\n      }, 4500);\n      \n      return () => {\n        clearInterval(shakeInterval);\n        clearTimeout(fadeTimeout);\n        clearTimeout(hideTimeout);\n      };\n    }\n  }, [showBossWarning]);\n\n  if (!visible) return null;\n\n  return (\n    <div \n      className={`fixed inset-0 z-[100] flex items-center justify-center pointer-events-none transition-opacity duration-1000 ${\n        fadeOut ? 'opacity-0' : 'opacity-100'\n      }`}\n    >\n      <div className=\"absolute inset-0 bg-red-900/30 animate-pulse\" />\n      \n      <div \n        className={`relative text-center ${shake ? 'translate-x-1' : '-translate-x-1'}`}\n        style={{\n          animation: 'bossWarningPulse 0.5s ease-in-out infinite'\n        }}\n      >\n        <div className=\"relative\">\n          <h1 \n            className=\"text-6xl md:text-8xl font-extrabold text-red-500 tracking-widest\"\n            style={{\n              textShadow: '0 0 20px rgba(239, 68, 68, 0.8), 0 0 40px rgba(239, 68, 68, 0.6), 0 0 60px rgba(239, 68, 68, 0.4)',\n              animation: 'bossTextGlow 0.3s ease-in-out infinite alternate'\n            }}\n          >\n            BOSS INCOMING!\n          </h1>\n          \n          <div className=\"absolute -inset-4 border-4 border-red-500/50 animate-ping\" />\n        </div>\n        \n        <div className=\"mt-8 space-y-4\">\n          <div className=\"flex items-center justify-center space-x-4\">\n            <div className=\"h-1 w-16 bg-gradient-to-r from-transparent to-red-500\" />\n            <span className=\"text-4xl\">\n              {bossName?.includes(\"Necromancer\") && \"\"}\n              {bossName?.includes(\"Vampire\") && \"\"}\n              {bossName?.includes(\"Golem\") && \"\"}\n              {!bossName && \"\"}\n            </span>\n            <div className=\"h-1 w-16 bg-gradient-to-l from-transparent to-red-500\" />\n          </div>\n          \n          <h2 \n            className=\"text-3xl md:text-5xl font-bold text-white\"\n            style={{\n              textShadow: '0 0 10px rgba(255, 255, 255, 0.8)'\n            }}\n          >\n            {bossName || \"Unknown Terror\"}\n          </h2>\n          \n          <p className=\"text-xl text-red-300 max-w-md mx-auto\">\n            {bossDescription || \"A powerful enemy approaches...\"}\n          </p>\n        </div>\n        \n        <div className=\"mt-8 flex justify-center space-x-2\">\n          {[...Array(5)].map((_, i) => (\n            <div \n              key={i}\n              className=\"w-3 h-3 bg-red-500 rounded-full animate-bounce\"\n              style={{ animationDelay: `${i * 0.1}s` }}\n            />\n          ))}\n        </div>\n      </div>\n      \n      <div className=\"absolute top-0 left-0 w-full h-2 bg-red-500 animate-pulse\" />\n      <div className=\"absolute bottom-0 left-0 w-full h-2 bg-red-500 animate-pulse\" />\n      <div className=\"absolute top-0 left-0 w-2 h-full bg-red-500 animate-pulse\" />\n      <div className=\"absolute top-0 right-0 w-2 h-full bg-red-500 animate-pulse\" />\n      \n      <style>{`\n        @keyframes bossWarningPulse {\n          0%, 100% { transform: scale(1); }\n          50% { transform: scale(1.02); }\n        }\n        \n        @keyframes bossTextGlow {\n          0% { \n            text-shadow: 0 0 20px rgba(239, 68, 68, 0.8), 0 0 40px rgba(239, 68, 68, 0.6);\n          }\n          100% { \n            text-shadow: 0 0 30px rgba(239, 68, 68, 1), 0 0 60px rgba(239, 68, 68, 0.8), 0 0 80px rgba(239, 68, 68, 0.6);\n          }\n        }\n      `}</style>\n    </div>\n  );\n}\n","path":null,"size_bytes":4278,"size_tokens":null},"client/src/lib/game/entities/enemies/RangedEnemy.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\nimport { EnemyProjectile } from './EnemyProjectile';\n\nexport class RangedEnemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  \n  private preferredDistance: number = 175;\n  private minDistance: number = 150;\n  private maxDistance: number = 200;\n  private shootTimer: number = 0;\n  private shootCooldown: number = 2.5;\n  private projectileQueue: EnemyProjectile[] = [];\n  private isAiming: boolean = false;\n  private aimTimer: number = 0;\n  private aimDuration: number = 0.5;\n  private targetPos: { x: number; y: number } | null = null;\n\n  constructor(x: number, y: number) {\n    super(x, y, 70, 70);\n    this.collisionWidth = 28;\n    this.collisionHeight = 28;\n    \n    this.speed = 40;\n    this.health = 1;\n    this.maxHealth = 1;\n    this.damage = 10;\n    this.scoreValue = 25;\n    \n    this.shootCooldown = 2 + Math.random();\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < this.minDistance) {\n      const moveX = -(dx / distance) * this.speed * deltaTime;\n      const moveY = -(dy / distance) * this.speed * deltaTime;\n      this.x += moveX;\n      this.y += moveY;\n    } else if (distance > this.maxDistance) {\n      const moveX = (dx / distance) * this.speed * deltaTime;\n      const moveY = (dy / distance) * this.speed * deltaTime;\n      this.x += moveX;\n      this.y += moveY;\n    } else {\n      const strafeAngle = Math.sin(Date.now() * 0.002) * 0.5;\n      const perpX = -dy / distance;\n      const perpY = dx / distance;\n      this.x += perpX * this.speed * 0.5 * strafeAngle * deltaTime;\n      this.y += perpY * this.speed * 0.5 * strafeAngle * deltaTime;\n    }\n\n    if (this.isAiming) {\n      this.aimTimer += deltaTime;\n      if (this.aimTimer >= this.aimDuration && this.targetPos) {\n        this.fireProjectile(this.targetPos);\n        this.isAiming = false;\n        this.aimTimer = 0;\n        this.targetPos = null;\n      }\n    } else {\n      this.shootTimer += deltaTime;\n      if (this.shootTimer >= this.shootCooldown && distance < this.maxDistance * 1.5) {\n        this.isAiming = true;\n        this.targetPos = { x: playerPos.x, y: playerPos.y };\n        this.shootTimer = 0;\n      }\n    }\n  }\n\n  private fireProjectile(targetPos: { x: number; y: number }): void {\n    const projectile = new EnemyProjectile(this.x, this.y, targetPos.x, targetPos.y, this.damage);\n    this.projectileQueue.push(projectile);\n  }\n\n  public getProjectiles(): EnemyProjectile[] {\n    const projectiles = [...this.projectileQueue];\n    this.projectileQueue = [];\n    return projectiles;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    \n    ctx.fillStyle = \"#9944cc\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#6622aa\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 3, 0, Math.PI * 2);\n    ctx.fill();\n    \n    if (this.isAiming && this.targetPos) {\n      ctx.strokeStyle = \"#ff00ff\";\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.beginPath();\n      ctx.moveTo(this.x, this.y);\n      \n      const dx = this.targetPos.x - this.x;\n      const dy = this.targetPos.y - this.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      const lineLength = Math.min(dist, 50);\n      ctx.lineTo(this.x + (dx / dist) * lineLength, this.y + (dy / dist) * lineLength);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      \n      const pulseSize = 8 + Math.sin(Date.now() * 0.01) * 4;\n      ctx.fillStyle = \"rgba(255, 0, 255, 0.5)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, pulseSize + this.width / 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    ctx.fillStyle = \"#ffff00\";\n    ctx.beginPath();\n    ctx.arc(this.x - 10, this.y - 5, 6, 0, Math.PI * 2);\n    ctx.arc(this.x + 10, this.y - 5, 6, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#000000\";\n    ctx.beginPath();\n    ctx.arc(this.x - 10, this.y - 5, 3, 0, Math.PI * 2);\n    ctx.arc(this.x + 10, this.y - 5, 3, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n    \n    ctx.restore();\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 8, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 8, barWidth * healthPercent, barHeight);\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return \"ranged\";\n  }\n\n  public isAimingState(): boolean {\n    return this.isAiming;\n  }\n}\n","path":null,"size_bytes":5601,"size_tokens":null},"client/src/lib/game/weapons/OrbitingShieldWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { WeaponRarity } from \"./WeaponRarity\";\n\ninterface Shield {\n  angle: number;\n  hitCooldowns: Map<Enemy, number>;\n}\n\nexport class OrbitingShieldWeapon {\n  private damage: number;\n  private orbitRadius: number;\n  private rotationSpeed: number;\n  private shieldCount: number;\n  private hitCooldown: number;\n  private shields: Shield[] = [];\n  private level: number = 1;\n  private rarity: WeaponRarity = WeaponRarity.Common;\n  private evolved: boolean = false;\n  private shieldSize: number = 20;\n  private blockedProjectiles: number = 0;\n\n  constructor() {\n    this.damage = 15;\n    this.orbitRadius = 80;\n    this.rotationSpeed = 2;\n    this.shieldCount = 3;\n    this.hitCooldown = 0.5;\n    this.initializeShields();\n  }\n\n  private initializeShields(): void {\n    this.shields = [];\n    for (let i = 0; i < this.shieldCount; i++) {\n      this.shields.push({\n        angle: (i / this.shieldCount) * Math.PI * 2,\n        hitCooldowns: new Map()\n      });\n    }\n  }\n\n  public update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number\n  ): { enemy: Enemy; damage: number }[] {\n    const hits: { enemy: Enemy; damage: number }[] = [];\n\n    for (const shield of this.shields) {\n      shield.angle += this.getEffectiveRotationSpeed() * deltaTime;\n      \n      for (const [enemy, time] of shield.hitCooldowns) {\n        shield.hitCooldowns.set(enemy, time - deltaTime);\n        if (time - deltaTime <= 0) {\n          shield.hitCooldowns.delete(enemy);\n        }\n      }\n\n      const shieldX = playerX + Math.cos(shield.angle) * this.getEffectiveRadius();\n      const shieldY = playerY + Math.sin(shield.angle) * this.getEffectiveRadius();\n\n      for (const enemy of enemies) {\n        if (!enemy.isAlive() || enemy.getHealth() <= 0) continue;\n        if (shield.hitCooldowns.has(enemy)) continue;\n\n        const dx = enemy.x - shieldX;\n        const dy = enemy.y - shieldY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        const hitRange = this.shieldSize + (enemy.width || 32) / 2;\n        if (distance < hitRange) {\n          hits.push({ enemy, damage: this.getBaseDamage() });\n          shield.hitCooldowns.set(enemy, this.hitCooldown);\n\n          if (this.evolved) {\n            const knockbackForce = 50;\n            const knockbackX = (dx / distance) * knockbackForce;\n            const knockbackY = (dy / distance) * knockbackForce;\n            enemy.x += knockbackX;\n            enemy.y += knockbackY;\n          }\n        }\n      }\n    }\n\n    if (this.shields.length < this.getEffectiveShieldCount()) {\n      const diff = this.getEffectiveShieldCount() - this.shields.length;\n      for (let i = 0; i < diff; i++) {\n        const newAngle = (this.shields.length / this.getEffectiveShieldCount()) * Math.PI * 2;\n        this.shields.push({\n          angle: newAngle,\n          hitCooldowns: new Map()\n        });\n      }\n    }\n\n    return hits;\n  }\n\n  public getShieldPositions(playerX: number, playerY: number): { x: number; y: number }[] {\n    return this.shields.map(shield => ({\n      x: playerX + Math.cos(shield.angle) * this.getEffectiveRadius(),\n      y: playerY + Math.sin(shield.angle) * this.getEffectiveRadius()\n    }));\n  }\n\n  public checkProjectileBlock(\n    projectileX: number,\n    projectileY: number,\n    playerX: number,\n    playerY: number\n  ): boolean {\n    for (const shield of this.shields) {\n      const shieldX = playerX + Math.cos(shield.angle) * this.getEffectiveRadius();\n      const shieldY = playerY + Math.sin(shield.angle) * this.getEffectiveRadius();\n\n      const dx = projectileX - shieldX;\n      const dy = projectileY - shieldY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < this.shieldSize + 10) {\n        this.blockedProjectiles++;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getEffectiveRotationSpeed(): number {\n    let speed = this.rotationSpeed + (this.level - 1) * 0.3;\n    \n    if (this.evolved) {\n      speed *= 1.5;\n    }\n\n    return speed;\n  }\n\n  private getEffectiveRadius(): number {\n    let radius = this.orbitRadius + (this.level - 1) * 10;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        radius *= 1.1;\n        break;\n      case WeaponRarity.Legendary:\n        radius *= 1.2;\n        break;\n    }\n\n    return radius;\n  }\n\n  private getEffectiveShieldCount(): number {\n    let count = this.shieldCount + Math.floor((this.level - 1) / 2);\n    \n    switch (this.rarity) {\n      case WeaponRarity.Legendary:\n        count += 1;\n        break;\n    }\n\n    if (this.evolved) {\n      count += 2;\n    }\n\n    return Math.min(count, 8);\n  }\n\n  private getBaseDamage(): number {\n    let baseDamage = this.damage + (this.level - 1) * 3;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        baseDamage *= 1.25;\n        break;\n      case WeaponRarity.Legendary:\n        baseDamage *= 1.5;\n        break;\n    }\n\n    if (this.evolved) {\n      baseDamage *= 2;\n    }\n\n    return Math.floor(baseDamage);\n  }\n\n  public render(\n    ctx: CanvasRenderingContext2D,\n    playerX: number,\n    playerY: number,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    const screenPlayerX = playerX - cameraX;\n    const screenPlayerY = playerY - cameraY;\n\n    ctx.save();\n\n    ctx.strokeStyle = this.evolved ? \"rgba(255, 215, 0, 0.3)\" : \"rgba(100, 149, 237, 0.2)\";\n    ctx.lineWidth = 2;\n    ctx.setLineDash([5, 5]);\n    ctx.beginPath();\n    ctx.arc(screenPlayerX, screenPlayerY, this.getEffectiveRadius(), 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.setLineDash([]);\n\n    for (const shield of this.shields) {\n      const shieldX = screenPlayerX + Math.cos(shield.angle) * this.getEffectiveRadius();\n      const shieldY = screenPlayerY + Math.sin(shield.angle) * this.getEffectiveRadius();\n      \n      this.renderShield(ctx, shieldX, shieldY, shield.angle);\n    }\n\n    ctx.restore();\n  }\n\n  private renderShield(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    angle: number\n  ): void {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angle + Math.PI / 2);\n\n    const baseColor = this.evolved ? \"#FFD700\" : \"#6495ED\";\n    const glowColor = this.evolved ? \"#FFA500\" : \"#87CEEB\";\n    const innerColor = this.evolved ? \"#FFFFFF\" : \"#B0C4DE\";\n\n    ctx.shadowColor = baseColor;\n    ctx.shadowBlur = this.evolved ? 20 : 12;\n\n    ctx.fillStyle = baseColor;\n    ctx.beginPath();\n    ctx.moveTo(0, -this.shieldSize);\n    ctx.lineTo(this.shieldSize * 0.7, -this.shieldSize * 0.3);\n    ctx.lineTo(this.shieldSize * 0.7, this.shieldSize * 0.5);\n    ctx.lineTo(0, this.shieldSize);\n    ctx.lineTo(-this.shieldSize * 0.7, this.shieldSize * 0.5);\n    ctx.lineTo(-this.shieldSize * 0.7, -this.shieldSize * 0.3);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.strokeStyle = glowColor;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    ctx.fillStyle = innerColor;\n    ctx.beginPath();\n    ctx.arc(0, 0, this.shieldSize * 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (this.evolved) {\n      ctx.strokeStyle = \"#FFFFFF\";\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(-this.shieldSize * 0.4, -this.shieldSize * 0.2);\n      ctx.lineTo(this.shieldSize * 0.4, -this.shieldSize * 0.2);\n      ctx.moveTo(0, -this.shieldSize * 0.5);\n      ctx.lineTo(0, this.shieldSize * 0.5);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  public upgrade(): void {\n    this.level = Math.min(this.level + 1, 5);\n    this.damage += 3;\n    this.shieldSize += 3;\n    if (this.level === 3) {\n      this.shieldCount = 4;\n    }\n    if (this.level === 5) {\n      this.shieldCount = 5;\n    }\n  }\n\n  public evolve(): void {\n    if (this.level >= 5 && !this.evolved) {\n      this.evolved = true;\n      this.damage *= 2;\n      this.shieldCount += 2;\n      this.shieldSize *= 1.3;\n      this.rotationSpeed *= 1.5;\n      this.initializeShields();\n    }\n  }\n\n  public getLevel(): number {\n    return this.level;\n  }\n\n  public isEvolved(): boolean {\n    return this.evolved;\n  }\n\n  public setRarity(rarity: WeaponRarity): void {\n    this.rarity = rarity;\n  }\n\n  public getRarity(): WeaponRarity {\n    return this.rarity;\n  }\n\n  public getBlockedProjectiles(): number {\n    return this.blockedProjectiles;\n  }\n\n  public getName(): string {\n    return this.evolved ? \"Divine Aegis\" : \"Orbiting Shield\";\n  }\n\n  public getDescription(): string {\n    return this.evolved \n      ? \"Impenetrable divine shields that devastate all who approach\"\n      : \"Protective shields that orbit and damage nearby enemies\";\n  }\n}\n","path":null,"size_bytes":8520,"size_tokens":null},"client/src/components/GameOverScreen.tsx":{"content":"\nimport { useGameState } from \"../lib/stores/useGameState\";\n\nexport default function GameOverScreen() {\n  const { phase, score, level, wave, maxCombo, totalKills, bossesDefeated, restart } = useGameState();\n\n  if (phase !== \"gameOver\") return null;\n\n  const handleRestart = () => {\n    restart();\n  };\n\n  const handleMainMenu = () => {\n    window.location.reload();\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 animate-fadeIn\">\n      <div className=\"bg-gradient-to-b from-red-900 to-black p-8 rounded-lg border-4 border-red-600 text-white max-w-2xl w-full\">\n        <h1 className=\"text-6xl font-bold text-center mb-6 text-red-500 animate-pulse\">\n          GAME OVER\n        </h1>\n        \n        <div className=\"grid grid-cols-2 gap-4 mb-8\">\n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Final Score</div>\n            <div className=\"text-3xl font-bold text-yellow-400\">{score.toLocaleString()}</div>\n          </div>\n          \n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Level Reached</div>\n            <div className=\"text-3xl font-bold text-purple-400\">{level}</div>\n          </div>\n          \n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Wave Survived</div>\n            <div className=\"text-3xl font-bold text-blue-400\">{wave}</div>\n          </div>\n          \n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Max Combo</div>\n            <div className=\"text-3xl font-bold text-orange-400\">{maxCombo}x</div>\n          </div>\n          \n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Total Kills</div>\n            <div className=\"text-3xl font-bold text-red-400\">{totalKills}</div>\n          </div>\n          \n          <div className=\"bg-black bg-opacity-50 p-4 rounded-lg\">\n            <div className=\"text-sm text-gray-400 uppercase mb-1\">Bosses Defeated</div>\n            <div className=\"text-3xl font-bold text-yellow-400\">{bossesDefeated}</div>\n          </div>\n        </div>\n\n        <div className=\"space-y-3\">\n          <button\n            onClick={handleRestart}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white text-xl font-bold rounded-lg transition-all transform hover:scale-105\"\n          >\n            Try Again (R)\n          </button>\n          <button\n            onClick={handleMainMenu}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white text-lg font-bold rounded-lg transition-all\"\n          >\n            Main Menu\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":3077,"size_tokens":null},"client/src/components/AchievementNotification.tsx":{"content":"\nimport { useEffect, useState } from \"react\";\n\ninterface AchievementNotificationProps {\n  achievement: {\n    name: string;\n    description: string;\n    icon: string;\n  } | null;\n  onClose: () => void;\n}\n\nexport default function AchievementNotification({ achievement, onClose }: AchievementNotificationProps) {\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (achievement) {\n      setVisible(true);\n      const timer = setTimeout(() => {\n        setVisible(false);\n        setTimeout(onClose, 300);\n      }, 4000);\n      return () => clearTimeout(timer);\n    }\n  }, [achievement, onClose]);\n\n  if (!achievement) return null;\n\n  return (\n    <div\n      className={`fixed top-20 left-1/2 -translate-x-1/2 z-50 transition-all duration-300 ${\n        visible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4'\n      }`}\n    >\n      <div className=\"bg-gradient-to-r from-yellow-600 to-yellow-500 border-2 border-yellow-300 rounded-lg p-4 shadow-2xl min-w-[300px]\">\n        <div className=\"flex items-center space-x-4\">\n          <div className=\"text-4xl\">{achievement.icon}</div>\n          <div className=\"flex-1\">\n            <div className=\"text-sm font-bold text-yellow-100 uppercase\">\n              Achievement Unlocked!\n            </div>\n            <div className=\"text-lg font-bold text-white\">\n              {achievement.name}\n            </div>\n            <div className=\"text-sm text-yellow-50\">\n              {achievement.description}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":1561,"size_tokens":null},"client/src/components/UpgradeShop.tsx":{"content":"\nimport { useState } from \"react\";\nimport { PersistentProgressionSystem } from \"../lib/game/systems/PersistentProgressionSystem\";\n\ninterface UpgradeShopProps {\n  onClose: () => void;\n}\n\nexport default function UpgradeShop({ onClose }: UpgradeShopProps) {\n  const [data, setData] = useState(PersistentProgressionSystem.load());\n\n  const handleUpgrade = (upgrade: keyof typeof data.permanentUpgrades) => {\n    const success = PersistentProgressionSystem.upgradePermanent(upgrade);\n    if (success) {\n      setData(PersistentProgressionSystem.load());\n    }\n  };\n\n  const upgrades = [\n    { key: \"maxHealth\" as const, name: \"Max Health\", icon: \"\", description: \"+10 max HP per level\" },\n    { key: \"damage\" as const, name: \"Damage\", icon: \"\", description: \"+5% damage per level\" },\n    { key: \"speed\" as const, name: \"Speed\", icon: \"\", description: \"+5% movement speed per level\" },\n    { key: \"pickupRange\" as const, name: \"Pickup Range\", icon: \"\", description: \"+10% XP pickup range per level\" },\n    { key: \"luck\" as const, name: \"Luck\", icon: \"\", description: \"+5% better drops per level\" },\n  ];\n\n  return (\n    <div className=\"absolute inset-0 bg-black bg-opacity-95 flex items-center justify-center z-50\">\n      <div className=\"bg-gray-900 border-2 border-purple-500 rounded-lg p-8 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto\">\n        <div className=\"flex justify-between items-center mb-6\">\n          <h2 className=\"text-4xl font-bold text-purple-400\">Permanent Upgrades</h2>\n          <div className=\"text-2xl text-yellow-400 font-bold\">\n             {data.currency}\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 mb-6\">\n          {upgrades.map((upgrade) => {\n            const level = data.permanentUpgrades[upgrade.key];\n            const cost = PersistentProgressionSystem.getUpgradeCost(upgrade.key);\n            const canAfford = data.currency >= cost;\n\n            return (\n              <div\n                key={upgrade.key}\n                className=\"bg-gray-800 border border-purple-400 rounded-lg p-4 hover:border-purple-300 transition-colors\"\n              >\n                <div className=\"flex items-start justify-between mb-2\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-3xl\">{upgrade.icon}</span>\n                    <div>\n                      <h3 className=\"text-xl font-bold text-white\">{upgrade.name}</h3>\n                      <p className=\"text-sm text-gray-400\">Level {level}</p>\n                    </div>\n                  </div>\n                </div>\n                \n                <p className=\"text-sm text-gray-300 mb-3\">{upgrade.description}</p>\n                \n                <button\n                  onClick={() => handleUpgrade(upgrade.key)}\n                  disabled={!canAfford}\n                  className={`w-full px-4 py-2 rounded font-bold transition-all ${\n                    canAfford\n                      ? \"bg-purple-600 hover:bg-purple-700 text-white\"\n                      : \"bg-gray-700 text-gray-500 cursor-not-allowed\"\n                  }`}\n                >\n                  Upgrade -  {cost}\n                </button>\n              </div>\n            );\n          })}\n        </div>\n\n        <div className=\"bg-gray-800 border border-blue-400 rounded-lg p-4 mb-4\">\n          <h3 className=\"text-xl font-bold text-blue-400 mb-2\">Statistics</h3>\n          <div className=\"grid grid-cols-2 gap-2 text-sm\">\n            <div>Total Runs: <span className=\"text-white\">{data.totalRuns}</span></div>\n            <div>Total Kills: <span className=\"text-white\">{data.totalKills}</span></div>\n            <div>High Score: <span className=\"text-white\">{data.highScore}</span></div>\n            <div>Max Wave: <span className=\"text-white\">{data.statistics.maxWave}</span></div>\n          </div>\n        </div>\n\n        <button\n          onClick={onClose}\n          className=\"w-full px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition-all\"\n        >\n          Close\n        </button>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":4143,"size_tokens":null},"client/src/lib/game/systems/ComboSystem.ts":{"content":"\nexport class ComboSystem {\n  private killCount: number = 0;\n  private comboCount: number = 0;\n  private comboTimer: number = 0;\n  private comboDecayTime: number = 3;\n  private maxCombo: number = 0;\n\n  public addKill(): void {\n    this.killCount++;\n    this.comboCount++;\n    this.comboTimer = this.comboDecayTime;\n    \n    if (this.comboCount > this.maxCombo) {\n      this.maxCombo = this.comboCount;\n    }\n  }\n\n  public update(deltaTime: number): void {\n    if (this.comboTimer > 0) {\n      this.comboTimer -= deltaTime;\n      \n      if (this.comboTimer <= 0) {\n        this.comboCount = 0;\n      }\n    }\n  }\n\n  public getComboMultiplier(): number {\n    if (this.comboCount < 5) return 1;\n    if (this.comboCount < 10) return 1.25;\n    if (this.comboCount < 20) return 1.5;\n    if (this.comboCount < 50) return 2;\n    return 2.5;\n  }\n\n  public getComboCount(): number {\n    return this.comboCount;\n  }\n\n  public getMaxCombo(): number {\n    return this.maxCombo;\n  }\n\n  public getTotalKills(): number {\n    return this.killCount;\n  }\n\n  public getTimeRemaining(): number {\n    return this.comboTimer;\n  }\n\n  public reset(): void {\n    this.killCount = 0;\n    this.comboCount = 0;\n    this.comboTimer = 0;\n  }\n}\n","path":null,"size_bytes":1212,"size_tokens":null},"client/src/lib/game/systems/StatisticsSystem.ts":{"content":"\nexport interface GameStatistics {\n  totalRuns: number;\n  totalKills: number;\n  totalDeaths: number;\n  bossesDefeated: number;\n  highestWave: number;\n  highestLevel: number;\n  highestScore: number;\n  totalPlayTime: number;\n  totalDamageTaken: number;\n  totalDamageDealt: number;\n  totalExperienceGained: number;\n  longestCombo: number;\n  weaponsUnlocked: string[];\n  achievementsEarned: string[];\n  characterStats: {\n    [characterId: string]: {\n      runs: number;\n      kills: number;\n      highestWave: number;\n      totalPlayTime: number;\n    };\n  };\n}\n\nexport class StatisticsSystem {\n  private static STORAGE_KEY = \"vampire_survivors_statistics\";\n\n  static load(): GameStatistics {\n    const saved = localStorage.getItem(this.STORAGE_KEY);\n    if (saved) {\n      return JSON.parse(saved);\n    }\n    return this.getDefaultStats();\n  }\n\n  static save(stats: GameStatistics): void {\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(stats));\n  }\n\n  static getDefaultStats(): GameStatistics {\n    return {\n      totalRuns: 0,\n      totalKills: 0,\n      totalDeaths: 0,\n      bossesDefeated: 0,\n      highestWave: 0,\n      highestLevel: 0,\n      highestScore: 0,\n      totalPlayTime: 0,\n      totalDamageTaken: 0,\n      totalDamageDealt: 0,\n      totalExperienceGained: 0,\n      longestCombo: 0,\n      weaponsUnlocked: [],\n      achievementsEarned: [],\n      characterStats: {}\n    };\n  }\n\n  static recordRun(data: {\n    characterId: string;\n    kills: number;\n    wave: number;\n    level: number;\n    score: number;\n    playTime: number;\n    damageTaken: number;\n    damageDealt: number;\n    experienceGained: number;\n    maxCombo: number;\n    bossesDefeated: number;\n  }): void {\n    const stats = this.load();\n\n    stats.totalRuns++;\n    stats.totalDeaths++;\n    stats.totalKills += data.kills;\n    stats.bossesDefeated += data.bossesDefeated;\n    stats.totalPlayTime += data.playTime;\n    stats.totalDamageTaken += data.damageTaken;\n    stats.totalDamageDealt += data.damageDealt;\n    stats.totalExperienceGained += data.experienceGained;\n\n    if (data.wave > stats.highestWave) stats.highestWave = data.wave;\n    if (data.level > stats.highestLevel) stats.highestLevel = data.level;\n    if (data.score > stats.highestScore) stats.highestScore = data.score;\n    if (data.maxCombo > stats.longestCombo) stats.longestCombo = data.maxCombo;\n\n    // Update character-specific stats\n    if (!stats.characterStats[data.characterId]) {\n      stats.characterStats[data.characterId] = {\n        runs: 0,\n        kills: 0,\n        highestWave: 0,\n        totalPlayTime: 0\n      };\n    }\n\n    const charStats = stats.characterStats[data.characterId];\n    charStats.runs++;\n    charStats.kills += data.kills;\n    charStats.totalPlayTime += data.playTime;\n    if (data.wave > charStats.highestWave) charStats.highestWave = data.wave;\n\n    this.save(stats);\n  }\n\n  static unlockWeapon(weaponId: string): void {\n    const stats = this.load();\n    if (!stats.weaponsUnlocked.includes(weaponId)) {\n      stats.weaponsUnlocked.push(weaponId);\n      this.save(stats);\n    }\n  }\n\n  static earnAchievement(achievementId: string): void {\n    const stats = this.load();\n    if (!stats.achievementsEarned.includes(achievementId)) {\n      stats.achievementsEarned.push(achievementId);\n      this.save(stats);\n    }\n  }\n\n  static reset(): void {\n    this.save(this.getDefaultStats());\n  }\n}\n","path":null,"size_bytes":3378,"size_tokens":null},"client/src/components/PauseMenu.tsx":{"content":"import { useGameState } from \"../lib/stores/useGameState\";\nimport { useAudio } from \"../lib/stores/useAudio\";\n\nexport default function PauseMenu() {\n  const { phase, resume, restart } = useGameState();\n  const { isMuted, toggleMute } = useAudio();\n\n  if (phase !== \"paused\") return null;\n\n  const handleResume = () => {\n    resume();\n  };\n\n  const handleRestart = () => {\n    restart();\n  };\n\n  const handleMainMenu = () => {\n    window.location.reload();\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50\">\n      <div className=\"bg-gradient-to-b from-purple-900 to-black p-8 rounded-lg border-4 border-purple-500 text-white\">\n        <h2 className=\"text-5xl font-bold text-center mb-8 text-purple-400\">PAUSED</h2>\n\n        <div className=\"space-y-4 min-w-[300px]\">\n          <button\n            onClick={handleResume}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white text-xl font-bold rounded-lg transition-all transform hover:scale-105\"\n          >\n            Resume (ESC)\n          </button>\n\n          <button\n            onClick={toggleMute}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-700 hover:to-cyan-700 text-white text-lg font-bold rounded-lg transition-all\"\n          >\n            Sound: {isMuted ? \"OFF\" : \"ON\"}\n          </button>\n\n          <button\n            onClick={handleRestart}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-700 hover:to-orange-700 text-white text-lg font-bold rounded-lg transition-all\"\n          >\n            Restart (R)\n          </button>\n\n          <button\n            onClick={handleMainMenu}\n            className=\"w-full px-6 py-3 bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white text-lg font-bold rounded-lg transition-all\"\n          >\n            Main Menu\n          </button>\n        </div>\n\n        <div className=\"mt-6 text-center text-sm text-gray-400\">\n          <p>ESC - Resume | M - Toggle Sound</p>\n          <p>R - Restart Game</p>\n        </div>\n      </div>\n    </div>\n  );\n}","path":null,"size_bytes":2246,"size_tokens":null},"client/src/lib/game/weapons/FireAuraWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { WeaponRarity } from \"./WeaponRarity\";\n\ninterface BurnEffect {\n  enemy: Enemy;\n  remainingTime: number;\n  damagePerTick: number;\n  tickTimer: number;\n}\n\nexport class FireAuraWeapon {\n  private damage: number;\n  private range: number;\n  private tickInterval: number;\n  private burnDuration: number;\n  private burnDamagePerTick: number;\n  private lastTickTime: number = 0;\n  private activeRadius: number = 0;\n  private burnEffects: Map<Enemy, BurnEffect> = new Map();\n  private level: number = 1;\n  private rarity: WeaponRarity = WeaponRarity.Common;\n  private evolved: boolean = false;\n  private pulsePhase: number = 0;\n\n  constructor() {\n    this.damage = 5;\n    this.range = 100;\n    this.tickInterval = 0.5;\n    this.burnDuration = 3;\n    this.burnDamagePerTick = 2;\n  }\n\n  public update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number\n  ): { enemy: Enemy; damage: number }[] {\n    this.lastTickTime += deltaTime;\n    this.pulsePhase += deltaTime * 3;\n\n    const hits: { enemy: Enemy; damage: number }[] = [];\n\n    this.updateBurnEffects(deltaTime, hits);\n\n    if (this.lastTickTime >= this.tickInterval) {\n      this.lastTickTime = 0;\n\n      const effectiveRange = this.getEffectiveRange();\n      this.activeRadius = effectiveRange;\n\n      for (const enemy of enemies) {\n        if (!enemy.isAlive() || enemy.getHealth() <= 0) continue;\n\n        const dx = enemy.x - playerX;\n        const dy = enemy.y - playerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= effectiveRange) {\n          const auraDamage = this.getBaseDamage();\n          hits.push({ enemy, damage: auraDamage });\n\n          this.applyBurn(enemy);\n        }\n      }\n    }\n\n    return hits;\n  }\n\n  private updateBurnEffects(\n    deltaTime: number,\n    hits: { enemy: Enemy; damage: number }[]\n  ): void {\n    const burnTickInterval = 0.5;\n\n    for (const [enemy, burn] of this.burnEffects) {\n      if (!enemy.isAlive() || enemy.getHealth() <= 0) {\n        this.burnEffects.delete(enemy);\n        continue;\n      }\n\n      burn.remainingTime -= deltaTime;\n      burn.tickTimer += deltaTime;\n\n      if (burn.tickTimer >= burnTickInterval) {\n        burn.tickTimer = 0;\n        hits.push({ enemy, damage: burn.damagePerTick });\n      }\n\n      if (burn.remainingTime <= 0) {\n        this.burnEffects.delete(enemy);\n      }\n    }\n  }\n\n  private applyBurn(enemy: Enemy): void {\n    const burnDamage = this.evolved \n      ? this.burnDamagePerTick * 2 \n      : this.burnDamagePerTick;\n    \n    const burnTime = this.evolved \n      ? this.burnDuration * 1.5 \n      : this.burnDuration;\n\n    this.burnEffects.set(enemy, {\n      enemy,\n      remainingTime: burnTime,\n      damagePerTick: burnDamage + Math.floor(this.level * 0.5),\n      tickTimer: 0\n    });\n  }\n\n  private getEffectiveRange(): number {\n    let range = this.range + (this.level - 1) * 15;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        range *= 1.2;\n        break;\n      case WeaponRarity.Legendary:\n        range *= 1.4;\n        break;\n    }\n\n    if (this.evolved) {\n      range *= 1.5;\n    }\n\n    return range;\n  }\n\n  private getBaseDamage(): number {\n    let baseDamage = this.damage + (this.level - 1) * 2;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        baseDamage *= 1.25;\n        break;\n      case WeaponRarity.Legendary:\n        baseDamage *= 1.5;\n        break;\n    }\n\n    if (this.evolved) {\n      baseDamage *= 2;\n    }\n\n    return Math.floor(baseDamage);\n  }\n\n  public render(\n    ctx: CanvasRenderingContext2D,\n    playerX: number,\n    playerY: number,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    const screenX = playerX - cameraX;\n    const screenY = playerY - cameraY;\n    const effectiveRange = this.getEffectiveRange();\n\n    ctx.save();\n\n    const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;\n    const baseColor = this.evolved ? \"#FF4500\" : \"#FF6B35\";\n    const innerColor = this.evolved ? \"#FFD700\" : \"#FF8C00\";\n\n    const gradient = ctx.createRadialGradient(\n      screenX, screenY, 0,\n      screenX, screenY, effectiveRange\n    );\n    gradient.addColorStop(0, `rgba(255, 200, 0, ${0.3 * pulse})`);\n    gradient.addColorStop(0.5, `rgba(255, 100, 0, ${0.2 * pulse})`);\n    gradient.addColorStop(1, `rgba(255, 50, 0, 0)`);\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, effectiveRange, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.strokeStyle = baseColor;\n    ctx.lineWidth = 2;\n    ctx.globalAlpha = 0.6 * pulse;\n    ctx.setLineDash([10, 5]);\n    ctx.beginPath();\n    ctx.arc(screenX, screenY, effectiveRange, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.setLineDash([]);\n\n    for (const [enemy, burn] of this.burnEffects) {\n      if (enemy.isAlive()) {\n        this.renderBurnEffect(ctx, enemy.x - cameraX, enemy.y - cameraY, burn);\n      }\n    }\n\n    ctx.restore();\n  }\n\n  private renderBurnEffect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    burn: BurnEffect\n  ): void {\n    const alpha = Math.min(burn.remainingTime / this.burnDuration, 1);\n    \n    ctx.save();\n    ctx.globalAlpha = alpha * 0.7;\n    \n    for (let i = 0; i < 3; i++) {\n      const offsetX = (Math.random() - 0.5) * 20;\n      const offsetY = (Math.random() - 0.5) * 20 - 10;\n      const size = 4 + Math.random() * 4;\n      \n      const gradient = ctx.createRadialGradient(\n        x + offsetX, y + offsetY, 0,\n        x + offsetX, y + offsetY, size\n      );\n      gradient.addColorStop(0, \"#FFD700\");\n      gradient.addColorStop(0.5, \"#FF4500\");\n      gradient.addColorStop(1, \"rgba(255, 0, 0, 0)\");\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    ctx.restore();\n  }\n\n  public upgrade(): void {\n    this.level = Math.min(this.level + 1, 5);\n    this.damage += 2;\n    this.range += 15;\n    this.burnDamagePerTick += 1;\n  }\n\n  public evolve(): void {\n    if (this.level >= 5 && !this.evolved) {\n      this.evolved = true;\n      this.damage *= 2;\n      this.range *= 1.5;\n      this.burnDuration *= 1.5;\n      this.burnDamagePerTick *= 2;\n    }\n  }\n\n  public getLevel(): number {\n    return this.level;\n  }\n\n  public isEvolved(): boolean {\n    return this.evolved;\n  }\n\n  public setRarity(rarity: WeaponRarity): void {\n    this.rarity = rarity;\n  }\n\n  public getRarity(): WeaponRarity {\n    return this.rarity;\n  }\n\n  public getName(): string {\n    return this.evolved ? \"Inferno\" : \"Fire Aura\";\n  }\n\n  public getDescription(): string {\n    return this.evolved \n      ? \"A devastating inferno that incinerates all nearby foes\"\n      : \"Burns enemies that get too close\";\n  }\n}\n","path":null,"size_bytes":6743,"size_tokens":null},"client/src/lib/game/weapons/LightningChainWeapon.ts":{"content":"import { Enemy } from \"../entities/enemies/Enemy\";\nimport { WeaponRarity } from \"./WeaponRarity\";\n\ninterface LightningChain {\n  startX: number;\n  startY: number;\n  endX: number;\n  endY: number;\n  alpha: number;\n  thickness: number;\n}\n\nexport class LightningChainWeapon {\n  private damage: number;\n  private cooldown: number;\n  private chainCount: number;\n  private chainDamageMultiplier: number;\n  private chainRange: number;\n  private lastFireTime: number = 0;\n  private activeChains: LightningChain[] = [];\n  private chainDecayRate: number = 3;\n  private level: number = 1;\n  private rarity: WeaponRarity = WeaponRarity.Common;\n  private evolved: boolean = false;\n\n  constructor() {\n    this.damage = 25;\n    this.cooldown = 2;\n    this.chainCount = 3;\n    this.chainDamageMultiplier = 0.8;\n    this.chainRange = 150;\n  }\n\n  public update(\n    deltaTime: number,\n    enemies: Enemy[],\n    playerX: number,\n    playerY: number\n  ): { enemy: Enemy; damage: number }[] {\n    this.lastFireTime += deltaTime;\n\n    this.activeChains = this.activeChains.filter(chain => {\n      chain.alpha -= this.chainDecayRate * deltaTime;\n      return chain.alpha > 0;\n    });\n\n    if (this.lastFireTime < this.cooldown) {\n      return [];\n    }\n\n    const aliveEnemies = enemies.filter(e => e.isAlive() && e.getHealth() > 0);\n    if (aliveEnemies.length === 0) {\n      return [];\n    }\n\n    this.lastFireTime = 0;\n    const hits: { enemy: Enemy; damage: number }[] = [];\n    const hitEnemies = new Set<Enemy>();\n\n    const firstTarget = this.findNearestEnemy(aliveEnemies, playerX, playerY, 300);\n    if (!firstTarget) {\n      return [];\n    }\n\n    let currentDamage = this.getBaseDamage();\n    hits.push({ enemy: firstTarget, damage: currentDamage });\n    hitEnemies.add(firstTarget);\n\n    this.activeChains.push({\n      startX: playerX,\n      startY: playerY,\n      endX: firstTarget.x,\n      endY: firstTarget.y,\n      alpha: 1,\n      thickness: this.evolved ? 4 : 2\n    });\n\n    let lastX = firstTarget.x;\n    let lastY = firstTarget.y;\n    const maxChains = this.evolved ? this.chainCount + 2 : this.chainCount;\n\n    for (let i = 0; i < maxChains; i++) {\n      currentDamage *= this.chainDamageMultiplier;\n      \n      const remainingEnemies = aliveEnemies.filter(e => !hitEnemies.has(e));\n      const nextTarget = this.findNearestEnemy(remainingEnemies, lastX, lastY, this.chainRange);\n      \n      if (!nextTarget) break;\n\n      hits.push({ enemy: nextTarget, damage: Math.floor(currentDamage) });\n      hitEnemies.add(nextTarget);\n\n      this.activeChains.push({\n        startX: lastX,\n        startY: lastY,\n        endX: nextTarget.x,\n        endY: nextTarget.y,\n        alpha: 1,\n        thickness: this.evolved ? 3 : 2\n      });\n\n      lastX = nextTarget.x;\n      lastY = nextTarget.y;\n    }\n\n    return hits;\n  }\n\n  private findNearestEnemy(\n    enemies: Enemy[],\n    x: number,\n    y: number,\n    maxRange: number\n  ): Enemy | null {\n    let nearest: Enemy | null = null;\n    let nearestDistance = maxRange;\n\n    for (const enemy of enemies) {\n      const dx = enemy.x - x;\n      const dy = enemy.y - y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < nearestDistance) {\n        nearest = enemy;\n        nearestDistance = distance;\n      }\n    }\n\n    return nearest;\n  }\n\n  private getBaseDamage(): number {\n    let baseDamage = this.damage + (this.level - 1) * 5;\n    \n    switch (this.rarity) {\n      case WeaponRarity.Rare:\n        baseDamage *= 1.25;\n        break;\n      case WeaponRarity.Legendary:\n        baseDamage *= 1.5;\n        break;\n    }\n\n    if (this.evolved) {\n      baseDamage *= 2;\n    }\n\n    return Math.floor(baseDamage);\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    for (const chain of this.activeChains) {\n      this.renderLightningBolt(ctx, chain, cameraX, cameraY);\n    }\n  }\n\n  private renderLightningBolt(\n    ctx: CanvasRenderingContext2D,\n    chain: LightningChain,\n    cameraX: number,\n    cameraY: number\n  ): void {\n    const startX = chain.startX - cameraX;\n    const startY = chain.startY - cameraY;\n    const endX = chain.endX - cameraX;\n    const endY = chain.endY - cameraY;\n\n    ctx.save();\n    ctx.globalAlpha = chain.alpha;\n\n    const color = this.evolved ? \"#FFD700\" : \"#00BFFF\";\n    const glowColor = this.evolved ? \"#FFA500\" : \"#87CEEB\";\n\n    ctx.shadowColor = color;\n    ctx.shadowBlur = 15;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = chain.thickness;\n    ctx.lineCap = \"round\";\n\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n\n    const segments = 8;\n    const dx = (endX - startX) / segments;\n    const dy = (endY - startY) / segments;\n    const jitter = 10;\n\n    for (let i = 1; i < segments; i++) {\n      const x = startX + dx * i + (Math.random() - 0.5) * jitter;\n      const y = startY + dy * i + (Math.random() - 0.5) * jitter;\n      ctx.lineTo(x, y);\n    }\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    ctx.strokeStyle = glowColor;\n    ctx.lineWidth = chain.thickness * 0.5;\n    ctx.shadowBlur = 5;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  public upgrade(): void {\n    this.level = Math.min(this.level + 1, 5);\n    this.damage += 5;\n    this.chainRange += 20;\n    if (this.level >= 3) {\n      this.chainCount = Math.min(this.chainCount + 1, 5);\n    }\n  }\n\n  public evolve(): void {\n    if (this.level >= 5 && !this.evolved) {\n      this.evolved = true;\n      this.damage *= 2;\n      this.chainCount += 2;\n      this.cooldown *= 0.7;\n    }\n  }\n\n  public getLevel(): number {\n    return this.level;\n  }\n\n  public isEvolved(): boolean {\n    return this.evolved;\n  }\n\n  public setRarity(rarity: WeaponRarity): void {\n    this.rarity = rarity;\n  }\n\n  public getRarity(): WeaponRarity {\n    return this.rarity;\n  }\n\n  public getName(): string {\n    return this.evolved ? \"Thunder God\" : \"Lightning Chain\";\n  }\n\n  public getDescription(): string {\n    return this.evolved \n      ? \"Divine lightning strikes multiple foes with devastating power\"\n      : \"Chain lightning jumps between enemies\";\n  }\n}\n","path":null,"size_bytes":6043,"size_tokens":null},"client/src/components/MainMenu.tsx":{"content":"\nimport { useState } from \"react\";\nimport { SaveSystem } from \"../lib/game/systems/SaveSystem\";\n\ninterface MainMenuProps {\n  onStartNew: () => void;\n  onContinue: () => void;\n  onQuit: () => void;\n}\n\nexport default function MainMenu({ onStartNew, onContinue, onQuit }: MainMenuProps) {\n  const [showSettings, setShowSettings] = useState(false);\n  const saveData = SaveSystem.load();\n  const hasSave = saveData.stats.totalRuns > 0;\n\n  return (\n    <div className=\"fixed inset-0 bg-gradient-to-b from-purple-900 via-black to-black flex items-center justify-center z-50\">\n      <div className=\"text-center\">\n        <h1 className=\"text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 mb-8 animate-pulse\">\n          VAMPIRE SURVIVORS\n        </h1>\n        \n        <div className=\"space-y-4\">\n          <button\n            onClick={onStartNew}\n            className=\"w-64 px-8 py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white text-xl font-bold rounded-lg transition-all transform hover:scale-105\"\n          >\n            NEW GAME\n          </button>\n          \n          {hasSave && (\n            <button\n              onClick={onContinue}\n              className=\"w-64 px-8 py-4 bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-700 hover:to-cyan-700 text-white text-xl font-bold rounded-lg transition-all transform hover:scale-105\"\n            >\n              CONTINUE\n            </button>\n          )}\n          \n          <button\n            onClick={() => setShowSettings(true)}\n            className=\"w-64 px-8 py-4 bg-gray-700 hover:bg-gray-600 text-white text-xl font-bold rounded-lg transition-all\"\n          >\n            SETTINGS\n          </button>\n          \n          <button\n            onClick={onQuit}\n            className=\"w-64 px-8 py-4 bg-red-700 hover:bg-red-600 text-white text-xl font-bold rounded-lg transition-all\"\n          >\n            QUIT\n          </button>\n        </div>\n\n        <div className=\"mt-12 text-gray-400\">\n          <p>Total Runs: {saveData.stats.totalRuns}</p>\n          <p>Highest Wave: {saveData.stats.highestWave}</p>\n          <p>Total Kills: {saveData.stats.totalKills}</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":2271,"size_tokens":null},"client/src/lib/game/entities/enemies/SplittingEnemy.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\n\nexport class SplittingEnemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  private splitLevel: number;\n  private maxSplitLevel: number = 2;\n  private spawnQueue: SplittingEnemy[] = [];\n  private scale: number;\n\n  constructor(x: number, y: number, splitLevel: number = 0) {\n    const baseSize = 90;\n    const sizeMultiplier = 1 - (splitLevel * 0.3);\n    const size = baseSize * sizeMultiplier;\n    \n    super(x, y, size, size);\n    \n    this.splitLevel = splitLevel;\n    this.scale = sizeMultiplier;\n    this.collisionWidth = size * 0.4;\n    this.collisionHeight = size * 0.4;\n    \n    const healthMultiplier = Math.pow(0.33, splitLevel);\n    const damageMultiplier = Math.pow(0.5, splitLevel);\n    \n    this.speed = 45 + (splitLevel * 15);\n    this.health = Math.max(1, Math.floor(3 * healthMultiplier));\n    this.maxHealth = this.health;\n    this.damage = Math.max(5, Math.floor(20 * damageMultiplier));\n    this.scoreValue = Math.max(5, Math.floor(30 / (splitLevel + 1)));\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance > 0) {\n      const wobble = Math.sin(Date.now() * 0.005 + this.x) * 0.3;\n      const moveX = (dx / distance) * this.speed * deltaTime;\n      const moveY = (dy / distance) * this.speed * deltaTime;\n\n      this.x += moveX + wobble * deltaTime * 20;\n      this.y += moveY;\n    }\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n      this.split();\n    }\n  }\n\n  private split(): void {\n    if (this.splitLevel >= this.maxSplitLevel) return;\n\n    const numChildren = 2 + Math.floor(Math.random() * 2);\n    const angleStep = (Math.PI * 2) / numChildren;\n    const spreadDistance = 30;\n\n    for (let i = 0; i < numChildren; i++) {\n      const angle = angleStep * i + Math.random() * 0.5;\n      const spawnX = this.x + Math.cos(angle) * spreadDistance;\n      const spawnY = this.y + Math.sin(angle) * spreadDistance;\n      \n      const child = new SplittingEnemy(spawnX, spawnY, this.splitLevel + 1);\n      this.spawnQueue.push(child);\n    }\n  }\n\n  public getSpawnQueue(): SplittingEnemy[] {\n    const queue = [...this.spawnQueue];\n    this.spawnQueue = [];\n    return queue;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    \n    const wobbleX = Math.sin(Date.now() * 0.003) * 3 * this.scale;\n    const wobbleY = Math.cos(Date.now() * 0.004) * 2 * this.scale;\n    \n    const hue = 120 - (this.splitLevel * 40);\n    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;\n    \n    ctx.beginPath();\n    const blobPoints = 8;\n    for (let i = 0; i <= blobPoints; i++) {\n      const angle = (i / blobPoints) * Math.PI * 2;\n      const radiusVariation = 1 + Math.sin(angle * 3 + Date.now() * 0.005) * 0.15;\n      const radius = (this.width / 2) * radiusVariation;\n      const px = this.x + wobbleX + Math.cos(angle) * radius;\n      const py = this.y + wobbleY + Math.sin(angle) * radius;\n      \n      if (i === 0) {\n        ctx.moveTo(px, py);\n      } else {\n        ctx.lineTo(px, py);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    \n    ctx.fillStyle = `hsl(${hue}, 60%, 30%)`;\n    ctx.beginPath();\n    ctx.arc(this.x + wobbleX, this.y + wobbleY, this.width / 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#ffffff\";\n    const eyeSize = 6 * this.scale;\n    ctx.beginPath();\n    ctx.arc(this.x + wobbleX - 10 * this.scale, this.y + wobbleY - 5 * this.scale, eyeSize, 0, Math.PI * 2);\n    ctx.arc(this.x + wobbleX + 10 * this.scale, this.y + wobbleY - 5 * this.scale, eyeSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#000000\";\n    const pupilSize = 3 * this.scale;\n    ctx.beginPath();\n    ctx.arc(this.x + wobbleX - 10 * this.scale, this.y + wobbleY - 5 * this.scale, pupilSize, 0, Math.PI * 2);\n    ctx.arc(this.x + wobbleX + 10 * this.scale, this.y + wobbleY - 5 * this.scale, pupilSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    if (this.splitLevel > 0) {\n      ctx.fillStyle = \"rgba(255, 255, 255, 0.3)\";\n      ctx.font = `${12 * this.scale}px Arial`;\n      ctx.fillText(`${this.splitLevel + 1}`, this.x + wobbleX - 6, this.y + wobbleY + 20 * this.scale);\n    }\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n    \n    ctx.restore();\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth * healthPercent, barHeight);\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return \"splitting\";\n  }\n\n  public getSplitLevel(): number {\n    return this.splitLevel;\n  }\n\n  public canSplit(): boolean {\n    return this.splitLevel < this.maxSplitLevel;\n  }\n}\n","path":null,"size_bytes":5712,"size_tokens":null},"client/src/lib/game/rendering/DamageNumber.ts":{"content":"\nexport class DamageNumber {\n  public x: number;\n  public y: number;\n  private damage: number;\n  private lifetime: number = 1;\n  private maxLifetime: number = 1;\n  private velocityY: number = -50;\n  private isCritical: boolean;\n\n  constructor(x: number, y: number, damage: number, isCritical: boolean = false) {\n    this.x = x + (Math.random() - 0.5) * 20;\n    this.y = y;\n    this.damage = Math.ceil(damage);\n    this.isCritical = isCritical;\n  }\n\n  public update(deltaTime: number): void {\n    this.lifetime -= deltaTime;\n    this.y += this.velocityY * deltaTime;\n    this.velocityY += 100 * deltaTime;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    const alpha = this.lifetime / this.maxLifetime;\n    \n    ctx.save();\n    ctx.globalAlpha = alpha;\n    \n    ctx.font = this.isCritical ? \"bold 24px Arial\" : \"bold 16px Arial\";\n    ctx.fillStyle = this.isCritical ? \"#ff0000\" : \"#ffff00\";\n    ctx.strokeStyle = \"#000000\";\n    ctx.lineWidth = 3;\n    \n    if (this.isCritical) {\n      ctx.shadowColor = \"#ff0000\";\n      ctx.shadowBlur = 10;\n    }\n\n    const text = this.isCritical ? `${this.damage}!` : `${this.damage}`;\n    ctx.strokeText(text, this.x, this.y);\n    ctx.fillText(text, this.x, this.y);\n    \n    ctx.restore();\n  }\n\n  public isAlive(): boolean {\n    return this.lifetime > 0;\n  }\n}\n\nexport class DamageNumberManager {\n  private numbers: DamageNumber[] = [];\n\n  public addDamageNumber(x: number, y: number, damage: number, isCritical: boolean = false): void {\n    this.numbers.push(new DamageNumber(x, y, damage, isCritical));\n  }\n\n  public update(deltaTime: number): void {\n    this.numbers = this.numbers.filter(number => {\n      number.update(deltaTime);\n      return number.isAlive();\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    this.numbers.forEach(number => number.render(ctx));\n  }\n\n  public clear(): void {\n    this.numbers = [];\n  }\n}\n","path":null,"size_bytes":1901,"size_tokens":null},"client/src/lib/game/entities/enemies/EnemyProjectile.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\n\nexport class EnemyProjectile extends BaseEntity {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private velocityX: number;\n  private velocityY: number;\n  private speed: number;\n  private damage: number;\n  private lifetime: number;\n  private maxLifetime: number;\n\n  constructor(x: number, y: number, targetX: number, targetY: number, damage: number = 10) {\n    super(x, y, 12, 12);\n    this.collisionWidth = 10;\n    this.collisionHeight = 10;\n    this.speed = 200;\n    this.damage = damage;\n    this.lifetime = 0;\n    this.maxLifetime = 5;\n\n    const dx = targetX - x;\n    const dy = targetY - y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance > 0) {\n      this.velocityX = (dx / distance) * this.speed;\n      this.velocityY = (dy / distance) * this.speed;\n    } else {\n      this.velocityX = 0;\n      this.velocityY = this.speed;\n    }\n  }\n\n  public update(deltaTime: number): void {\n    if (!this.alive) return;\n\n    this.x += this.velocityX * deltaTime;\n    this.y += this.velocityY * deltaTime;\n    \n    this.lifetime += deltaTime;\n    if (this.lifetime >= this.maxLifetime) {\n      this.alive = false;\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    \n    ctx.fillStyle = \"#cc00cc\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#ff66ff\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.restore();\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public markForRemoval(): void {\n    this.alive = false;\n  }\n}\n","path":null,"size_bytes":1742,"size_tokens":null},"client/src/components/SettingsMenu.tsx":{"content":"\nimport { useAudio } from \"../lib/stores/useAudio\";\nimport { useState } from \"react\";\n\ninterface SettingsMenuProps {\n  onClose: () => void;\n}\n\nexport default function SettingsMenu({ onClose }: SettingsMenuProps) {\n  const { isMuted, toggleMute, musicVolume: globalMusicVolume, sfxVolume: globalSfxVolume, setMusicVolume: setGlobalMusicVolume, setSfxVolume: setGlobalSfxVolume } = useAudio();\n  const [musicVolume, setMusicVolume] = useState(globalMusicVolume);\n  const [sfxVolume, setSfxVolume] = useState(globalSfxVolume);\n\n  const handleMusicVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const volume = parseFloat(e.target.value);\n    setMusicVolume(volume);\n    setGlobalMusicVolume(volume);\n  };\n\n  const handleSfxVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const volume = parseFloat(e.target.value);\n    setSfxVolume(volume);\n    setGlobalSfxVolume(volume);\n  };\n\n  return (\n    <div className=\"absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50\">\n      <div className=\"bg-gray-900 border-2 border-purple-500 rounded-lg p-8 max-w-md w-full mx-4\">\n        <h2 className=\"text-3xl font-bold text-purple-400 text-center mb-6\">Settings</h2>\n        \n        <div className=\"space-y-6\">\n          <div>\n            <label className=\"flex items-center justify-between mb-2\">\n              <span className=\"text-white font-bold\">Master Audio</span>\n              <button\n                onClick={toggleMute}\n                className={`px-4 py-2 rounded ${\n                  isMuted ? 'bg-red-600' : 'bg-green-600'\n                } text-white font-bold`}\n              >\n                {isMuted ? 'Muted' : 'Unmuted'}\n              </button>\n            </label>\n          </div>\n\n          <div>\n            <label className=\"block text-white font-bold mb-2\">\n              Music Volume: {Math.round(musicVolume * 100)}%\n            </label>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"1\"\n              step=\"0.1\"\n              value={musicVolume}\n              onChange={handleMusicVolumeChange}\n              className=\"w-full\"\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-white font-bold mb-2\">\n              SFX Volume: {Math.round(sfxVolume * 100)}%\n            </label>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"1\"\n              step=\"0.1\"\n              value={sfxVolume}\n              onChange={handleSfxVolumeChange}\n              className=\"w-full\"\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-white font-bold mb-2\">\n              SFX Volume: {Math.round(sfxVolume * 100)}%\n            </label>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"1\"\n              step=\"0.1\"\n              value={sfxVolume}\n              onChange={handleSfxVolumeChange}\n              className=\"w-full\"\n            />\n          </div>\n\n          <div className=\"pt-4\">\n            <button\n              onClick={onClose}\n              className=\"w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg transition-all duration-200\"\n            >\n              Back\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":3350,"size_tokens":null},"client/src/lib/game/weapons/WeaponRarity.ts":{"content":"export enum WeaponRarity {\n  Common = \"common\",\n  Rare = \"rare\",\n  Legendary = \"legendary\"\n}\n\nexport interface WeaponRarityConfig {\n  rarity: WeaponRarity;\n  color: string;\n  glowColor: string;\n  damageMultiplier: number;\n  dropChance: number;\n  displayName: string;\n}\n\nexport const WEAPON_RARITY_CONFIGS: Record<WeaponRarity, WeaponRarityConfig> = {\n  [WeaponRarity.Common]: {\n    rarity: WeaponRarity.Common,\n    color: \"#FFFFFF\",\n    glowColor: \"#CCCCCC\",\n    damageMultiplier: 1.0,\n    dropChance: 0.70,\n    displayName: \"Common\"\n  },\n  [WeaponRarity.Rare]: {\n    rarity: WeaponRarity.Rare,\n    color: \"#4169E1\",\n    glowColor: \"#6495ED\",\n    damageMultiplier: 1.25,\n    dropChance: 0.25,\n    displayName: \"Rare\"\n  },\n  [WeaponRarity.Legendary]: {\n    rarity: WeaponRarity.Legendary,\n    color: \"#FFD700\",\n    glowColor: \"#FFA500\",\n    damageMultiplier: 1.5,\n    dropChance: 0.05,\n    displayName: \"Legendary\"\n  }\n};\n\nexport function getRandomRarity(): WeaponRarity {\n  const roll = Math.random();\n  \n  if (roll < WEAPON_RARITY_CONFIGS[WeaponRarity.Legendary].dropChance) {\n    return WeaponRarity.Legendary;\n  }\n  \n  if (roll < WEAPON_RARITY_CONFIGS[WeaponRarity.Legendary].dropChance + \n              WEAPON_RARITY_CONFIGS[WeaponRarity.Rare].dropChance) {\n    return WeaponRarity.Rare;\n  }\n  \n  return WeaponRarity.Common;\n}\n\nexport function getRarityConfig(rarity: WeaponRarity): WeaponRarityConfig {\n  return WEAPON_RARITY_CONFIGS[rarity];\n}\n\nexport function getRarityColor(rarity: WeaponRarity): string {\n  return WEAPON_RARITY_CONFIGS[rarity].color;\n}\n\nexport function getRarityDisplayName(rarity: WeaponRarity): string {\n  return WEAPON_RARITY_CONFIGS[rarity].displayName;\n}\n","path":null,"size_bytes":1686,"size_tokens":null},"client/src/lib/game/systems/PersistentProgressionSystem.ts":{"content":"\nimport { useGameState } from \"../../stores/useGameState\";\n\nexport interface PersistentData {\n  totalKills: number;\n  totalRuns: number;\n  highScore: number;\n  currency: number;\n  unlockedCharacters: string[];\n  permanentUpgrades: {\n    maxHealth: number;\n    damage: number;\n    speed: number;\n    pickupRange: number;\n    luck: number;\n  };\n  achievements: string[];\n  statistics: {\n    totalDamageDealt: number;\n    totalDamageTaken: number;\n    totalPlayTime: number;\n    bossesDefeated: number;\n    maxWave: number;\n    maxCombo: number;\n  };\n}\n\nexport class PersistentProgressionSystem {\n  private static SAVE_KEY = \"vampire_survivors_save\";\n\n  static getDefaultData(): PersistentData {\n    return {\n      totalKills: 0,\n      totalRuns: 0,\n      highScore: 0,\n      currency: 0,\n      unlockedCharacters: [\"guardian\"],\n      permanentUpgrades: {\n        maxHealth: 0,\n        damage: 0,\n        speed: 0,\n        pickupRange: 0,\n        luck: 0,\n      },\n      achievements: [],\n      statistics: {\n        totalDamageDealt: 0,\n        totalDamageTaken: 0,\n        totalPlayTime: 0,\n        bossesDefeated: 0,\n        maxWave: 0,\n        maxCombo: 0,\n      },\n    };\n  }\n\n  static save(data: Partial<PersistentData>): void {\n    try {\n      const existing = this.load();\n      const merged = { ...existing, ...data };\n      localStorage.setItem(this.SAVE_KEY, JSON.stringify(merged));\n      console.log(\"Game saved successfully\");\n    } catch (error) {\n      console.error(\"Failed to save game:\", error);\n    }\n  }\n\n  static load(): PersistentData {\n    try {\n      const saved = localStorage.getItem(this.SAVE_KEY);\n      if (!saved) return this.getDefaultData();\n      \n      const data = JSON.parse(saved);\n      return { ...this.getDefaultData(), ...data };\n    } catch (error) {\n      console.error(\"Failed to load game:\", error);\n      return this.getDefaultData();\n    }\n  }\n\n  static updateStatistics(stats: Partial<PersistentData[\"statistics\"]>): void {\n    const data = this.load();\n    data.statistics = { ...data.statistics, ...stats };\n    this.save(data);\n  }\n\n  static addCurrency(amount: number): void {\n    const data = this.load();\n    data.currency += amount;\n    this.save(data);\n  }\n\n  static spendCurrency(amount: number): boolean {\n    const data = this.load();\n    if (data.currency >= amount) {\n      data.currency -= amount;\n      this.save(data);\n      return true;\n    }\n    return false;\n  }\n\n  static unlockCharacter(characterId: string): void {\n    const data = this.load();\n    if (!data.unlockedCharacters.includes(characterId)) {\n      data.unlockedCharacters.push(characterId);\n      this.save(data);\n    }\n  }\n\n  static isCharacterUnlocked(characterId: string): boolean {\n    const data = this.load();\n    return data.unlockedCharacters.includes(characterId);\n  }\n\n  static upgradePermanent(upgrade: keyof PersistentData[\"permanentUpgrades\"]): boolean {\n    const cost = this.getUpgradeCost(upgrade);\n    if (this.spendCurrency(cost)) {\n      const data = this.load();\n      data.permanentUpgrades[upgrade] += 1;\n      this.save(data);\n      return true;\n    }\n    return false;\n  }\n\n  static getUpgradeCost(upgrade: keyof PersistentData[\"permanentUpgrades\"]): number {\n    const data = this.load();\n    const level = data.permanentUpgrades[upgrade];\n    return Math.floor(100 * Math.pow(1.5, level));\n  }\n\n  static unlockAchievement(achievementId: string): void {\n    const data = this.load();\n    if (!data.achievements.includes(achievementId)) {\n      data.achievements.push(achievementId);\n      this.save(data);\n      \n      // Trigger achievement notification\n      if (typeof window !== 'undefined') {\n        const event = new CustomEvent('achievement', { detail: { id: achievementId } });\n        window.dispatchEvent(event);\n      }\n    }\n  }\n\n  static recordRunEnd(score: number, wave: number, kills: number, combo: number, bossesDefeated: number, playTime: number): void {\n    const data = this.load();\n    \n    data.totalRuns += 1;\n    data.totalKills += kills;\n    data.highScore = Math.max(data.highScore, score);\n    data.statistics.maxWave = Math.max(data.statistics.maxWave, wave);\n    data.statistics.maxCombo = Math.max(data.statistics.maxCombo, combo);\n    data.statistics.bossesDefeated += bossesDefeated;\n    data.statistics.totalPlayTime += playTime;\n    \n    this.save(data);\n  }\n\n  static reset(): void {\n    localStorage.removeItem(this.SAVE_KEY);\n    console.log(\"Save data reset\");\n  }\n}\n","path":null,"size_bytes":4460,"size_tokens":null},"client/src/lib/game/weapons/LaserBeamWeapon.ts":{"content":"\nimport { BaseWeapon } from \"../core/base/BaseWeapon\";\nimport { IProjectile } from \"../core/interfaces/IProjectile\";\n\ninterface LaserBeam {\n  angle: number;\n  length: number;\n  active: boolean;\n  rotationSpeed: number;\n}\n\nexport class LaserBeamWeapon extends BaseWeapon {\n  private beams: LaserBeam[] = [];\n  private beamCount: number = 1;\n  private beamLength: number = 300;\n  private beamDamage: number = 15;\n  private rotationSpeed: number = 2;\n\n  constructor() {\n    super();\n    this.damage = 15;\n    this.fireRate = 1;\n    \n    this.beams.push({\n      angle: 0,\n      length: this.beamLength,\n      active: true,\n      rotationSpeed: this.rotationSpeed\n    });\n  }\n\n  public update(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.beams.forEach(beam => {\n      beam.angle += beam.rotationSpeed * deltaTime;\n      \n      enemies.forEach(enemy => {\n        if (!enemy.isAlive()) return;\n\n        const dx = enemy.x - playerX;\n        const dy = enemy.y - playerY;\n        const distanceToEnemy = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distanceToEnemy > beam.length) return;\n\n        const angleToEnemy = Math.atan2(dy, dx);\n        let angleDiff = Math.abs(beam.angle - angleToEnemy);\n        \n        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n        angleDiff = Math.abs(angleDiff);\n\n        if (angleDiff < 0.1) {\n          enemy.takeDamage(this.beamDamage * deltaTime);\n        }\n      });\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number, playerX: number, playerY: number): void {\n    this.beams.forEach(beam => {\n      ctx.save();\n      \n      const endX = playerX + Math.cos(beam.angle) * beam.length;\n      const endY = playerY + Math.sin(beam.angle) * beam.length;\n\n      const gradient = ctx.createLinearGradient(playerX, playerY, endX, endY);\n      gradient.addColorStop(0, \"rgba(255, 0, 0, 0.8)\");\n      gradient.addColorStop(0.5, \"rgba(255, 100, 100, 0.6)\");\n      gradient.addColorStop(1, \"rgba(255, 0, 0, 0)\");\n\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = 8;\n      ctx.shadowColor = \"#ff0000\";\n      ctx.shadowBlur = 20;\n\n      ctx.beginPath();\n      ctx.moveTo(playerX, playerY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      ctx.restore();\n    });\n  }\n\n  public fire(x: number, y: number, direction: { x: number; y: number }): IProjectile[] {\n    return [];\n  }\n\n  public upgrade(): void {\n    this.beamDamage += 5;\n    this.beamLength += 50;\n    \n    if (this.beams.length < 4) {\n      this.beams.push({\n        angle: Math.random() * Math.PI * 2,\n        length: this.beamLength,\n        active: true,\n        rotationSpeed: this.rotationSpeed\n      });\n    }\n  }\n\n  public getType(): string {\n    return \"laser_beam\";\n  }\n\n  public getBeams(): LaserBeam[] {\n    return this.beams;\n  }\n}\n","path":null,"size_bytes":2839,"size_tokens":null},"client/src/lib/game/systems/SaveSystem.ts":{"content":"\nexport interface PlayerStats {\n  totalKills: number;\n  totalRuns: number;\n  highestWave: number;\n  highestScore: number;\n  totalPlayTime: number;\n  achievements: string[];\n  unlockedCharacters: string[];\n  permanentUpgrades: Record<string, number>;\n  currency: number;\n}\n\nexport interface SaveData {\n  version: string;\n  lastPlayed: Date;\n  stats: PlayerStats;\n  settings: {\n    volume: number;\n    sfxVolume: number;\n    isMuted: boolean;\n  };\n}\n\nexport class SaveSystem {\n  private static readonly SAVE_KEY = \"vampire_survivors_save\";\n  private static readonly VERSION = \"1.0.0\";\n\n  public static save(data: Partial<SaveData>): void {\n    const existingData = this.load();\n    const saveData: SaveData = {\n      ...existingData,\n      ...data,\n      version: this.VERSION,\n      lastPlayed: new Date()\n    };\n\n    try {\n      localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));\n      console.log(\"Game saved successfully\");\n    } catch (error) {\n      console.error(\"Failed to save game:\", error);\n    }\n  }\n\n  public static load(): SaveData {\n    try {\n      const saved = localStorage.getItem(this.SAVE_KEY);\n      if (!saved) {\n        return this.getDefaultSave();\n      }\n\n      const data = JSON.parse(saved) as SaveData;\n      \n      if (data.version !== this.VERSION) {\n        console.warn(\"Save version mismatch, migrating...\");\n        return this.migrateSave(data);\n      }\n\n      return data;\n    } catch (error) {\n      console.error(\"Failed to load save:\", error);\n      return this.getDefaultSave();\n    }\n  }\n\n  public static getDefaultSave(): SaveData {\n    return {\n      version: this.VERSION,\n      lastPlayed: new Date(),\n      stats: {\n        totalKills: 0,\n        totalRuns: 0,\n        highestWave: 0,\n        highestScore: 0,\n        totalPlayTime: 0,\n        achievements: [],\n        unlockedCharacters: [\"warrior\"],\n        permanentUpgrades: {},\n        currency: 0\n      },\n      settings: {\n        volume: 0.3,\n        sfxVolume: 0.5,\n        isMuted: false\n      }\n    };\n  }\n\n  private static migrateSave(oldData: SaveData): SaveData {\n    return {\n      ...this.getDefaultSave(),\n      ...oldData,\n      version: this.VERSION\n    };\n  }\n\n  public static updateStats(updates: Partial<PlayerStats>): void {\n    const data = this.load();\n    data.stats = { ...data.stats, ...updates };\n    this.save(data);\n  }\n\n  public static addCurrency(amount: number): void {\n    const data = this.load();\n    data.stats.currency += amount;\n    this.save(data);\n  }\n\n  public static spendCurrency(amount: number): boolean {\n    const data = this.load();\n    if (data.stats.currency >= amount) {\n      data.stats.currency -= amount;\n      this.save(data);\n      return true;\n    }\n    return false;\n  }\n\n  public static unlockCharacter(characterId: string): void {\n    const data = this.load();\n    if (!data.stats.unlockedCharacters.includes(characterId)) {\n      data.stats.unlockedCharacters.push(characterId);\n      this.save(data);\n    }\n  }\n\n  public static unlockAchievement(achievementId: string): void {\n    const data = this.load();\n    if (!data.stats.achievements.includes(achievementId)) {\n      data.stats.achievements.push(achievementId);\n      this.save(data);\n    }\n  }\n\n  public static reset(): void {\n    localStorage.removeItem(this.SAVE_KEY);\n    console.log(\"Save data reset\");\n  }\n}\n","path":null,"size_bytes":3341,"size_tokens":null},"client/src/components/StatisticsScreen.tsx":{"content":"\nimport { StatisticsSystem } from \"../lib/game/systems/StatisticsSystem\";\n\ninterface StatisticsScreenProps {\n  onClose: () => void;\n}\n\nexport default function StatisticsScreen({ onClose }: StatisticsScreenProps) {\n  const stats = StatisticsSystem.load();\n\n  const formatTime = (seconds: number): string => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4 overflow-y-auto\">\n      <div className=\"bg-gradient-to-b from-purple-900 to-black p-8 rounded-lg border-4 border-purple-500 text-white max-w-4xl w-full my-8\">\n        <h1 className=\"text-5xl font-bold text-center mb-8 text-purple-400\">Statistics</h1>\n        \n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6 mb-8\">\n          {/* Overall Stats */}\n          <div className=\"bg-black bg-opacity-50 p-6 rounded-lg border-2 border-purple-400\">\n            <h2 className=\"text-2xl font-bold mb-4 text-purple-300\">Overall</h2>\n            <div className=\"space-y-2\">\n              <StatRow label=\"Total Runs\" value={stats.totalRuns.toLocaleString()} />\n              <StatRow label=\"Total Kills\" value={stats.totalKills.toLocaleString()} />\n              <StatRow label=\"Bosses Defeated\" value={stats.bossesDefeated.toLocaleString()} />\n              <StatRow label=\"Total Deaths\" value={stats.totalDeaths.toLocaleString()} />\n              <StatRow label=\"Total Play Time\" value={formatTime(stats.totalPlayTime)} />\n            </div>\n          </div>\n\n          {/* Records */}\n          <div className=\"bg-black bg-opacity-50 p-6 rounded-lg border-2 border-yellow-400\">\n            <h2 className=\"text-2xl font-bold mb-4 text-yellow-300\">Records</h2>\n            <div className=\"space-y-2\">\n              <StatRow label=\"Highest Score\" value={stats.highestScore.toLocaleString()} color=\"text-yellow-400\" />\n              <StatRow label=\"Highest Wave\" value={stats.highestWave.toString()} color=\"text-blue-400\" />\n              <StatRow label=\"Highest Level\" value={stats.highestLevel.toString()} color=\"text-purple-400\" />\n              <StatRow label=\"Longest Combo\" value={`${stats.longestCombo}x`} color=\"text-orange-400\" />\n              <StatRow label=\"Weapons Unlocked\" value={stats.weaponsUnlocked.length.toString()} color=\"text-green-400\" />\n            </div>\n          </div>\n\n          {/* Combat Stats */}\n          <div className=\"bg-black bg-opacity-50 p-6 rounded-lg border-2 border-red-400\">\n            <h2 className=\"text-2xl font-bold mb-4 text-red-300\">Combat</h2>\n            <div className=\"space-y-2\">\n              <StatRow label=\"Damage Dealt\" value={Math.floor(stats.totalDamageDealt).toLocaleString()} />\n              <StatRow label=\"Damage Taken\" value={Math.floor(stats.totalDamageTaken).toLocaleString()} />\n              <StatRow label=\"Experience Gained\" value={stats.totalExperienceGained.toLocaleString()} />\n              <StatRow label=\"Avg Kills/Run\" value={stats.totalRuns > 0 ? Math.floor(stats.totalKills / stats.totalRuns).toString() : \"0\"} />\n            </div>\n          </div>\n\n          {/* Achievements */}\n          <div className=\"bg-black bg-opacity-50 p-6 rounded-lg border-2 border-green-400\">\n            <h2 className=\"text-2xl font-bold mb-4 text-green-300\">Progress</h2>\n            <div className=\"space-y-2\">\n              <StatRow label=\"Achievements\" value={`${stats.achievementsEarned.length}/50`} color=\"text-green-400\" />\n              <StatRow label=\"Weapons\" value={`${stats.weaponsUnlocked.length}/15`} color=\"text-blue-400\" />\n              <StatRow label=\"Characters Used\" value={Object.keys(stats.characterStats).length.toString()} />\n            </div>\n          </div>\n        </div>\n\n        <button\n          onClick={onClose}\n          className=\"w-full px-6 py-3 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white text-xl font-bold rounded-lg transition-all transform hover:scale-105\"\n        >\n          Close\n        </button>\n      </div>\n    </div>\n  );\n}\n\nfunction StatRow({ label, value, color = \"text-white\" }: { label: string; value: string; color?: string }) {\n  return (\n    <div className=\"flex justify-between items-center\">\n      <span className=\"text-gray-300\">{label}:</span>\n      <span className={`font-bold ${color}`}>{value}</span>\n    </div>\n  );\n}\n","path":null,"size_bytes":4489,"size_tokens":null},"client/src/lib/game/entities/enemies/FlyingEnemy.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\n\nexport class FlyingEnemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  \n  private sineOffset: number = 0;\n  private sineAmplitude: number = 50;\n  private sineFrequency: number = 3;\n  private baseY: number = 0;\n  private swoopTimer: number = 0;\n  private swoopCooldown: number = 4;\n  private isSwooping: boolean = false;\n  private swoopDuration: number = 0.8;\n  private swoopProgress: number = 0;\n  private swoopStartY: number = 0;\n  private swoopTargetY: number = 0;\n  public ignoresTerrain: boolean = true;\n\n  constructor(x: number, y: number) {\n    super(x, y, 60, 60);\n    this.baseY = y;\n    this.collisionWidth = 24;\n    this.collisionHeight = 24;\n    \n    this.speed = 90;\n    this.health = 1;\n    this.maxHealth = 1;\n    this.damage = 15;\n    this.scoreValue = 20;\n    \n    this.sineOffset = Math.random() * Math.PI * 2;\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (!this.isSwooping) {\n      if (distance > 0) {\n        const moveX = (dx / distance) * this.speed * deltaTime;\n        this.x += moveX;\n        this.baseY += (dy / distance) * this.speed * deltaTime * 0.3;\n      }\n\n      this.sineOffset += this.sineFrequency * deltaTime;\n      this.y = this.baseY + Math.sin(this.sineOffset) * this.sineAmplitude;\n\n      this.swoopTimer += deltaTime;\n      if (this.swoopTimer >= this.swoopCooldown && distance < 200) {\n        this.startSwoop(playerPos);\n      }\n    } else {\n      this.swoopProgress += deltaTime / this.swoopDuration;\n      \n      if (this.swoopProgress >= 1) {\n        this.isSwooping = false;\n        this.swoopProgress = 0;\n        this.swoopTimer = 0;\n        this.baseY = this.y;\n      } else {\n        const swoopCurve = Math.sin(this.swoopProgress * Math.PI);\n        this.y = this.swoopStartY + (this.swoopTargetY - this.swoopStartY) * swoopCurve;\n        \n        if (distance > 0) {\n          this.x += (dx / distance) * this.speed * 1.5 * deltaTime;\n        }\n      }\n    }\n  }\n\n  private startSwoop(playerPos: { x: number; y: number }): void {\n    this.isSwooping = true;\n    this.swoopProgress = 0;\n    this.swoopStartY = this.y;\n    this.swoopTargetY = playerPos.y;\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    \n    ctx.fillStyle = this.isSwooping ? \"#ff6600\" : \"#ff9944\";\n    \n    ctx.beginPath();\n    ctx.moveTo(this.x, this.y - this.height / 2);\n    ctx.lineTo(this.x - this.width / 2, this.y);\n    ctx.lineTo(this.x - this.width / 4, this.y + this.height / 4);\n    ctx.lineTo(this.x, this.y);\n    ctx.lineTo(this.x + this.width / 4, this.y + this.height / 4);\n    ctx.lineTo(this.x + this.width / 2, this.y);\n    ctx.closePath();\n    ctx.fill();\n    \n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(this.x - 8, this.y - 5, 4, 0, Math.PI * 2);\n    ctx.arc(this.x + 8, this.y - 5, 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#000000\";\n    ctx.beginPath();\n    ctx.arc(this.x - 8, this.y - 5, 2, 0, Math.PI * 2);\n    ctx.arc(this.x + 8, this.y - 5, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n    \n    ctx.restore();\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth * healthPercent, barHeight);\n  }\n\n  public takeDamage(amount: number): void {\n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return \"flying\";\n  }\n\n  public isSwoopingState(): boolean {\n    return this.isSwooping;\n  }\n}\n","path":null,"size_bytes":4634,"size_tokens":null},"client/src/components/Minimap.tsx":{"content":"import { useEffect, useRef } from \"react\";\n\ninterface MinimapProps {\n  playerX: number;\n  playerY: number;\n  enemies: Array<{ x: number; y: number; isBoss?: boolean }>;\n}\n\nexport default function Minimap({ playerX, playerY, enemies }: MinimapProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const size = 150;\n  const viewRange = 800;\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Clear\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.8)\";\n    ctx.fillRect(0, 0, size, size);\n\n    // Border\n    ctx.strokeStyle = \"#4a5568\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 0, size, size);\n\n    // Center (player)\n    const centerX = size / 2;\n    const centerY = size / 2;\n\n    // Draw player\n    ctx.fillStyle = \"#00ff00\";\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw enemies\n    enemies.forEach((enemy) => {\n      const dx = enemy.x - playerX;\n      const dy = enemy.y - playerY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < viewRange) {\n        const scale = size / (viewRange * 2);\n        const ex = centerX + dx * scale;\n        const ey = centerY + dy * scale;\n\n        ctx.fillStyle = enemy.isBoss ? \"#ff0000\" : \"#ff6600\";\n        ctx.beginPath();\n        ctx.arc(ex, ey, enemy.isBoss ? 3 : 2, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    });\n\n    // Draw range circle\n    ctx.strokeStyle = \"rgba(255, 255, 255, 0.2)\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size / 2 - 2, 0, Math.PI * 2);\n    ctx.stroke();\n  }, [playerX, playerY, enemies]);\n\n  return (\n    <div className=\"bg-black bg-opacity-80 rounded-lg p-2 border border-gray-600\">\n      <canvas\n        ref={canvasRef}\n        width={size}\n        height={size}\n        className=\"block\"\n      />\n      <div className=\"text-xs text-gray-400 text-center mt-1\">Minimap</div>\n    </div>\n  );\n}","path":null,"size_bytes":1987,"size_tokens":null},"client/src/lib/game/entities/collectibles/PassiveItem.ts":{"content":"\nexport type PassiveItemType = \n  | \"armor\" \n  | \"speed_boots\" \n  | \"xp_magnet\" \n  | \"health_regen\" \n  | \"critical_chance\"\n  | \"life_steal\"\n  | \"damage_boost\"\n  | \"cooldown_reduction\";\n\nexport interface PassiveItemData {\n  type: PassiveItemType;\n  name: string;\n  description: string;\n  icon: string;\n  maxStacks: number;\n  effect: (player: any, stacks: number) => void;\n}\n\nexport const PASSIVE_ITEMS: Record<PassiveItemType, PassiveItemData> = {\n  armor: {\n    type: \"armor\",\n    name: \"Iron Armor\",\n    description: \"Reduces incoming damage by 10% per stack\",\n    icon: \"\",\n    maxStacks: 5,\n    effect: (player, stacks) => {\n      player.damageReduction = Math.min(0.5, stacks * 0.1);\n    }\n  },\n  speed_boots: {\n    type: \"speed_boots\",\n    name: \"Swift Boots\",\n    description: \"Increases movement speed by 15% per stack\",\n    icon: \"\",\n    maxStacks: 3,\n    effect: (player, stacks) => {\n      player.speedMultiplier = 1 + (stacks * 0.15);\n    }\n  },\n  xp_magnet: {\n    type: \"xp_magnet\",\n    name: \"XP Magnet\",\n    description: \"Increases XP pickup range by 50 per stack\",\n    icon: \"\",\n    maxStacks: 4,\n    effect: (player, stacks) => {\n      player.xpPickupRange = 100 + (stacks * 50);\n    }\n  },\n  health_regen: {\n    type: \"health_regen\",\n    name: \"Regeneration\",\n    description: \"Regenerate 2 HP per second per stack\",\n    icon: \"\",\n    maxStacks: 5,\n    effect: (player, stacks) => {\n      player.healthRegenRate = stacks * 2;\n    }\n  },\n  critical_chance: {\n    type: \"critical_chance\",\n    name: \"Critical Strike\",\n    description: \"5% chance to deal double damage per stack\",\n    icon: \"\",\n    maxStacks: 4,\n    effect: (player, stacks) => {\n      player.criticalChance = Math.min(0.5, stacks * 0.05);\n    }\n  },\n  life_steal: {\n    type: \"life_steal\",\n    name: \"Life Steal\",\n    description: \"Heal for 5% of damage dealt per stack\",\n    icon: \"\",\n    maxStacks: 3,\n    effect: (player, stacks) => {\n      player.lifeStealPercent = stacks * 0.05;\n    }\n  },\n  damage_boost: {\n    type: \"damage_boost\",\n    name: \"Power Surge\",\n    description: \"Increases all damage by 20% per stack\",\n    icon: \"\",\n    maxStacks: 5,\n    effect: (player, stacks) => {\n      player.damageMultiplier = 1 + (stacks * 0.2);\n    }\n  },\n  cooldown_reduction: {\n    type: \"cooldown_reduction\",\n    name: \"Haste\",\n    description: \"Reduces all cooldowns by 10% per stack\",\n    icon: \"\",\n    maxStacks: 4,\n    effect: (player, stacks) => {\n      player.cooldownReduction = Math.min(0.4, stacks * 0.1);\n    }\n  }\n};\n\nexport class PassiveItemManager {\n  private items: Map<PassiveItemType, number> = new Map();\n\n  public addItem(type: PassiveItemType): boolean {\n    const itemData = PASSIVE_ITEMS[type];\n    const currentStacks = this.items.get(type) || 0;\n\n    if (currentStacks >= itemData.maxStacks) {\n      return false;\n    }\n\n    this.items.set(type, currentStacks + 1);\n    return true;\n  }\n\n  public getItemStacks(type: PassiveItemType): number {\n    return this.items.get(type) || 0;\n  }\n\n  public applyEffects(player: any): void {\n    this.items.forEach((stacks, type) => {\n      const itemData = PASSIVE_ITEMS[type];\n      itemData.effect(player, stacks);\n    });\n  }\n\n  public getAllItems(): Array<{ type: PassiveItemType; stacks: number }> {\n    const items: Array<{ type: PassiveItemType; stacks: number }> = [];\n    this.items.forEach((stacks, type) => {\n      items.push({ type, stacks });\n    });\n    return items;\n  }\n}\n","path":null,"size_bytes":3464,"size_tokens":null},"client/src/lib/game/rendering/ScreenShake.ts":{"content":"\nexport class ScreenShake {\n  private intensity: number = 0;\n  private duration: number = 0;\n  private offsetX: number = 0;\n  private offsetY: number = 0;\n\n  public shake(intensity: number, duration: number): void {\n    this.intensity = Math.max(this.intensity, intensity);\n    this.duration = Math.max(this.duration, duration);\n  }\n\n  public update(deltaTime: number): void {\n    if (this.duration > 0) {\n      this.duration -= deltaTime;\n      \n      const currentIntensity = this.intensity * (this.duration / 0.5);\n      this.offsetX = (Math.random() - 0.5) * currentIntensity * 2;\n      this.offsetY = (Math.random() - 0.5) * currentIntensity * 2;\n\n      if (this.duration <= 0) {\n        this.intensity = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n      }\n    }\n  }\n\n  public getOffset(): { x: number; y: number } {\n    return { x: this.offsetX, y: this.offsetY };\n  }\n\n  public isActive(): boolean {\n    return this.duration > 0;\n  }\n}\nexport class ScreenShakeSystem {\n  private intensity: number = 0;\n  private duration: number = 0;\n  private offsetX: number = 0;\n  private offsetY: number = 0;\n\n  public trigger(intensity: number, duration: number = 0.3) {\n    this.intensity = Math.max(this.intensity, intensity);\n    this.duration = Math.max(this.duration, duration);\n  }\n\n  public update(deltaTime: number) {\n    if (this.duration > 0) {\n      this.duration -= deltaTime;\n      \n      const shake = this.intensity * (this.duration / 0.3);\n      this.offsetX = (Math.random() - 0.5) * shake * 2;\n      this.offsetY = (Math.random() - 0.5) * shake * 2;\n    } else {\n      this.offsetX = 0;\n      this.offsetY = 0;\n      this.intensity = 0;\n    }\n  }\n\n  public getOffset(): { x: number; y: number } {\n    return { x: this.offsetX, y: this.offsetY };\n  }\n\n  public isActive(): boolean {\n    return this.duration > 0;\n  }\n}\n","path":null,"size_bytes":1842,"size_tokens":null},"client/src/lib/game/systems/WeaponEvolution.ts":{"content":"\nimport { IWeapon } from \"../core/interfaces/IWeapon\";\n\nexport type WeaponRarity = \"common\" | \"rare\" | \"epic\" | \"legendary\";\n\nexport interface WeaponEvolution {\n  baseWeapon: string;\n  evolvedWeapon: string;\n  requiredLevel: number;\n  requiredItem?: string;\n}\n\nexport interface WeaponRarityData {\n  rarity: WeaponRarity;\n  damageMultiplier: number;\n  color: string;\n  glowColor: string;\n}\n\nexport const WEAPON_RARITIES: Record<WeaponRarity, WeaponRarityData> = {\n  common: {\n    rarity: \"common\",\n    damageMultiplier: 1.0,\n    color: \"#ffffff\",\n    glowColor: \"#cccccc\"\n  },\n  rare: {\n    rarity: \"rare\",\n    damageMultiplier: 1.3,\n    color: \"#4287f5\",\n    glowColor: \"#6ea3ff\"\n  },\n  epic: {\n    rarity: \"epic\",\n    damageMultiplier: 1.6,\n    color: \"#9b59b6\",\n    glowColor: \"#c792ea\"\n  },\n  legendary: {\n    rarity: \"legendary\",\n    damageMultiplier: 2.0,\n    color: \"#f39c12\",\n    glowColor: \"#ffd700\"\n  }\n};\n\nexport const WEAPON_EVOLUTIONS: WeaponEvolution[] = [\n  {\n    baseWeapon: \"sylph_blooms\",\n    evolvedWeapon: \"divine_garden\",\n    requiredLevel: 8,\n    requiredItem: \"ancient_seed\"\n  },\n  {\n    baseWeapon: \"orbital\",\n    evolvedWeapon: \"celestial_rings\",\n    requiredLevel: 8,\n    requiredItem: \"star_fragment\"\n  },\n  {\n    baseWeapon: \"thunder_strike\",\n    evolvedWeapon: \"storm_caller\",\n    requiredLevel: 8,\n    requiredItem: \"storm_essence\"\n  },\n  {\n    baseWeapon: \"poison_cloud\",\n    evolvedWeapon: \"toxic_tempest\",\n    requiredLevel: 8,\n    requiredItem: \"venom_core\"\n  },\n  {\n    baseWeapon: \"laser_beam\",\n    evolvedWeapon: \"omega_beam\",\n    requiredLevel: 8,\n    requiredItem: \"energy_crystal\"\n  }\n];\n\nexport class WeaponEvolutionSystem {\n  private playerWeapons: Map<string, { weapon: IWeapon; level: number; rarity: WeaponRarity }> = new Map();\n  private inventory: Set<string> = new Set();\n\n  public addWeapon(weaponType: string, weapon: IWeapon, rarity: WeaponRarity = \"common\"): void {\n    this.playerWeapons.set(weaponType, { weapon, level: 1, rarity });\n  }\n\n  public upgradeWeapon(weaponType: string): boolean {\n    const weaponData = this.playerWeapons.get(weaponType);\n    if (!weaponData) return false;\n\n    weaponData.level++;\n    weaponData.weapon.upgrade();\n\n    const evolution = this.checkEvolution(weaponType, weaponData.level);\n    if (evolution) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public addItem(item: string): void {\n    this.inventory.add(item);\n  }\n\n  public hasItem(item: string): boolean {\n    return this.inventory.has(item);\n  }\n\n  private checkEvolution(weaponType: string, level: number): WeaponEvolution | null {\n    const evolution = WEAPON_EVOLUTIONS.find(\n      e => e.baseWeapon === weaponType && level >= e.requiredLevel\n    );\n\n    if (evolution && (!evolution.requiredItem || this.hasItem(evolution.requiredItem))) {\n      return evolution;\n    }\n\n    return null;\n  }\n\n  public getAvailableEvolutions(): WeaponEvolution[] {\n    const available: WeaponEvolution[] = [];\n\n    this.playerWeapons.forEach((data, weaponType) => {\n      const evolution = this.checkEvolution(weaponType, data.level);\n      if (evolution) {\n        available.push(evolution);\n      }\n    });\n\n    return available;\n  }\n\n  public applyRarityBonus(weapon: IWeapon, rarity: WeaponRarity): void {\n    const rarityData = WEAPON_RARITIES[rarity];\n    weapon.setDamage(weapon.getDamage() * rarityData.damageMultiplier);\n  }\n\n  public getWeaponData(weaponType: string) {\n    return this.playerWeapons.get(weaponType);\n  }\n}\n","path":null,"size_bytes":3473,"size_tokens":null},"client/src/lib/game/systems/WeaponSynergySystem.ts":{"content":"\nexport interface WeaponSynergy {\n  weapons: string[];\n  name: string;\n  description: string;\n  bonus: {\n    damageMultiplier?: number;\n    cooldownReduction?: number;\n    rangeIncrease?: number;\n    specialEffect?: string;\n  };\n}\n\nexport const WEAPON_SYNERGIES: WeaponSynergy[] = [\n  {\n    weapons: [\"thunder_strike\", \"poison_cloud\"],\n    name: \"Toxic Storm\",\n    description: \"Lightning electrifies poison clouds\",\n    bonus: {\n      damageMultiplier: 1.3,\n      specialEffect: \"electrified_poison\"\n    }\n  },\n  {\n    weapons: [\"ice_nova\", \"laser_beam\"],\n    name: \"Frozen Prism\",\n    description: \"Lasers shatter frozen enemies\",\n    bonus: {\n      damageMultiplier: 1.5,\n      specialEffect: \"shatter_frozen\"\n    }\n  },\n  {\n    weapons: [\"orbital\", \"boomerang\"],\n    name: \"Orbital Dance\",\n    description: \"Rotating weapons move faster\",\n    bonus: {\n      cooldownReduction: 0.2,\n      rangeIncrease: 1.2\n    }\n  },\n  {\n    weapons: [\"sylph_blooms\", \"poison_cloud\"],\n    name: \"Garden of Decay\",\n    description: \"Flowers spread poison\",\n    bonus: {\n      damageMultiplier: 1.25,\n      specialEffect: \"poison_flowers\"\n    }\n  },\n  {\n    weapons: [\"thunder_strike\", \"laser_beam\"],\n    name: \"Electromagnetic Fury\",\n    description: \"Lightning and lasers chain together\",\n    bonus: {\n      damageMultiplier: 1.4,\n      specialEffect: \"chain_lightning_laser\"\n    }\n  }\n];\n\nexport class WeaponSynergySystem {\n  private activeWeapons: Set<string> = new Set();\n  private activeSynergies: WeaponSynergy[] = [];\n\n  public addWeapon(weaponId: string): void {\n    this.activeWeapons.add(weaponId);\n    this.updateSynergies();\n  }\n\n  public removeWeapon(weaponId: string): void {\n    this.activeWeapons.delete(weaponId);\n    this.updateSynergies();\n  }\n\n  private updateSynergies(): void {\n    this.activeSynergies = WEAPON_SYNERGIES.filter(synergy => {\n      return synergy.weapons.every(weapon => this.activeWeapons.has(weapon));\n    });\n  }\n\n  public getActiveSynergies(): WeaponSynergy[] {\n    return this.activeSynergies;\n  }\n\n  public hasSynergy(weapons: string[]): boolean {\n    return this.activeSynergies.some(synergy => \n      synergy.weapons.every(w => weapons.includes(w))\n    );\n  }\n\n  public getSynergyBonus(weaponId: string): { damageMultiplier: number; cooldownReduction: number; rangeIncrease: number } {\n    let damageMultiplier = 1;\n    let cooldownReduction = 0;\n    let rangeIncrease = 1;\n\n    this.activeSynergies.forEach(synergy => {\n      if (synergy.weapons.includes(weaponId)) {\n        if (synergy.bonus.damageMultiplier) damageMultiplier *= synergy.bonus.damageMultiplier;\n        if (synergy.bonus.cooldownReduction) cooldownReduction += synergy.bonus.cooldownReduction;\n        if (synergy.bonus.rangeIncrease) rangeIncrease *= synergy.bonus.rangeIncrease;\n      }\n    });\n\n    return { damageMultiplier, cooldownReduction, rangeIncrease };\n  }\n}\n","path":null,"size_bytes":2874,"size_tokens":null},"client/src/lib/game/systems/AchievementSystem.ts":{"content":"\nexport interface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  requirement: (stats: any) => boolean;\n  reward?: {\n    type: 'currency' | 'character' | 'weapon';\n    value: string | number;\n  };\n}\n\nexport const ACHIEVEMENTS: Achievement[] = [\n  {\n    id: 'first_blood',\n    name: 'First Blood',\n    description: 'Kill your first enemy',\n    icon: '',\n    requirement: (stats) => stats.totalKills >= 1,\n    reward: { type: 'currency', value: 100 }\n  },\n  {\n    id: 'century',\n    name: 'Century',\n    description: 'Kill 100 enemies in total',\n    icon: '',\n    requirement: (stats) => stats.totalKills >= 100,\n    reward: { type: 'currency', value: 500 }\n  },\n  {\n    id: 'survivor',\n    name: 'Survivor',\n    description: 'Reach wave 10',\n    icon: '',\n    requirement: (stats) => stats.highestWave >= 10,\n    reward: { type: 'currency', value: 300 }\n  },\n  {\n    id: 'boss_slayer',\n    name: 'Boss Slayer',\n    description: 'Defeat your first boss',\n    icon: '',\n    requirement: (stats) => stats.bossesDefeated >= 1,\n    reward: { type: 'currency', value: 1000 }\n  },\n  {\n    id: 'level_master',\n    name: 'Level Master',\n    description: 'Reach level 20',\n    icon: '',\n    requirement: (stats) => stats.highestLevel >= 20,\n    reward: { type: 'currency', value: 800 }\n  },\n  {\n    id: 'marathon',\n    name: 'Marathon Runner',\n    description: 'Play for 30 minutes in one run',\n    icon: '',\n    requirement: (stats) => stats.longestRun >= 1800,\n    reward: { type: 'currency', value: 1500 }\n  },\n  {\n    id: 'untouchable',\n    name: 'Untouchable',\n    description: 'Complete wave 5 without taking damage',\n    icon: '',\n    requirement: (stats) => stats.perfectWaves >= 5,\n    reward: { type: 'currency', value: 2000 }\n  }\n];\n\nexport class AchievementSystem {\n  private unlockedAchievements: Set<string> = new Set();\n\n  public checkAchievements(stats: any): Achievement[] {\n    const newlyUnlocked: Achievement[] = [];\n\n    ACHIEVEMENTS.forEach(achievement => {\n      if (!this.unlockedAchievements.has(achievement.id) && achievement.requirement(stats)) {\n        this.unlockedAchievements.add(achievement.id);\n        newlyUnlocked.push(achievement);\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  public isUnlocked(achievementId: string): boolean {\n    return this.unlockedAchievements.has(achievementId);\n  }\n\n  public getUnlockedCount(): number {\n    return this.unlockedAchievements.size;\n  }\n\n  public getTotalCount(): number {\n    return ACHIEVEMENTS.length;\n  }\n\n  public load(achievements: string[]): void {\n    this.unlockedAchievements = new Set(achievements);\n  }\n}\n","path":null,"size_bytes":2658,"size_tokens":null},"client/src/lib/game/entities/enemies/ShieldedEnemy.ts":{"content":"import { BaseEntity } from '../../core/base/BaseEntity';\nimport { IEnemy } from '../../core/interfaces/IEnemy';\n\nexport class ShieldedEnemy extends BaseEntity implements IEnemy {\n  public collisionWidth: number;\n  public collisionHeight: number;\n  private speed: number;\n  private health: number;\n  private maxHealth: number;\n  private damage: number;\n  private scoreValue: number;\n  \n  private shieldActive: boolean = true;\n  private shieldTimer: number = 0;\n  private shieldDuration: number = 3;\n  private shieldCooldown: number = 5;\n  private shieldPulse: number = 0;\n\n  constructor(x: number, y: number) {\n    super(x, y, 95, 95);\n    this.collisionWidth = 38;\n    this.collisionHeight = 38;\n    \n    this.speed = 35;\n    this.health = 4;\n    this.maxHealth = 4;\n    this.damage = 25;\n    this.scoreValue = 45;\n    \n    this.shieldTimer = Math.random() * this.shieldDuration;\n  }\n\n  public update(deltaTime: number, playerPos: { x: number; y: number }): void {\n    if (!this.alive) return;\n\n    const dx = playerPos.x - this.x;\n    const dy = playerPos.y - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance > 0) {\n      const moveX = (dx / distance) * this.speed * deltaTime;\n      const moveY = (dy / distance) * this.speed * deltaTime;\n\n      this.x += moveX;\n      this.y += moveY;\n    }\n\n    this.shieldTimer += deltaTime;\n    this.shieldPulse += deltaTime * 5;\n\n    if (this.shieldActive) {\n      if (this.shieldTimer >= this.shieldDuration) {\n        this.shieldActive = false;\n        this.shieldTimer = 0;\n      }\n    } else {\n      if (this.shieldTimer >= this.shieldCooldown) {\n        this.shieldActive = true;\n        this.shieldTimer = 0;\n      }\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D, deltaTime: number): void {\n    if (!this.alive) return;\n\n    ctx.save();\n    \n    if (this.shieldActive) {\n      const pulseSize = 1 + Math.sin(this.shieldPulse) * 0.1;\n      const shieldRadius = (this.width / 2 + 15) * pulseSize;\n      \n      const gradient = ctx.createRadialGradient(\n        this.x, this.y, this.width / 2,\n        this.x, this.y, shieldRadius\n      );\n      gradient.addColorStop(0, \"rgba(0, 150, 255, 0.3)\");\n      gradient.addColorStop(0.7, \"rgba(0, 100, 255, 0.2)\");\n      gradient.addColorStop(1, \"rgba(0, 50, 255, 0)\");\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, shieldRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      ctx.strokeStyle = `rgba(0, 200, 255, ${0.5 + Math.sin(this.shieldPulse * 2) * 0.3})`;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, shieldRadius - 5, 0, Math.PI * 2);\n      ctx.stroke();\n      \n      for (let i = 0; i < 6; i++) {\n        const angle = (i / 6) * Math.PI * 2 + this.shieldPulse * 0.5;\n        const sparkX = this.x + Math.cos(angle) * (shieldRadius - 5);\n        const sparkY = this.y + Math.sin(angle) * (shieldRadius - 5);\n        \n        ctx.fillStyle = \"#00ffff\";\n        ctx.beginPath();\n        ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    ctx.fillStyle = this.shieldActive ? \"#4488cc\" : \"#666688\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = this.shieldActive ? \"#224466\" : \"#444466\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.width / 3, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.strokeStyle = this.shieldActive ? \"#66aaff\" : \"#888888\";\n    ctx.lineWidth = 3;\n    for (let i = 0; i < 4; i++) {\n      const angle = (i / 4) * Math.PI * 2 + Date.now() * 0.001;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.width / 2.5, angle, angle + 0.5);\n      ctx.stroke();\n    }\n    \n    ctx.fillStyle = this.shieldActive ? \"#aaddff\" : \"#aaaaaa\";\n    ctx.beginPath();\n    ctx.arc(this.x - 12, this.y - 8, 8, 0, Math.PI * 2);\n    ctx.arc(this.x + 12, this.y - 8, 8, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = \"#000000\";\n    ctx.beginPath();\n    ctx.arc(this.x - 12, this.y - 8, 4, 0, Math.PI * 2);\n    ctx.arc(this.x + 12, this.y - 8, 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    if (!this.shieldActive) {\n      const rechargePercent = this.shieldTimer / this.shieldCooldown;\n      const barWidth = this.width * 0.8;\n      const barHeight = 4;\n      \n      ctx.fillStyle = \"#333333\";\n      ctx.fillRect(this.x - barWidth / 2, this.y + this.height / 2 + 5, barWidth, barHeight);\n      \n      ctx.fillStyle = \"#0088ff\";\n      ctx.fillRect(this.x - barWidth / 2, this.y + this.height / 2 + 5, barWidth * rechargePercent, barHeight);\n    }\n\n    if (this.health < this.maxHealth) {\n      this.renderHealthBar(ctx);\n    }\n    \n    ctx.restore();\n  }\n\n  private renderHealthBar(ctx: CanvasRenderingContext2D): void {\n    const barWidth = this.width;\n    const barHeight = 3;\n    const healthPercent = this.health / this.maxHealth;\n\n    ctx.fillStyle = \"#333333\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth, barHeight);\n\n    ctx.fillStyle = \"#44ff44\";\n    ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - 12, barWidth * healthPercent, barHeight);\n  }\n\n  public takeDamage(amount: number): void {\n    if (this.shieldActive) {\n      return;\n    }\n    \n    this.health -= amount;\n    if (this.health <= 0) {\n      this.alive = false;\n    }\n  }\n\n  public getHealth(): number {\n    return this.health;\n  }\n\n  public getMaxHealth(): number {\n    return this.maxHealth;\n  }\n\n  public getDamage(): number {\n    return this.damage;\n  }\n\n  public getScoreValue(): number {\n    return this.scoreValue;\n  }\n\n  public getType(): string {\n    return \"shielded\";\n  }\n\n  public isShieldActive(): boolean {\n    return this.shieldActive;\n  }\n\n  public getShieldProgress(): number {\n    if (this.shieldActive) {\n      return 1 - (this.shieldTimer / this.shieldDuration);\n    } else {\n      return this.shieldTimer / this.shieldCooldown;\n    }\n  }\n}\n","path":null,"size_bytes":5925,"size_tokens":null},"client/src/lib/game/weapons/ThunderStrikeWeapon.ts":{"content":"\nimport { BaseWeapon } from \"../core/base/BaseWeapon\";\nimport { IProjectile } from \"../core/interfaces/IProjectile\";\n\nexport class ThunderStrikeWeapon extends BaseWeapon {\n  private strikeTimer: number = 0;\n  private strikeInterval: number = 2;\n  private strikeRadius: number = 150;\n  private strikeDamage: number = 40;\n  private lightningBolts: Array<{ x: number; y: number; lifetime: number }> = [];\n\n  constructor() {\n    super();\n    this.damage = 40;\n    this.fireRate = 0.5;\n  }\n\n  public update(deltaTime: number, enemies: any[], playerX: number, playerY: number): void {\n    this.strikeTimer += deltaTime;\n\n    if (this.strikeTimer >= this.strikeInterval && enemies.length > 0) {\n      const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];\n      if (randomEnemy && randomEnemy.isAlive()) {\n        this.lightningBolts.push({\n          x: randomEnemy.x,\n          y: randomEnemy.y,\n          lifetime: 0.3\n        });\n\n        enemies.forEach(enemy => {\n          if (!enemy.isAlive()) return;\n          const dx = enemy.x - randomEnemy.x;\n          const dy = enemy.y - randomEnemy.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance <= this.strikeRadius) {\n            enemy.takeDamage(this.strikeDamage);\n          }\n        });\n\n        this.strikeTimer = 0;\n      }\n    }\n\n    this.lightningBolts = this.lightningBolts.filter(bolt => {\n      bolt.lifetime -= deltaTime;\n      return bolt.lifetime > 0;\n    });\n  }\n\n  public render(ctx: CanvasRenderingContext2D, cameraX: number, cameraY: number): void {\n    this.lightningBolts.forEach(bolt => {\n      ctx.save();\n      ctx.strokeStyle = \"#ffff00\";\n      ctx.lineWidth = 3;\n      ctx.shadowColor = \"#ffff00\";\n      ctx.shadowBlur = 10;\n\n      ctx.beginPath();\n      ctx.moveTo(bolt.x, bolt.y - 500);\n      \n      for (let i = 0; i < 5; i++) {\n        const offsetX = (Math.random() - 0.5) * 30;\n        const offsetY = i * 100;\n        ctx.lineTo(bolt.x + offsetX, bolt.y - 500 + offsetY);\n      }\n      \n      ctx.stroke();\n\n      ctx.strokeStyle = \"rgba(255, 255, 0, 0.5)\";\n      ctx.beginPath();\n      ctx.arc(bolt.x, bolt.y, this.strikeRadius, 0, Math.PI * 2);\n      ctx.stroke();\n\n      ctx.restore();\n    });\n  }\n\n  public fire(x: number, y: number, direction: { x: number; y: number }): IProjectile[] {\n    return [];\n  }\n\n  public upgrade(): void {\n    this.strikeDamage += 10;\n    this.strikeRadius += 20;\n    this.strikeInterval = Math.max(0.5, this.strikeInterval * 0.9);\n  }\n\n  public getType(): string {\n    return \"thunder_strike\";\n  }\n}\n","path":null,"size_bytes":2565,"size_tokens":null},"client/src/lib/game/systems/WeaponUnlockSystem.ts":{"content":"\nexport interface WeaponUnlockRequirement {\n  weaponId: string;\n  name: string;\n  description: string;\n  unlocked: boolean;\n  requirements: {\n    level?: number;\n    kills?: number;\n    bossKills?: number;\n    wave?: number;\n    currency?: number;\n  };\n}\n\nexport const WEAPON_UNLOCKS: WeaponUnlockRequirement[] = [\n  {\n    weaponId: \"sylph_blooms\",\n    name: \"Sylph Blooms\",\n    description: \"Magical flower turrets\",\n    unlocked: true,\n    requirements: {}\n  },\n  {\n    weaponId: \"orbital\",\n    name: \"Orbital Shield\",\n    description: \"Rotating protective orbs\",\n    unlocked: true,\n    requirements: {}\n  },\n  {\n    weaponId: \"thunder_strike\",\n    name: \"Thunder Strike\",\n    description: \"Lightning bolts from above\",\n    unlocked: false,\n    requirements: { level: 5, kills: 50 }\n  },\n  {\n    weaponId: \"poison_cloud\",\n    name: \"Poison Cloud\",\n    description: \"Toxic area damage\",\n    unlocked: false,\n    requirements: { level: 8, kills: 100 }\n  },\n  {\n    weaponId: \"laser_beam\",\n    name: \"Laser Beam\",\n    description: \"Piercing laser damage\",\n    unlocked: false,\n    requirements: { level: 10, bossKills: 1 }\n  },\n  {\n    weaponId: \"ice_nova\",\n    name: \"Ice Nova\",\n    description: \"Freezing wave attack\",\n    unlocked: false,\n    requirements: { wave: 15, kills: 200 }\n  },\n  {\n    weaponId: \"boomerang\",\n    name: \"Boomerang\",\n    description: \"Returning projectile\",\n    unlocked: false,\n    requirements: { currency: 1000, kills: 150 }\n  }\n];\n\nexport class WeaponUnlockSystem {\n  private unlocks: Map<string, boolean> = new Map();\n\n  constructor() {\n    WEAPON_UNLOCKS.forEach(weapon => {\n      this.unlocks.set(weapon.weaponId, weapon.unlocked);\n    });\n  }\n\n  public checkUnlocks(stats: {\n    level: number;\n    totalKills: number;\n    bossesDefeated: number;\n    wave: number;\n    currency: number;\n  }): string[] {\n    const newlyUnlocked: string[] = [];\n\n    WEAPON_UNLOCKS.forEach(weapon => {\n      if (this.unlocks.get(weapon.weaponId)) return;\n\n      const req = weapon.requirements;\n      let canUnlock = true;\n\n      if (req.level && stats.level < req.level) canUnlock = false;\n      if (req.kills && stats.totalKills < req.kills) canUnlock = false;\n      if (req.bossKills && stats.bossesDefeated < req.bossKills) canUnlock = false;\n      if (req.wave && stats.wave < req.wave) canUnlock = false;\n      if (req.currency && stats.currency < req.currency) canUnlock = false;\n\n      if (canUnlock) {\n        this.unlocks.set(weapon.weaponId, true);\n        newlyUnlocked.push(weapon.weaponId);\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  public isUnlocked(weaponId: string): boolean {\n    return this.unlocks.get(weaponId) || false;\n  }\n\n  public getUnlockedWeapons(): string[] {\n    const unlocked: string[] = [];\n    this.unlocks.forEach((isUnlocked, weaponId) => {\n      if (isUnlocked) unlocked.push(weaponId);\n    });\n    return unlocked;\n  }\n\n  public getProgress(weaponId: string, stats: any): { current: number; required: number; type: string }[] {\n    const weapon = WEAPON_UNLOCKS.find(w => w.weaponId === weaponId);\n    if (!weapon) return [];\n\n    const progress: { current: number; required: number; type: string }[] = [];\n    const req = weapon.requirements;\n\n    if (req.level) progress.push({ current: stats.level, required: req.level, type: \"Level\" });\n    if (req.kills) progress.push({ current: stats.totalKills, required: req.kills, type: \"Kills\" });\n    if (req.bossKills) progress.push({ current: stats.bossesDefeated, required: req.bossKills, type: \"Boss Kills\" });\n    if (req.wave) progress.push({ current: stats.wave, required: req.wave, type: \"Wave\" });\n    if (req.currency) progress.push({ current: stats.currency, required: req.currency, type: \"Currency\" });\n\n    return progress;\n  }\n}\n","path":null,"size_bytes":3750,"size_tokens":null},"client/src/components/ComboDisplay.tsx":{"content":"import { useEffect, useState } from 'react';\nimport { useGameState } from '../lib/stores/useGameState';\n\ninterface ComboDisplayProps {\n  combo: number;\n  multiplier: number;\n  timeRemaining: number;\n}\n\nexport default function ComboDisplay({ combo, multiplier, timeRemaining }: ComboDisplayProps) {\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    setVisible(combo > 0);\n  }, [combo]);\n\n  if (!visible || combo === 0) return null;\n\n  const timePercentage = Math.max(0, Math.min(100, (timeRemaining / 3) * 100));\n  const isHighCombo = combo >= 20;\n  const isMediumCombo = combo >= 10;\n\n  return (\n    <div className=\"fixed top-1/2 right-8 transform -translate-y-1/2 z-40\">\n      <div className={`bg-black bg-opacity-80 rounded-lg p-4 border-2 ${\n        isHighCombo ? 'border-yellow-400 animate-pulse' : \n        isMediumCombo ? 'border-orange-400' : 'border-blue-400'\n      }`}>\n        <div className=\"text-center\">\n          <div className=\"text-sm text-gray-400 uppercase\">Combo</div>\n          <div className={`text-5xl font-bold ${\n            isHighCombo ? 'text-yellow-400' : \n            isMediumCombo ? 'text-orange-400' : 'text-blue-400'\n          }`}>\n            {combo}\n          </div>\n          <div className=\"text-lg text-white mt-1\">\n            {multiplier.toFixed(2)}x\n          </div>\n\n          <div className=\"mt-2 w-full h-2 bg-gray-700 rounded-full overflow-hidden\">\n            <div \n              className={`h-full transition-all duration-100 ${\n                isHighCombo ? 'bg-yellow-400' : \n                isMediumCombo ? 'bg-orange-400' : 'bg-blue-400'\n              }`}\n              style={{ width: `${timePercentage}%` }}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}","path":null,"size_bytes":1760,"size_tokens":null},"client/src/components/BossHealthBar.tsx":{"content":"import { useGameState } from \"../lib/stores/useGameState\";\nimport { useEffect, useState } from \"react\";\n\nexport default function BossHealthBar() {\n  const { isBossActive, currentBossHealth, currentBossMaxHealth, bossName } = useGameState();\n  const [displayHealth, setDisplayHealth] = useState(currentBossHealth);\n  const [isLowHealth, setIsLowHealth] = useState(false);\n  const [damageFlash, setDamageFlash] = useState(false);\n\n  useEffect(() => {\n    if (currentBossHealth < displayHealth) {\n      setDamageFlash(true);\n      const timeout = setTimeout(() => setDamageFlash(false), 150);\n      return () => clearTimeout(timeout);\n    }\n  }, [currentBossHealth, displayHealth]);\n\n  useEffect(() => {\n    const animationFrame = requestAnimationFrame(() => {\n      if (displayHealth !== currentBossHealth) {\n        const diff = currentBossHealth - displayHealth;\n        const step = diff * 0.1;\n        if (Math.abs(diff) < 1) {\n          setDisplayHealth(currentBossHealth);\n        } else {\n          setDisplayHealth(prev => prev + step);\n        }\n      }\n    });\n    return () => cancelAnimationFrame(animationFrame);\n  }, [displayHealth, currentBossHealth]);\n\n  useEffect(() => {\n    const healthPercent = currentBossHealth / currentBossMaxHealth;\n    setIsLowHealth(healthPercent <= 0.25);\n  }, [currentBossHealth, currentBossMaxHealth]);\n\n  if (!isBossActive) return null;\n\n  const healthPercentage = Math.max(0, (displayHealth / currentBossMaxHealth) * 100);\n  const actualHealthPercentage = Math.max(0, (currentBossHealth / currentBossMaxHealth) * 100);\n\n  return (\n    <div className=\"absolute top-16 left-1/2 transform -translate-x-1/2 w-full max-w-2xl px-4 z-50\">\n      <div \n        className={`bg-black bg-opacity-80 rounded-lg p-4 border-2 ${\n          isLowHealth ? 'border-red-500 animate-pulse' : 'border-purple-600'\n        } ${damageFlash ? 'bg-red-900 bg-opacity-60' : ''}`}\n      >\n        <div className=\"flex items-center justify-between mb-2\">\n          <div className=\"flex items-center space-x-3\">\n            <span className=\"text-3xl\">\n              {bossName.includes(\"Necromancer\") && \"\"}\n              {bossName.includes(\"Vampire\") && \"\"}\n              {bossName.includes(\"Golem\") && \"\"}\n            </span>\n            <div>\n              <h2 className=\"text-xl font-bold text-white\">{bossName}</h2>\n              <p className=\"text-xs text-gray-400\">BOSS</p>\n            </div>\n          </div>\n          <div className=\"text-right\">\n            <span className={`text-2xl font-bold ${isLowHealth ? 'text-red-500' : 'text-white'}`}>\n              {Math.ceil(actualHealthPercentage)}%\n            </span>\n          </div>\n        </div>\n        \n        <div className=\"relative h-6 bg-gray-900 rounded-full overflow-hidden border border-gray-700\">\n          <div \n            className=\"absolute inset-0 bg-gradient-to-r from-red-800 to-red-600 transition-all duration-200\"\n            style={{ width: `${healthPercentage}%` }}\n          />\n          \n          <div \n            className={`absolute inset-0 bg-gradient-to-r from-red-600 to-red-400 transition-all duration-75 ${\n              isLowHealth ? 'animate-pulse' : ''\n            }`}\n            style={{ width: `${actualHealthPercentage}%` }}\n          />\n          \n          <div \n            className=\"absolute inset-0 bg-gradient-to-b from-white/20 to-transparent\"\n            style={{ width: `${actualHealthPercentage}%` }}\n          />\n          \n          {isLowHealth && (\n            <div className=\"absolute inset-0 flex items-center justify-center\">\n              <span className=\"text-white text-sm font-bold drop-shadow-lg animate-pulse\">\n                LOW HEALTH!\n              </span>\n            </div>\n          )}\n        </div>\n        \n        <div className=\"flex justify-between mt-1 text-xs text-gray-400\">\n          <span>{Math.ceil(currentBossHealth)} HP</span>\n          <span>{Math.ceil(currentBossMaxHealth)} MAX</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":4007,"size_tokens":null},"client/src/components/LevelUpEffect.tsx":{"content":"\nimport { useEffect, useState } from 'react';\n\nexport default function LevelUpEffect() {\n  const [visible, setVisible] = useState(false);\n  const [level, setLevel] = useState(1);\n\n  useEffect(() => {\n    const handleLevelUp = (event: CustomEvent) => {\n      setLevel(event.detail.level);\n      setVisible(true);\n      setTimeout(() => setVisible(false), 2000);\n    };\n\n    window.addEventListener('levelUp' as any, handleLevelUp);\n    return () => window.removeEventListener('levelUp' as any, handleLevelUp);\n  }, []);\n\n  if (!visible) return null;\n\n  return (\n    <div className=\"fixed inset-0 pointer-events-none z-50 flex items-center justify-center\">\n      <div className=\"animate-pulse\">\n        <div className=\"text-8xl font-bold text-yellow-400 drop-shadow-[0_0_30px_rgba(255,215,0,0.8)]\">\n          LEVEL UP!\n        </div>\n        <div className=\"text-6xl font-bold text-center text-white mt-4\">\n          Level {level}\n        </div>\n      </div>\n      \n      {/* Particle burst effect */}\n      <div className=\"absolute inset-0\">\n        {[...Array(20)].map((_, i) => (\n          <div\n            key={i}\n            className=\"absolute w-4 h-4 bg-yellow-400 rounded-full animate-ping\"\n            style={{\n              left: '50%',\n              top: '50%',\n              animationDelay: `${i * 0.05}s`,\n              transform: `translate(-50%, -50%) rotate(${i * 18}deg) translateY(-100px)`,\n            }}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":1478,"size_tokens":null}},"version":2}